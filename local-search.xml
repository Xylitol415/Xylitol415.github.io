<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构与算法之C++实现</title>
    <link href="/Algorithm/DataStruct_CPP/"/>
    <url>/Algorithm/DataStruct_CPP/</url>
    
    <content type="html"><![CDATA[<h2 id="cpp模板">CPP模板</h2><h3 id="一基础算法">一、基础算法</h3><h4 id="快速排序">1.快速排序</h4><p>1.1 Hoare Partition Scheme:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">while</span>(i &lt; j) <br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>1.2 Lomuto Partition Scheme:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(r &lt;= l) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> x = l, y = r, z = nums[l];<br>    <span class="hljs-keyword">while</span>(x &lt; y) &#123;<br>        <span class="hljs-keyword">while</span>(x &lt; y &amp;&amp; nums[y] &gt;= z) y--;<br>        <span class="hljs-keyword">if</span>(x &lt; y) nums[x++] = nums[y];<br>        <span class="hljs-keyword">while</span>(x &lt; y &amp;&amp; nums[x] &lt;= z) x++;<br>        <span class="hljs-keyword">if</span>(x &lt; y) nums[y--] = nums[x];<br>    &#125;<br>    nums[x] = z;<br>    <span class="hljs-built_in">quick_sort</span>(nums, l, x - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(nums, x + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="归并排序">2.归并排序</h4><p>归并属于分治算法，有三个步骤</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归的终止情况</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//第一步：分成子问题</span><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//第二步：递归处理子问题</span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid ), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">//第三步：合并子问题</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>, tmp[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];<br><br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(r - l &lt;= <span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-keyword">if</span>(r - l == <span class="hljs-number">1</span> &amp;&amp; nums[l] &gt; nums[r]) <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">merge_sort</span>(nums, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> p1 = l, p2 = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *temp = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (r - l + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">while</span>(p1 &lt;= mid || p2 &lt;= r) <br>    &#123;<br>        <span class="hljs-keyword">if</span>(p2 &gt; r || (p1 &lt;= mid &amp;&amp; nums[p1] &lt;= nums[p2])) temp[k++] = nums[p1++];<br>        <span class="hljs-keyword">else</span> temp[k++] = nums[p2++];<br>    &#125;<br>    <br>    <span class="hljs-built_in">memcpy</span>(nums + l, temp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (r - l + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">free</span>(temp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="整数二分">3.整数二分</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="浮点数二分">4.浮点数二分</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="高精度算法">5.高精度算法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="前缀和">6.前缀和</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 一维前缀和</span><br>S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 二维前缀和</span><br><span class="hljs-comment">// S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h4 id="差分">7.差分</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//一维：给区间[l, r]中的每个数加上c：</span><br>B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br><br><span class="hljs-comment">// 二维：给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></div></td></tr></table></figure><p><strong>模板题：</strong>输入一个长度为 <code>n</code> 的整数序列。接下来输入<code>m</code>个操作，每个操作包含三个整数 <code>l,r,c</code>，表示将序列中 <code>[l,r]</code>之间的每个数加上<code>c</code>。请你输出进行完所有操作后的序列。</p><p><strong>输入样例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1<br></code></pre></div></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3 4 5 3 4 2<br></code></pre></div></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N], b[N];<span class="hljs-comment">// a[]前缀和数组，b[]差分数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-comment">// 构造差分数组 b[i] = a[i] - a[i - 1]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">insert</span>(i, i, a[i]); <br>    <span class="hljs-keyword">while</span> (m -- ) <br>    &#123;<br>        <span class="hljs-type">int</span> l, r, c;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(l, r, c);<br>    &#125;<br>    <span class="hljs-comment">// 对差分数组b[i]求前缀和得到a[i]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = b[i] + a[i - <span class="hljs-number">1</span>]; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="位运算">8.位运算</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></div></td></tr></table></figure><h4 id="双指针">9.双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></div></td></tr></table></figure><h4 id="离散化">10.离散化</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="区间合并">11.区间合并</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="二数据结构">二、数据结构</h3><h4 id="单链表">单链表</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="双链表">双链表</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="栈">栈</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="队列">队列</h4><p>普通队列</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>循环队列</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++ ] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="单调栈">单调栈</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="单调队列">单调队列</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="滑动窗口">滑动窗口</h4><p>基本模式：双指针算法</p><p>例如：力扣第三题<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>        cnt[s[right]]++;<br>        <span class="hljs-keyword">while</span>(cnt[s[right]] &gt; <span class="hljs-number">1</span>) cnt[s[left]]--, left++;<br>        res = <span class="hljs-built_in">max</span>(res, right - left + <span class="hljs-number">1</span>);<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>类型一</strong>：窗口大小固定，使用单调队列（双端队列）或优先队列实现</p><p>参考力扣<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239.滑动窗口最大值</a></p><p>数组模拟双端队列实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> hh, tt;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    hh = <span class="hljs-number">0</span>, tt= <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(q[hh] &lt;= i - k) hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) tt--;<br>        q[++tt] = i;<br>        <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= k) res.<span class="hljs-built_in">push_back</span>(nums[q[hh]]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>优先队列实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        q.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;q.<span class="hljs-built_in">top</span>().first&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; ++i) &#123;<br>        q.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">top</span>().second &lt;= i - k) &#123;<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>STL双端队列实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    deque&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="hljs-built_in">back</span>()]) &#123;<br>            q.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;nums[q.<span class="hljs-built_in">front</span>()]&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="hljs-built_in">back</span>()]) &#123;<br>            q.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">front</span>() &lt;= i - k) &#123;<br>            q.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>类型二</strong>：窗口大小变化：但只会扩大</p><p>参考</p><ul><li>力扣<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/submissions/">424.替换后的最长重复字符</a></li></ul><p><strong>类型三</strong>：窗口动态变化：需动态插入/删除元素</p><p>参考</p><ul><li>力扣<a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></li><li>力扣<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></li></ul><h4 id="kmp">KMP</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="trie树字典树">Trie树（字典树）</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cpp面向对象实现方式1（lc720<a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">词典中最长的单词</a>）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义Trie树节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TrieNode* son[<span class="hljs-number">26</span>];<span class="hljs-comment">// 字符类型的Trie子节点，长度26个（小写/大写）字母</span><br>    <span class="hljs-type">int</span> isEnd;<span class="hljs-comment">// 结束标记，表示当前位置存在一个单词</span><br>    <span class="hljs-built_in">TrieNode</span>() &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span>; i++) son[i] = <span class="hljs-literal">nullptr</span>;<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TrieNode* root;<span class="hljs-comment">// 定义Trie树根节点，在构造函数或使用Trie树的函数中初始化root</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Trie插入函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string x)</span> </span>&#123;<br>        TrieNode* p = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> u = x[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p-&gt;son[u] == <span class="hljs-literal">nullptr</span>) p-&gt;son[u] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            p = p-&gt;son[u];<br>        &#125;<br>        p-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">longestWord</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<span class="hljs-comment">// 初始化root</span><br>        <span class="hljs-comment">// 使用Trie树完成任务......</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> w : words) <span class="hljs-built_in">insert</span>(w);<br><span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>方式2(力扣官方解答提供)：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; t;<br>    <span class="hljs-type">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">t</span>(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        Trie* p = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;t[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;<br>                p-&gt;t[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            p = p-&gt;t[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        p-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>        Trie* p = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;t[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p-&gt;t[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;isEnd;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ret;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie* t, string&amp; cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() &gt; ret.<span class="hljs-built_in">size</span>()) &#123;<br>            ret = cur;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (t-&gt;t[i] &amp;&amp; t-&gt;t[i]-&gt;isEnd) &#123;<br>                cur.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-string">&#x27;a&#x27;</span>);<br>                <span class="hljs-built_in">dfs</span>(t-&gt;t[i], cur);<br>                cur.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">longestWord</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        Trie* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; w : words) &#123;<br>            t-&gt;<span class="hljs-built_in">insert</span>(w);<br>        &#125;<br>        string r;<br>        <span class="hljs-built_in">dfs</span>(t, r);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="并查集">并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// (1)朴素并查集：</span><br><br>    <span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br><span class="hljs-comment">// (2)维护size的并查集：</span><br><br>    <span class="hljs-type">int</span> p[N], size[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br><span class="hljs-comment">// (3)维护到祖宗节点距离的并查集：</span><br><br>    <span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        d[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></div></td></tr></table></figure><h4 id="模拟堆">模拟堆</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></div></td></tr></table></figure><h4 id="一般哈希">一般哈希</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">(<span class="hljs-number">1</span>) 拉链法<br>    <span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br>    <span class="hljs-comment">// 向哈希表中插入一个数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        e[idx] = x;<br>        ne[idx] = h[k];<br>        h[k] = idx ++ ;<br>    &#125;<br><br>    <span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>            <span class="hljs-keyword">if</span> (e[i] == x)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>(<span class="hljs-number">2</span>) 开放寻址法<br>    <span class="hljs-type">int</span> h[N];<br><br>    <span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> t = (x % N + N) % N;<br>        <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>        &#123;<br>            t ++ ;<br>            <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="字符串哈希">字符串哈希</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">核心思想：将字符串看成P进制数，P的经验值是<span class="hljs-number">131</span>或<span class="hljs-number">13331</span>，取这两个值的冲突概率低<br>小技巧：取模的数用<span class="hljs-number">2</span>^<span class="hljs-number">64</span>，这样直接用<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>存储，溢出的结果就是取模的结果<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="c-stl简介">C++ STL简介</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vector, 变长数组，倍增的思想<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()/back()<br>    push_back()/pop_back()<br>    begin()/end()<br>    []<br>    支持比较运算，按字典序<br><br>pair&lt;int, int&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br>string，字符串<br>    size()/length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，(子串长度))  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;<br><br>stack, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素<br><br>deque, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back()/pop_back()<br>    push_front()/pop_front()<br>    begin()/end()<br>    []<br><br><span class="hljs-built_in">set</span>, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()/end()<br>    ++, -- 返回前驱和后继，时间复杂度 O(logn)<br><br>    <span class="hljs-built_in">set</span>/multiset<br>        insert()  插入一个数<br>        find()  查找一个数<br>        count()  返回某一个数的个数<br>        erase()<br>            (1) 输入是一个数x，删除所有x   O(k + logn)<br>            (2) 输入一个迭代器，删除这个迭代器<br>        lower_bound()/upper_bound()<br>            lower_bound(x)  返回大于等于x的最小的数的迭代器<br>            upper_bound(x)  返回大于x的最小的数的迭代器<br>    map/multimap<br>        insert()  插入的数是一个pair<br>        erase()  输入的参数是pair或者迭代器<br>        find()<br>        []  注意multimap不支持此操作。 时间复杂度是 O(logn)<br>        lower_bound()/upper_bound()<br><br>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(1)<br>    不支持 lower_bound()/upper_bound()， 迭代器的++，--<br><br>bitset, 圧位<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    count()  返回有多少个1<br><br>    any()  判断是否至少有一个1<br>    none()  判断是否全为0<br><br>    <span class="hljs-built_in">set</span>()  把所有位置成1<br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    reset()  把所有位变成0<br>    flip()  等价于~<br>    flip(k) 把第k位取反<br></code></pre></div></td></tr></table></figure><h4 id="pb_ds库">pb_ds库</h4><p>pb_ds 库全称 Policy-Based Data Structures， 是<strong>GNU-C++</strong>自带的一个<strong>C++</strong>的扩展库，其中封装了很多数据结构，比如哈希（Hash）表，平衡二叉树，字典树（Trie 树），堆（优先队列）等，比<strong>STL</strong>里面的功能更强大。pb_ds 只在使用 libstdc++ 为标准库的编译器下可以用。</p><p><strong>哈希表</strong></p><p>头文件及使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br>cc_hash_table&lt;string,<span class="hljs-type">int</span>&gt;mp1;<span class="hljs-comment">//拉链法</span><br>gp_hash_table&lt;string,<span class="hljs-type">int</span>&gt;mp2;<span class="hljs-comment">//查探法(快一些)</span><br></code></pre></div></td></tr></table></figure><p><strong>堆</strong></p><p>头文件及使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>&gt;q;<span class="hljs-comment">//因为放置和std重复，故需要带上命名空间</span><br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt;,pairing_heap_tag&gt; pq;<span class="hljs-comment">//最快</span><br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt;,binary_heap_tag&gt; pq;<br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt;,binomial_heap_tag&gt; pq;<br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt;,rc_binomial_heap_tag&gt; pq;<br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt;,thin_heap_tag&gt; pq;<br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>,greater&lt;<span class="hljs-type">int</span>&gt; &gt; pq;<br></code></pre></div></td></tr></table></figure><p><code>pb_ds</code>库的堆提供了五种tag，分别是<code>binary_heap_tag</code>，<code>binomal_heap_tag</code>，<code>pairing_heap_tag</code>，<code>thin_heap_tag</code>，<code>rc_binomal_heap_tag</code> ， 因为重名的原因一定要加上 <code>__gnu_pbds::</code>。</p><p>常用操作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">push</span>()  <span class="hljs-comment">//会返回一个迭代器</span><br><span class="hljs-built_in">top</span>()  <span class="hljs-comment">//同 stl </span><br><span class="hljs-built_in">size</span>()  <span class="hljs-comment">//同 stl </span><br><span class="hljs-built_in">empty</span>() <span class="hljs-comment">//同 stl </span><br><span class="hljs-built_in">clear</span>()  <span class="hljs-comment">//同 stl </span><br><span class="hljs-built_in">pop</span>()  <span class="hljs-comment">//同 stl </span><br><span class="hljs-built_in">join</span>(priority_queue &amp;other)  <span class="hljs-comment">//合并两个堆,other会被清空</span><br><span class="hljs-built_in">split</span>(Pred prd,priority_queue &amp;other)  <span class="hljs-comment">//分离出两个堆</span><br><span class="hljs-built_in">modify</span>(point_iterator it,<span class="hljs-type">const</span> key)  <span class="hljs-comment">//修改一个节点的值</span><br>__gnu_pbds::priority_queue&lt;<span class="hljs-type">int</span>&gt;::point_iterator it;  <span class="hljs-comment">// 优先队列的迭代器</span><br></code></pre></div></td></tr></table></figure><p><strong>红黑树</strong></p><p>头文件及定义方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br><br>tree&lt;<span class="hljs-type">int</span>, null_type, less&lt;<span class="hljs-type">int</span>&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; t;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义一颗红黑树</span><br><span class="hljs-comment">int 关键字类型</span><br><span class="hljs-comment">null_type无映射(低版本g++为null_mapped_type)</span><br><span class="hljs-comment">less&lt;int&gt;从小到大排序</span><br><span class="hljs-comment">rb_tree_tag 红黑树（splay_tree_tag）</span><br><span class="hljs-comment">tree_order_statistics_node_update结点更新</span><br><span class="hljs-comment">插入t.insert();</span><br><span class="hljs-comment">删除t.erase();</span><br><span class="hljs-comment">求k在树中是第几大:t.order_of_key();</span><br><span class="hljs-comment">求树中的第k大:t.find_by_order();</span><br><span class="hljs-comment">前驱:t.lower_bound();</span><br><span class="hljs-comment">后继t.upper_bound();</span><br><span class="hljs-comment">a.join(b)b并入a 前提是两棵树的key的取值范围不相交</span><br><span class="hljs-comment">a.split(v,b)key小于等于v的元素属于a，其余的属于b</span><br><span class="hljs-comment">T.lower_bound(x)   &gt;=x的min的迭代器</span><br><span class="hljs-comment">T.upper_bound((x)  &gt;x的min的迭代器</span><br><span class="hljs-comment">T.find_by_order(k) 有k个数比它小的数,可用于找中位数</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><blockquote><p>第一个参数代表key的类型 第二个参数表示value的类型。这里不需要映射值，也就填null_type。在老版本G++中这个需要替换为null_mapped_type（如BZOJ）。 第三个参数表示key的排序方式，从小到大。 第四个参数表示使用哪种数据结构，rb_tree_tag表示红黑树。 第五个参数表示如何更新保存节点信息，填写tree_order_statistics_node_update会额外获得order_of_key()和find_by_order()两个功能。</p></blockquote><p>迭代器的定义和使用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">tree&lt;<span class="hljs-type">int</span>,null_type,less&lt;<span class="hljs-type">int</span>&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;::iterator it;<br><span class="hljs-comment">// 或者便捷使用auto</span><br><span class="hljs-keyword">auto</span> it = t.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// tree包含set的全部功能，如lower_bound, upper_bound, insert, erase, find, begin, end, rbegin等。</span><br><span class="hljs-comment">// 查询第k+1小的数，可用于找中位数，使用find_by_order()函数，返回的为迭代器。</span><br></code></pre></div></td></tr></table></figure><p>参考博客<a href="https://blog.csdn.net/riba2534/article/details/80454602">pb_ds库的一些常用方法</a></p><h4 id="unordered_setpii及unordered_mappii-t使用">unordered_set&lt;PII&gt;及unordered_map&lt;PII, T&gt;使用</h4><p>使用PII作为hashset的参数时需要自定义哈希函数，使用如下方式定义：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//自定义哈希函数，元素类型为 pair&lt;T1, T2&gt; a(X1, X2);</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(pair&lt;T1, T2&gt; <span class="hljs-type">const</span> &amp;p)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(p.first + <span class="hljs-number">1</span>); <span class="hljs-comment">//用默认的 hash 处理 pair 中的第一个数据 X1</span><br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(p.second);<span class="hljs-comment">//用默认的 hash 处理 pair 中的第二个数据 X2</span><br>        <span class="hljs-keyword">return</span> h1 ^ h2;<br>        <span class="hljs-comment">//return p.first * 100 + p.second;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用时传入哈希函数</span><br>    unordered_set&lt;PDD, pair_hash&gt; st;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同理，unordered_map&lt;PII, T&gt;使用PII作为键时应定义如下哈希函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p.first * <span class="hljs-number">100</span> + p.second;<br>    &#125;<br>&#125;;<br>unordered_map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>, pair_hash&gt; ump;<br></code></pre></div></td></tr></table></figure><h3 id="三搜索与图论">三、搜索与图论</h3><p>树与图的存储</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/Algorithm/DynamicProgramming/"/>
    <url>/Algorithm/DynamicProgramming/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划">动态规划</h2><h3 id="背包问题">背包问题</h3><h3 id="线性dp">线性DP</h3><h3 id="区间dp">区间DP</h3><h3 id="树形dp">树形DP</h3><h3 id="状态压缩dp">状态压缩DP</h3><h3 id="数位dp">数位DP</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法之数学知识</title>
    <link href="/Algorithm/Mathematics/"/>
    <url>/Algorithm/Mathematics/</url>
    
    <content type="html"><![CDATA[<h2 id="数学知识">数学知识</h2><h3 id="素数质数相关">素数（质数）相关</h3><h4 id="试除法判定质数">试除法判定质数</h4><p>质数：在大于<code>1</code>的整数中，如果只包含<code>1</code>和<code>本身</code>这两个约数，就被称为质数，也可以叫做素数</p><p>约数都是成对出现的，所以只需要枚举每一对中较小的那一个，就可以将时间复杂度从<span class="math inline">\(O(n)\)</span>降到<span class="math inline">\(O(sqrt(n))\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrim</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="试除法分解质因数">试除法分解质因数</h4><p>例题<a href="https://www.acwing.com/problem/content/869/">acw867. 分解质因数</a>：给定 <span class="math inline">\(n\)</span> 个正整数<span class="math inline">\(a_i\)</span>，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。</p><p>数据范围：<span class="math inline">\(1\leq n\leq 100, 2\leq a_i \leq 2 \times 10^9\)</span></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>                x /= i;<br>                s++;<br>            &#125;<br>            System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) System.out.println(x + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-number">1</span>);<br>    System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="素数筛法">素数筛法</h4><p>题目：给定一个正整数<span class="math inline">\(n\)</span>，请你求出 <span class="math inline">\(1∼n\)</span>中质数的个数。</p><h5 id="朴素筛法-onlogn">朴素筛法 <span class="math inline">\(O(nlogn)\)</span></h5><p>遍历<span class="math inline">\(2∼n\)</span>，把每个数的倍数都筛掉</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];       <span class="hljs-comment">// 存储所有素数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> cnt;                         <span class="hljs-comment">// 统计素数个数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];   <span class="hljs-comment">// st[x]判断x是否被筛掉</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= n; j += i) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="埃氏筛法-onloglogn">埃氏筛法 <span class="math inline">\(O(nloglogn)\)</span></h5><p>可以用质数就把所有的合数都筛掉</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) &#123;<br>            primes[cnt++] = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= n; j += i) &#123;<br>                st[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="线性筛法欧拉筛法-on">线性筛法（欧拉筛法） <span class="math inline">\(O(n)\)</span></h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ; i &lt;= n ; i ++ )&#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) pr[cnt++] = i;<span class="hljs-comment">//将没有被标记的点加入到primes数组中去，也就是质数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; primes[j] &lt;= n / i; j++)&#123;<span class="hljs-comment">//从小到大遍历质数</span><br>            st[primes[j]*i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//每一次让primes[j]*i标记</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//只要pi % primes[j] == 0说明他是primes[j]*i的最小质因数了,然后结束循环，</span><br>            <span class="hljs-comment">//如果不break循环的话就会进行primes[j+1]*i晒掉，因为primes[j+1]*i的最小质因数</span><br>            <span class="hljs-comment">//不是primes[j+1],所以会导致重复删除，这也是线性筛的优点所在</span><br>            <span class="hljs-comment">//例如：st[2*4=8]标记之后，如果你不在下面判断if(4%2==0)break掉</span><br>            <span class="hljs-comment">//就会继续primes[(j+1)]*i== st[3*4=12],3不是12的最小质因数，所以这样也是</span><br>            <span class="hljs-comment">//会导致重复删除，执行到i=6时候，st[2*6=12]会再次标记，这样也就在此导致重复了</span><br><br>            <span class="hljs-comment">//i % primes[j] != 0 说明primes[j]永远是primes[j]*i的最小质因数</span><br>            <span class="hljs-comment">//因为primes[j]的最小质因数是本身primes[j]，然后primes[j]*i是primes[j]的倍数</span><br>            <span class="hljs-comment">//所以primes[j]*i的最小质因数也是primes[j]，永远都是，primes[j+1]*i的时候也是</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="约数相关">约数相关</h3><p><strong>定义</strong></p><p>若整数 <span class="math inline">\(n\)</span> 除以整数 <span class="math inline">\(d\)</span> 的余数为 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(d\)</span> 能整除 <span class="math inline">\(n\)</span>，则称 <span class="math inline">\(d\)</span> 是<span class="math inline">\(n\)</span>的约数，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(d\)</span> 的倍数，记为 <span class="math inline">\(d|n\)</span>。</p><h4 id="试除法求所有约数">试除法求所有约数</h4><p>若 <span class="math inline">\(d \ge \sqrt{N}\)</span> 是 <span class="math inline">\(N\)</span> 的约数，则 <span class="math inline">\(N/d \le \sqrt{N}\)</span> 也是 <span class="math inline">\(N\)</span> 的约数。换言之，约数总是成对出现的（除了对于完全平方数，<span class="math inline">\(\sqrt{N}\)</span> 会单独出现）。因此，只需要扫描 <span class="math inline">\(d=1\sim\sqrt{N}\)</span>，尝试 <span class="math inline">\(d\)</span> 是否能整除 <span class="math inline">\(N\)</span>， 若能整除，则 <span class="math inline">\(N/d\)</span> 也是 <span class="math inline">\(N\)</span> 的约数。时间复杂度为 <span class="math inline">\(O(\sqrt{N})\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= x / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>            res.add(i);<br>            <span class="hljs-keyword">if</span>(i != x / i) res.add(x / i);<br>        &#125;<br>    &#125;<br>    Collections.sort(res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>试除法推论</strong></p><p>一个整数 <span class="math inline">\(N\)</span> 的约数个数上界为 <span class="math inline">\(2\sqrt{N}\)</span>。</p><h4 id="约数个数和约数之和">约数个数和约数之和</h4><p><strong>算术基本定理的推论</strong></p><p>在算术基本定理中，若正整数 <span class="math inline">\(N\)</span> 被唯一分解为 <span class="math inline">\(N=p_{1}^{c_1}p_{2}^{c_2}\cdots p_{m}^{c_m}\)</span>，其中 <span class="math inline">\(c_i\)</span> 都是正整数，<span class="math inline">\(p_i\)</span> 都是质数，且满足 <span class="math inline">\(p_1&lt;p_2&lt;\cdots&lt;p_m\)</span>，则 <span class="math inline">\(N\)</span> 的正约数集合可写作：</p><p><span class="math inline">\(\lbrace p_{1}^{b_1}p_{2}^{b_2}\cdots p_{m}^{b_m} \rbrace\)</span>，其中$ 0b_i c_i$</p><p><span class="math inline">\(N\)</span> 的正约数个数为（<span class="math inline">\(\prod\)</span>为连乘符号）：</p><p><span class="math inline">\((c_1+1)*(c_2+1)*\cdots*(c_m+1)=\prod\limits_{i=1}\limits^{m}(c_i+1)\)</span></p><p><span class="math inline">\(N\)</span> 的所有正约数的和为：</p><p><span class="math inline">\((1+p_1+p_1^2+\cdots+p_1^{c_1})*\cdots*(1+p_m+p_m^2+\cdots+p_m^{c_m})=\prod\limits_{i=1}\limits^{m}(\sum\limits_{j=0}\limits^{c_i}(p_i)^j)\)</span></p><p><strong>约数个数</strong></p><p>例题：给定 <span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(a_i\)</span>，请你输出这些数的乘积的约数个数，答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// map存储约数和对应个数</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>    <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-comment">// 计算每个数的所有约数及个数存入map</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>                x /= i;<br>                map.put(i, map.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-comment">// 约数个数</span><br>        res = res * (entry.getValue() + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>    System.out.println(res);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>约数之和</strong></p><p>例题：给定 <span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(a_i\)</span>，请你输出这些数的乘积的约数之和，答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p>关键代码：<code>while(b-- &gt; 0) t = (t * a + 1) % MOD;</code>，运行过程如下所示：</p><p><span class="math display">\[t=t∗p+1\]</span> <span class="math display">\[t=1\]</span> <span class="math display">\[t=p+1\]</span> <span class="math display">\[t=p^2+p+1\]</span> <span class="math display">\[\cdots\cdots\]</span> <span class="math display">\[t=p^b+p^{b−1}+\cdots+1\]</span></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>    <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>                x /= i;<br>                map.put(i, map.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> entry.getKey();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> entry.getValue();<br>        <span class="hljs-comment">// 约数之和</span><br>        <span class="hljs-keyword">while</span>(b-- &gt; <span class="hljs-number">0</span>) t = (t * a + <span class="hljs-number">1</span>) % MOD;<br>        res = res * t % MOD;<br>    &#125;<br>    System.out.println(res);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="最大公约数">最大公约数</h4><p><strong>定义</strong></p><p>若自然数 <span class="math inline">\(d\)</span> 同时是自然数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的约数，则称 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的公约数。在所有 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的公约数中最大的一个，称为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的最大公约数，记为 <span class="math inline">\(gcd(a,b)\)</span>。</p><p>若自然数 <span class="math inline">\(m\)</span> 同时是自然数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的倍数，则称 <span class="math inline">\(m\)</span> 是 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的公倍数。在所有 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的公倍数中最小的一个，称为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的最小公倍数，记为 <span class="math inline">\(lcm(a,b)\)</span>。</p><p><strong>定理</strong></p><p><span class="math display">\[\forall a,b \in \mathbb{N},\quad gcd(a,b)*lcm(a,b) = a*b\]</span></p><p><strong>九章算术·更相减损术</strong></p><p><span class="math inline">\(\forall a,b \in \mathbb{N}, a\ge b\)</span>，有 <span class="math inline">\(gcd(a, b)=gcd(b,a-b)=gcd(a,a-b)\)</span></p><p><span class="math inline">\(\forall a,b \in \mathbb{N}\)</span>，有 <span class="math inline">\(gcd(2a,2b)=2gcd(a,b)\)</span></p><p><strong>欧几里得算法</strong></p><p><span class="math inline">\(\forall a,b \in \mathbb{N}, b \ne 0,\quad gcd(a,b)=gcd(b, a\, mod \, b)\)</span></p><ul><li><p>一般有：若<code>d|a</code>且<code>d|b</code>,则<code>d|(a*x+b*y)</code></p></li><li><p>证明： 设<code>a%b = a - k*b</code>其中<code>k = a/b</code>(向下取整) 若d是<code>(a,b)</code>的公约数 则知<code>d|a</code> 且 <code>d|b</code> 则易知<code>d|(a-k*b)</code>故d也是<code>(b,a%b)</code>的公约数 若d是<code>(b,a%b)</code>的公约数 则知 <code>d|b</code> 且 <code>d|(a-k*b)</code>则<code>d|(a-k*b+k*b) = d|a</code>，故而 d也是<code>(a,b)</code>的公约数 因此<code>(a,b)</code>的公约数集合和<code>(b,a%b)</code>的公约数集合相同 所以他们的最大公约数也相同，证毕。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> b != <span class="hljs-number">0</span> ? gcd(b,a % b) : a;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="求欧拉函数">求欧拉函数</h3><p><strong>互质定义</strong></p><p><span class="math inline">\(\forall a,b \in \mathbb{N}\)</span>，若 <span class="math inline">\(gcd(a,b)=1\)</span>，则称 <span class="math inline">\(a,b\)</span> 互质。</p><p><strong>欧拉函数定义</strong></p><p><span class="math inline">\(1\sim N\)</span> 中<strong>与 <span class="math inline">\(N\)</span> 互质</strong>的数的<strong>个数</strong>被称为<strong>欧拉函数</strong>，记为 <span class="math inline">\(\varphi(N)\)</span>。</p><p>若在算术基本定理中，<span class="math inline">\(N=p_{1}^{c_1}p_{2}^{c_2}\cdots p_{m}^{c_m}\)</span>，则：</p><p><span class="math display">\[\varphi(N)=N* \frac{p_1-1}{p_1}*\frac{p_2-1}{p_2}*\cdots*\frac{p_m-1}{p_m}=N*\prod\limits_{质数p|N}(1-\frac{1}{p})\]</span></p><p>以上公式具体证明可参考<a href="https://www.acwing.com/solution/content/8702/">AcWing 873. 欧拉函数-题解</a>。根据欧拉函数的计算公式，只需要分解质因数，即可顺便求出欧拉函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="筛法求欧拉函数">筛法求欧拉函数</h3><p>例题：给定一个正整数 <span class="math inline">\(n\)</span>，求<span class="math inline">\(1\sim n\)</span>中每个数的欧拉函数之和。</p><p>原理及证明参考题解<a href="https://www.acwing.com/solution/content/43470/">AcWing874.筛法求欧拉函数-题解</a>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] phi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];          <span class="hljs-comment">// 用于保存每个数字的欧拉函数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];       <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];   <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> cnt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//1的欧拉函数为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            primes[cnt++] = i;<br>            phi[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j++)&#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>)&#123;<br>                phi[primes[j]*i] = phi[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="快速幂">快速幂</h3><p>求 <span class="math inline">\(a\)</span> 的 <span class="math inline">\(b\)</span> 次方对 <span class="math inline">\(p\)</span> 取模的值，其中 <span class="math inline">\(1 \le a,b,p \le 10^9\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res = (<span class="hljs-type">int</span>)((<span class="hljs-type">long</span>)res * a % p);<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (<span class="hljs-type">int</span>)((<span class="hljs-type">long</span>)a * a % p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>快速乘</strong></p><p>借鉴快速幂思想，求 <span class="math inline">\(a \times b\, mod\, p\)</span> 的结果。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qmul</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) res = (res + a) % p;<br>        a = a * <span class="hljs-number">2</span> % p;<br>        b /= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>快速幂求逆元</strong></p><p>费马小定理：如果 <span class="math inline">\(p\)</span> 是一个质数，而整数 a 不是 p 的倍数，则有 <span class="math inline">\(a^{p-1} \equiv 1(mod \, p)\)</span>。</p><p>乘法逆元定义</p><p>若整数 $ b，m$ 互质，并且对于任意的整数 <span class="math inline">\(a\)</span>，如果满足 <span class="math inline">\(b|a\)</span>，则存在一个整数 <span class="math inline">\(x\)</span>，使得<span class="math inline">\(a/b \equiv a\times x(mod \, m)\)</span>，则称 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(b\)</span> 的模 <span class="math inline">\(m\)</span> 乘法逆元，记为 <span class="math inline">\(b^{-1}(mod\, m)\)</span>。 相关结论：<span class="math inline">\(b\)</span> 存在乘法逆元的充要条件是 <span class="math inline">\(b\)</span> 与模数 <span class="math inline">\(m\)</span> 互质。当模数 <span class="math inline">\(m\)</span> 为质数时，<span class="math inline">\(b^{m-2}\)</span> 即为 <span class="math inline">\(b\)</span> 的乘法逆元，当 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(m\)</span> 的倍数时，<span class="math inline">\(b\)</span> 的逆元不存在，<span class="math inline">\(b \times x\,\%\, m == 0\)</span>，<span class="math inline">\(b\)</span> 乘任意一个 <span class="math inline">\(x \% m == 0\)</span> 一定等于 <span class="math inline">\(0\)</span>。</p><p>证明过程见题解<a href="https://www.acwing.com/solution/content/16468/">AcWing 876. 费马小定理 - 快速幂求逆元</a>。</p><p>题目：给定 <span class="math inline">\(n\)</span> 组 <span class="math inline">\(a_i，p_i\)</span>，其中 <span class="math inline">\(p_i\)</span> 是质数，求 <span class="math inline">\(a_i\)</span> 模 <span class="math inline">\(p_i\)</span> 的乘法逆元，若逆元不存在则输出 <code>impossible</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>    <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> in.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> qmi(a, m - <span class="hljs-number">2</span>, m);<br>        <span class="hljs-keyword">if</span>(a % m != <span class="hljs-number">0</span>) System.out.println(res);<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>矩阵快速幂</strong></p><p>待补充。。。</p><h3 id="扩展欧几里得算法">扩展欧几里得算法</h3><p>题目：给定 <span class="math inline">\(n\)</span> 对正整数 <span class="math inline">\(a_i,b_i\)</span>，对于每对数，求出一组<span class="math inline">\(x_i,y_i\)</span>，使其满足<span class="math inline">\(a_i\times x_i+b_i\times y_i=gcd(a_i,b_i)\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>[] x, <span class="hljs-type">int</span>[] y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>            y[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> exgcd(b, a % b, y, x);<br>        y[<span class="hljs-number">0</span>] -= a / b * x[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] argv)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            exgcd(a, b, x, y);<br>            System.out.print(x[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println(y[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="高斯消元">高斯消元</h3><p>待补充。。。</p><h3 id="组合数">组合数</h3><p>给定两个正整数 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span>，求 <span class="math inline">\(C_{a}^{b}\, mod \, (10_9+7)\)</span> 的值。针对不同的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 取值范围有四种求解方式。</p><h4 id="递推法求组合数">递推法求组合数</h4><p>递推式：<span class="math inline">\(C_a^b=C_{a-1}^{b-1}+C_{a-1}^{b}\)</span>，时间复杂度<span class="math inline">\(O(n^2)\)</span>，数据范围：<span class="math inline">\(1\le b \le a \le 2000\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>, n, m = <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt;= i ; j ++ )<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) f[i][j] = <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">else</span> f[i][j] = (f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][j]) % m;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="通过预处理逆元的方式求组合数">通过预处理逆元的方式求组合数</h4><p><span class="math inline">\(C_{a}^{b}=\frac{a!}{b!(a-b)!}=a!*b!^{-1}*(a-b)!^{-1}\)</span>，时间复杂度<span class="math inline">\(O(a*log(mod))\)</span>，数据范围：<span class="math inline">\(1\le b \le a \le 10^5\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-keyword">static</span> Long <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % mod;<br>        infact[i] = infact[i - <span class="hljs-number">1</span>] * qmi(i,mod - <span class="hljs-number">2</span>,mod) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(reader.readLine().trim());<br>    <span class="hljs-keyword">while</span>(n -- &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        String[] s1 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s1[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(s1[<span class="hljs-number">1</span>]);<br>        System.out.println(fact[a] * infact[a - b] % mod * infact[b] % mod);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="lucas定理">Lucas定理</h4><p>题目：给定 <span class="math inline">\(n\)</span> 组询问，每组询问给定三个整数 <span class="math inline">\(a,b,p\)</span>，其中 <span class="math inline">\(p\)</span> 是质数，请你输出 <span class="math inline">\(C_a^b \, mod \,p\)</span> 的值。数据范围：<span class="math inline">\(1\le n\le 20, 1 \le b \le a \le 10^{18}, 1 \le p \le 10^5\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">long</span> k,<span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((k &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res = res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">long</span> b,<span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(b &gt; a) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a,j = b; j &gt;= <span class="hljs-number">1</span>;i --,j --)<br>    &#123;<br>        res = res * i % p;<br>        res = res * qmi(j,p - <span class="hljs-number">2</span>,p) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lucas</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">long</span> b,<span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a,b,p);<br>    <span class="hljs-keyword">return</span> C(a % p,b % p,p) * lucas(a / p,b / p,p) % p;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scan.nextInt();<br>    <span class="hljs-keyword">while</span>(n -- &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scan.nextLong();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scan.nextLong();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> scan.nextInt();<br>        System.out.println(lucas(a,b,p));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="分解质因数法求组合数">分解质因数法求组合数</h4><p>由于计算不取模，所以必须使用高精度乘法；因为只询问一次，所以直接按定义计算就行，不需要预处理；但是要避免除法，所以要计算分子分母相消之后的剩余值在相乘，为了方便相消，所以要统计分子和分母的质因子个数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">5010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><br><span class="hljs-comment">//线性筛法求质数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i &lt;= n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt ++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;primes[j] &lt;= n / i;j++)<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//记录p中多少个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">mul</span><span class="hljs-params">(List&lt;Integer&gt; a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; a.size();i++)<br>    &#123;<br>        t += a.get(i) * b;<br>        a.set(i, t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t != <span class="hljs-number">0</span>)<br>    &#123;<br>        a.add(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scan.nextInt();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scan.nextInt();<br>    get_primes(a);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; cnt;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> primes[i];<br>        sum[i] = get(a,p) - get(a - b,p) - get(b,p);<br>    &#125;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    res.add(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; cnt;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; sum[i];j++)<br>            res = mul(res,primes[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> res.size() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)<br>        System.out.print(res.get(i));<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——共享模型之无锁</title>
    <link href="/JUC/Thread_NoLock/"/>
    <url>/JUC/Thread_NoLock/</url>
    
    <content type="html"><![CDATA[<h2 id="共享模型之无锁">共享模型之无锁</h2><h3 id="问题提出">1. 问题提出</h3><p>有如下需求，保证 <code>account.withdraw</code> 取款方法的线程安全</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Account account)</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>原有实现并不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行测试代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountUnsafe</span>(<span class="hljs-number">10000</span>));<br>&#125;<br><br><span class="hljs-comment">// 某次的执行结果</span><br><span class="hljs-number">330</span> cost: <span class="hljs-number">306</span> ms<br></code></pre></div></td></tr></table></figure><p><strong>为什么不安全</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>balance -= amount;<br>&#125;<br><br><span class="hljs-comment">// 以上方法对应的字节码</span><br>ALOAD <span class="hljs-number">0</span> <span class="hljs-comment">// &lt;- this</span><br>ALOAD <span class="hljs-number">0</span><br>GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="hljs-comment">// &lt;- this.balance</span><br>INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="hljs-comment">// 拆箱</span><br>ALOAD <span class="hljs-number">1</span> <span class="hljs-comment">// &lt;- amount</span><br>INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="hljs-comment">// 拆箱</span><br>ISUB <span class="hljs-comment">// 减法</span><br>INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; <span class="hljs-comment">// 结果装箱</span><br>PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="hljs-comment">// -&gt; this.balance</span><br></code></pre></div></td></tr></table></figure><p>多线程执行流程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ALOAD <span class="hljs-number">0</span> <span class="hljs-comment">// thread-0 &lt;- this</span><br>ALOAD <span class="hljs-number">0</span><br>GETFIELD cn/itcast/AccountUnsafe.balance <span class="hljs-comment">// thread-0 &lt;- this.balance</span><br>INVOKEVIRTUAL java/lang/Integer.intValue <span class="hljs-comment">// thread-0 拆箱</span><br>ALOAD <span class="hljs-number">1</span> <span class="hljs-comment">// thread-0 &lt;- amount</span><br>INVOKEVIRTUAL java/lang/Integer.intValue <span class="hljs-comment">// thread-0 拆箱</span><br>ISUB <span class="hljs-comment">// thread-0 减法</span><br>INVOKESTATIC java/lang/Integer.valueOf <span class="hljs-comment">// thread-0 结果装箱</span><br>PUTFIELD cn/itcast/AccountUnsafe.balance <span class="hljs-comment">// thread-0 -&gt; this.balance</span><br><br>ALOAD <span class="hljs-number">0</span> <span class="hljs-comment">// thread-1 &lt;- this</span><br>ALOAD <span class="hljs-number">0</span><br>GETFIELD cn/itcast/AccountUnsafe.balance <span class="hljs-comment">// thread-1 &lt;- this.balance</span><br>INVOKEVIRTUAL java/lang/Integer.intValue <span class="hljs-comment">// thread-1 拆箱</span><br>ALOAD <span class="hljs-number">1</span> <span class="hljs-comment">// thread-1 &lt;- amount</span><br>INVOKEVIRTUAL java/lang/Integer.intValue <span class="hljs-comment">// thread-1 拆箱</span><br>ISUB <span class="hljs-comment">// thread-1 减法</span><br>INVOKESTATIC java/lang/Integer.valueOf <span class="hljs-comment">// thread-1 结果装箱</span><br>PUTFIELD cn/itcast/AccountUnsafe.balance <span class="hljs-comment">// thread-1 -&gt; this.balance</span><br></code></pre></div></td></tr></table></figure><ul><li>单核的指令交错</li><li>多核的指令交错</li></ul><p><strong>解决思路-锁</strong></p><p>首先想到的是给 Account 对象加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">private</span> Integer balance;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br><span class="hljs-built_in">this</span>.balance = balance;<br>&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    balance -= amount;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0 cost: 399 ms<br></code></pre></div></td></tr></table></figure><p><strong>解决思路-无锁</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    AtomicInteger atomicInteger;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atomicInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atomicInteger.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> getBalance();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> pre - amount;<br>            <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(pre, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 可以简化为下面的方法</span><br><span class="hljs-comment">// balance.addAndGet(-1 * amount);</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行测试代码并得到正确结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountSafe</span>(<span class="hljs-number">10000</span>));<br>&#125;<br><br><span class="hljs-comment">// 某次的执行结果</span><br><span class="hljs-number">0</span> cost: <span class="hljs-number">302</span> ms<br></code></pre></div></td></tr></table></figure><h3 id="cas-与-volatile">2. CAS 与 volatile</h3><h4 id="cas">2.1 CAS</h4><p>前面看到的<code>AtomicInteger</code> 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span><br><span class="hljs-comment">            - 不一致了，next 作废，返回 false 表示失败</span><br><span class="hljs-comment">            比如，别的线程已经做了减法，当前值已经被减成了 990</span><br><span class="hljs-comment">            那么本线程的这次 990 就作废了，进入 while 下次循环重试</span><br><span class="hljs-comment">            - 一致，以 next 设置为新值，返回 true 表示成功</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>    <span class="hljs-keyword">break</span>;<br>   &#125;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/NoLock_1.png" alt="CAS解决取款问题" /><figcaption aria-hidden="true">CAS解决取款问题</figcaption></figure><div class="note note-warning">            <p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p><ul><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。</li></ul>          </div><h4 id="volatile">2.2 volatile</h4><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><div class="note note-warning">            <p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>          </div><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><h4 id="为什么无锁效率高">2.3 为什么无锁效率高</h4><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻</li><li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/SixThreadState1.png" alt="线程状态转换图" /><figcaption aria-hidden="true">线程状态转换图</figcaption></figure><h4 id="cas-的特点">2.4 CAS 的特点</h4><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h3 id="原子整数">3. 原子整数</h3><p><code>J.U.C</code>并发包提供了：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以 AtomicInteger 为例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>System.out.println(i.getAndIncrement());<br><br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br><br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br><br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br><br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></div></td></tr></table></figure><h3 id="原子引用">4. 原子引用</h3><p>为什么需要原子引用类型？</p><p>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p><ul><li>AtomicReference：引用类型原子类。</li><li>AtomicMarkableReference：原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicStampedReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul><p>对于如下方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">    * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(DecimalAccount account)</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            account.withdraw(BigDecimal.TEN);<br>        &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以提供不同的 DecimalAccount 实现，通过<code>synchronized</code>加锁或<code>CAS</code>无锁的方式实现安全的取款操作</p><h4 id="不安全实现">4.1 不安全实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>BigDecimal balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountUnsafe</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>    <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBalance();<br>        <span class="hljs-built_in">this</span>.balance = balance.subtract(amount);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="安全实现-使用-cas">4.2 安全实现-使用 CAS</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountSafeCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    AtomicReference&lt;BigDecimal&gt; ref;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountSafeCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>    ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> ref.get();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (ref.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="aba问题及解决">4.3 ABA问题及解决</h4><p><strong>ABA问题</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>    <span class="hljs-comment">// 获取值 A</span><br><span class="hljs-comment">// 这个共享变量被其它线程修改过</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> ref.get();<br>    other();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 尝试改为 C</span><br>    log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="hljs-string">&quot;C&quot;</span>));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">52.325</span> c.Test36 [main] - main start...<br><span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">52.379</span> c.Test36 [t1] - change A-&gt;B <span class="hljs-literal">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">52.879</span> c.Test36 [t2] - change B-&gt;A <span class="hljs-literal">true</span><br><span class="hljs-number">11</span>:<span class="hljs-number">29</span>:<span class="hljs-number">53.880</span> c.Test36 [main] - change A-&gt;C <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 CAS 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p><p><strong>AtomicStampedReference</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>    <span class="hljs-comment">// 获取值 A</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>    <span class="hljs-comment">// 获取版本号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>    log.debug(<span class="hljs-string">&quot;版本 &#123;&#125;&quot;</span>, stamp);<br>    <span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>    other();<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 尝试改为 C</span><br>    log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>    log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>        log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">34.891</span> c.Test36 [main] - main start...<br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">34.894</span> c.Test36 [main] - 版本 <span class="hljs-number">0</span><br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">34.956</span> c.Test36 [t1] - change A-&gt;B <span class="hljs-literal">true</span><br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">34.956</span> c.Test36 [t1] - 更新版本为 <span class="hljs-number">1</span><br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">35.457</span> c.Test36 [t2] - change B-&gt;A <span class="hljs-literal">true</span><br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">35.457</span> c.Test36 [t2] - 更新版本为 <span class="hljs-number">2</span><br><span class="hljs-number">15</span>:<span class="hljs-number">41</span>:<span class="hljs-number">36.457</span> c.Test36 [main] - change A-&gt;C <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： <code>A -&gt; B -&gt; A -&gt;C</code>，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p><p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了<strong>AtomicMarkableReference</strong></p><h3 id="原子数组">5. 原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>对于如下方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">    参数2，获取数组长度的方法</span><br><span class="hljs-comment">    参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">    参数4，打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T,Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T,Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer)</span> &#123;<br>    ArrayList&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array,j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t-&gt;t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    ts.forEach(t-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="不安全的数组">5.1 不安全的数组</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">demo(<br>    ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>    (array)-&gt;array.length,<br>    (array, index) -&gt; array[index]++,<br>    array-&gt; System.out.println(Arrays.toString(array))<br>);<br></code></pre></div></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">[<span class="hljs-number">9870</span>, <span class="hljs-number">9862</span>, <span class="hljs-number">9774</span>, <span class="hljs-number">9697</span>, <span class="hljs-number">9683</span>, <span class="hljs-number">9678</span>, <span class="hljs-number">9679</span>, <span class="hljs-number">9668</span>, <span class="hljs-number">9680</span>, <span class="hljs-number">9698</span>]<br></code></pre></div></td></tr></table></figure><h4 id="安全的数组">5.2 安全的数组</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">demo(<br>    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>    (array) -&gt; array.length(),<br>    (array, index) -&gt; array.getAndIncrement(index),<br>    array -&gt; System.out.println(array)<br>);<br></code></pre></div></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></div></td></tr></table></figure><h3 id="字段更新器">6.字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be volatile <span class="hljs-built_in">type</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        AtomicIntegerFieldUpdater&lt;TestFieldUpdater&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(TestFieldUpdater.class, <span class="hljs-string">&quot;field&quot;</span>);<br>        <span class="hljs-type">TestFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestFieldUpdater</span>();<br>        fieldUpdater.compareAndSet(updater, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 修改成功 field = 10</span><br>        System.out.println(updater.field);<br>        <span class="hljs-comment">// 修改成功 field = 20</span><br>        fieldUpdater.compareAndSet(updater, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(updater.field);<br>        <span class="hljs-comment">// 修改失败 field = 20</span><br>        fieldUpdater.compareAndSet(updater, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>        System.out.println(updater.field);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="原子累加器">7. 原子累加器</h3><p><strong>累加器性能比较</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLongAdder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>),(ref)-&gt;ref.getAndIncrement());<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(),(ref)-&gt;ref.increment());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer)</span> &#123;<br>        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> supplier.get();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    consumer.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        list.forEach(t -&gt; t.start());<br>        list.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>比较 AtomicLong 与 LongAdder，输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">2000000</span> cost:<span class="hljs-number">80</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">76</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">60</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">56</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">52</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">32</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">5</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">8</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">8</span><br><span class="hljs-number">2000000</span> cost:<span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]... 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h3 id="unsafe">8. Unsafe</h3><h4 id="概述">8.1 概述</h4><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeAccessor</span> &#123;<br><span class="hljs-keyword">static</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="unsafe-实现-cas-操作">8.2 Unsafe 实现 CAS 操作</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br><br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> UnsafeAccessor.getUnsafe();<br><span class="hljs-type">Field</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Student.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Student.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 获得成员变量的偏移量</span><br><span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);<br><span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);<br><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-comment">// 使用 cas 方法替换成员变量的值</span><br>UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 返回 true</span><br>UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 返回 true</span><br><br>System.out.println(student);<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student(id=<span class="hljs-number">20</span>, name=张三)<br></code></pre></div></td></tr></table></figure><h4 id="unsafe-实现-原子整型类">8.3 Unsafe 实现 原子整型类</h4><p>使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        UNSAFE = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// value 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 value 调试来加深理解</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">// cas 尝试修改旧值 prev 为 next，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getValue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        decrement(amount);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——共享模型之内存</title>
    <link href="/JUC/Thread_Memory/"/>
    <url>/JUC/Thread_Memory/</url>
    
    <content type="html"><![CDATA[<h2 id="共享模型之内存">共享模型之内存</h2><h3 id="java-内存模型">1. Java 内存模型</h3><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h3 id="可见性">2. 可见性</h3><h4 id="退不出的循环">2.1 退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(run)&#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析原因如下：</p><ol type="1"><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_1.png" alt="内存模型" /><figcaption aria-hidden="true">内存模型</figcaption></figure><ol start="2" type="1"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_1_2.png" alt="线程中的高速缓存" /><figcaption aria-hidden="true">线程中的高速缓存</figcaption></figure><ol start="3" type="1"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_1_3.png" alt="数据不一致" /><figcaption aria-hidden="true">数据不一致</figcaption></figure><h4 id="解决方法">2.2 解决方法</h4><p><strong>volatile（易变关键字）</strong> 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><h4 id="可见性-vs-原子性">2.3 可见性 vs 原子性</h4><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。 上例从字节码理解是这样的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>putstatic run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run false</span><br></code></pre></div></td></tr></table></figure><p>比较一下之前描述线程安全的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>getstatic i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>iconst_1 <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd <span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1<span class="hljs-comment">// 线程2-准备常量1</span><br>isub <span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></div></td></tr></table></figure><div class="note note-warning">            <p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了。因为 printIn () 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。</p>          </div><p><strong><font color='blue' style='font-weight:blue'> * 原理之 CPU缓存结构</font></strong></p><p><strong>1. 缓存结构</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_2_1.png" alt="CPU缓存结构" /><figcaption aria-hidden="true">CPU缓存结构</figcaption></figure><p>cpu 拿到的内存地址格式是这样的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[高位组标记][低位索引][偏移量]<br></code></pre></div></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_2_2.png" alt="内存地址格式" /><figcaption aria-hidden="true">内存地址格式</figcaption></figure><p><strong>2. CPU 缓存读</strong> 读取数据流程如下</p><ul><li>根据低位，计算在缓存中的索引</li><li>判断是否有效<ul><li>0 去内存读取新数据更新缓存行</li><li>1 再对比高位组标记是否一致<ul><li>一致，根据偏移量返回缓存数据</li><li>不一致，去内存读取新数据更新缓存行</li></ul></li></ul></li></ul><p><strong>3. 内存屏障</strong></p><p>Memory Barrier（Memory Fence）</p><ul><li>可见性<ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之</li></ul></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_2_3.png" alt="内存屏障" /><figcaption aria-hidden="true">内存屏障</figcaption></figure><h4 id="模式之两阶段终止"><font color='orange' style='font-weight:yellow'>2.4 * 模式之两阶段终止</font></h4><p><strong>3.1 利用 isInterrupted(见前文)</strong></p><p><strong>3.2 利用停止标记</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span><br><span class="hljs-comment">// 本例中，即主线程把它修改为 true 对 t1 线程可见</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TPTVolatile&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">TPTVolatile</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TPTVolatile</span>();<br>t.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>log.debug(<span class="hljs-string">&quot;stop&quot;</span>);<br>t.stop();<br></code></pre></div></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">54</span>:<span class="hljs-number">52.003</span> c.TPTVolatile [监控线程] - 将结果保存<br><span class="hljs-number">11</span>:<span class="hljs-number">54</span>:<span class="hljs-number">53.006</span> c.TPTVolatile [监控线程] - 将结果保存<br><span class="hljs-number">11</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54.007</span> c.TPTVolatile [监控线程] - 将结果保存<br><span class="hljs-number">11</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54.502</span> c.TestTwoPhaseTermination [main] - stop<br><span class="hljs-number">11</span>:<span class="hljs-number">54</span>:<span class="hljs-number">54.502</span> c.TPTVolatile [监控线程] - 料理后事<br></code></pre></div></td></tr></table></figure><h4 id="同步模式之balking"><font color='orange' style='font-weight:yellow'> 2.5 * 同步模式之Balking </font></h4><p><strong>2.5.1 定义</strong></p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><p><strong>2.5.1 实现</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>            &#125;<br>        starting = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当前端页面多次点击按钮调用 start 时，输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">[http-nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="hljs-literal">false</span>)<br>[http-nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] cn.itcast.monitor.service.MonitorService - 监控线程已启动...<br>[http-nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="hljs-literal">true</span>)<br>[http-nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="hljs-literal">true</span>)<br>[http-nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">4</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="hljs-literal">true</span>)<br></code></pre></div></td></tr></table></figure><p>它还经常用来实现线程安全的单例</p><p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p><h3 id="有序性">3. 有序性</h3><h4 id="指令重排问题">3.1 指令重排问题</h4><p>观察以下代码，I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</li><li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</li><li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li><li>情况4：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2，最终结果为0</li></ul><p>出现情况4这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现。</p><p><strong>解决方法</strong> volatile 修饰的变量，可以禁用指令重排</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="原理之-volatile"><font color='blue' style='font-weight:blue'>3.2 * 原理之 volatile</font></h4><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h5 id="如何保证可见性">3.2.1 如何保证可见性</h5><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p></li><li><p>```java public void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } <figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><br>- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据<br><br>- ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>      <span class="hljs-comment">// 读屏障</span><br>      <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>      <span class="hljs-keyword">if</span>(ready) &#123;<br>     r.r1 = num + num;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>      r.r1 = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure></p></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_3_1.png" alt="内存屏障保证可见性" /><figcaption aria-hidden="true">内存屏障保证可见性</figcaption></figure><h5 id="如何保证有序性">3.2.2 如何保证有序性</h5><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>```java public void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } <figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><br>- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前<br><br>- ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>      <span class="hljs-comment">// 读屏障</span><br>      <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>      <span class="hljs-keyword">if</span>(ready) &#123;<br>     r.r1 = num + num;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>      r.r1 = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure></p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_3_2.png" alt="内存屏障保证有序性" /><figcaption aria-hidden="true">内存屏障保证有序性</figcaption></figure></li></ul><p>还是那句话，不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_3_3.png" alt="volatile不能解决指令交错" /><figcaption aria-hidden="true">volatile不能解决指令交错</figcaption></figure><h5 id="double-checked-locking-问题">3.2.3 double-checked locking 问题</h5><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></div></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_3_4.png" alt="DCL中的指令重排问题" /><figcaption aria-hidden="true">DCL中的指令重排问题</figcaption></figure><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值</p><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h5 id="double-checked-locking-解决">3.2.4 double-checked locking 解决</h5><p>对<code>INSTANCE</code>使用<code>volatile</code>即可解决问题：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Memory_3_5.png" alt="volatile解决DCL指令重排问题" /><figcaption aria-hidden="true">volatile解决DCL指令重排问题</figcaption></figure><h4 id="happens-before">3.3 happens-before</h4><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>    x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></div></td></tr></table></figure></li><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></div></td></tr></table></figure></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></div></td></tr></table></figure></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></div></td></tr></table></figure></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>            System.out.println(x);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>    Thread.yield();<br>    &#125;<br>    System.out.println(x);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> y;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    y = <span class="hljs-number">10</span>;<br>    x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></div></td></tr></table></figure></li></ul><div class="note note-warning">            <p>变量都是指成员变量或静态成员变量</p>          </div><h4 id="单例模式"><font color='orange' style='font-weight:yellow'>3.4 *单例模式</font></h4><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p><div class="note note-primary">            <p>饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>          </div><h5 id="饿汉单例">3.4.1 饿汉单例</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final</span><br><span class="hljs-comment">// ans：防止子类继承后更改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例？ </span><br><span class="hljs-comment">// ans：如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?</span><br>    <span class="hljs-comment">// ans1：防止其它类中使用new生成新的实例 ans2：不能。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?</span><br>    <span class="hljs-comment">// ans：这是静态常量，jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span><br>    <span class="hljs-comment">// ans： 1.提供更好的封装性；2.提供范型的支持</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="枚举单例">3.4.2 枚举单例</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的</span><br><span class="hljs-comment">// ans：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题</span><br><span class="hljs-comment">// ans：没有，这是静态成员变量</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例</span><br><span class="hljs-comment">// ans：不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例</span><br><span class="hljs-comment">// ans：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span><br><span class="hljs-comment">// ans：饿汉式</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span><br><span class="hljs-comment">// ans：加构造方法就行了</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>INSTANCE;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="懒汉单例">3.4.3 懒汉单例</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点</span><br>    <span class="hljs-comment">// ans：synchronized加在静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能比较低。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="dcl懒汉单例">3.4.4 DCL懒汉单例</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile</span><br>    <span class="hljs-comment">// ans：为了防止重排序问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义</span><br>    <span class="hljs-comment">// ans：提高了效率</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span><br>            <span class="hljs-comment">// ans：这是为了解决第一次判断时的并发问题。</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="静态内部类懒汉单例">3.4.5 静态内部类懒汉单例</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式</span><br>    <span class="hljs-comment">// ans：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyHolder</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题</span><br>    <span class="hljs-comment">// ans：这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——共享模型之管程</title>
    <link href="/JUC/Thread_Monitor/"/>
    <url>/JUC/Thread_Monitor/</url>
    
    <content type="html"><![CDATA[<h2 id="共享模型之管程">共享模型之管程</h2><h3 id="共享带来的问题">1. 共享带来的问题</h3><h4 id="java的体现">1.1 java的体现</h4><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter++;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            counter--;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;res: &#123;&#125;&quot;</span>, counter);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="问题分析">1.2 问题分析</h4><p>以上的结果可能是<strong>正数、负数、零</strong>。为什么呢？因为 Java 中对静态变量的自增，自减并<strong>不是原子操作</strong>，要彻底理解，必须从字节码来进行分析。例如对于<code>i++</code> 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>iadd <span class="hljs-comment">// 自增</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></div></td></tr></table></figure><p>而对应 <code>i--</code> 也是类似：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>isub <span class="hljs-comment">// 自减</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></div></td></tr></table></figure><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_1.png" alt="内存模型" /><figcaption aria-hidden="true">内存模型</figcaption></figure><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题，但多线程下这 8 行代码可能交错运行，此时就有可能出现正数或负数，出现负数情况：</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_2.png" alt="多线程操作共享变量加减法出现负数的情景" /><figcaption aria-hidden="true">多线程操作共享变量加减法出现负数的情景</figcaption></figure><h4 id="临界区-critical-section">1.3 临界区 Critical Section</h4><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问<strong>共享资源</strong><ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><h4 id="竞态条件-race-condition">1.4 竞态条件 Race Condition</h4><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h3 id="synchronized-解决方案">2. synchronized 解决方案</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></blockquote><h4 id="synchronized">2.1 synchronized</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>临界区<br>&#125;<br></code></pre></div></td></tr></table></figure><p>解决</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                counter++;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                counter--;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;res: &#123;&#125;&quot;</span>,counter);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码执行过程理解：</p><ul><li><code>synchronized(对象)</code> 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人</li><li>当线程 t1 执行到 <code>synchronized(room)</code> 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行<code>count++</code> 代码</li><li>这时候如果 t2 也运行到了 <code>synchronized(room)</code> 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了</li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入</li><li>当 t1 执行完<code>synchronized&#123;&#125;</code> 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 <code>count--</code>代码</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_3_1.png" alt="synchronized获取锁示意图" /><figcaption aria-hidden="true">synchronized获取锁示意图</figcaption></figure><h4 id="面向对象改进">2.2 面向对象改进</h4><p>把需要保护的共享变量放入一个类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span> , room.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="方法上的-synchronized">3. 方法上的 synchronized</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <br>&#125;<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            <br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <br>&#125;<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br>            <br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="不加-synchronized-的方法">3.1 <strong>不加 synchronized 的方法</strong></h4><p>不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的）</p><h4 id="所谓的线程八锁">3.2 <strong>所谓的“线程八锁”</strong></h4><p>其实就是考察 <code>synchronized</code> 锁住的是哪个对象</p><p>情况1：<u>12 或 21</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 加锁对象相同，有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况2：<u>1s后12，或 2 1s后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 加锁对象相同，有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况3：<u>3 1s 12 或 23 1s 1 或 32 1s 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 加锁对象都是n1，有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.c(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况4：<u>2 1s 后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 加锁对象不同n1和n2，无竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况5：<u>2 1s 后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 加锁对象不同，线程没有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况6：<u>1s 后12， 或 2 1s后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 两个静态方法a()和b()加锁的是同一个对象Number.class，有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况7：<u>2 1s 后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// a()方法锁住Number.class，b()方法锁住n2对象，无竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>情况8：<u>1s 后12， 或 2 1s后 1</u></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-comment">// 调用静态方法，锁住的都是同一个对象 Number.class，有竞争</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="变量的线程安全分析">4. 变量的线程安全分析</h3><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p><strong>常见线程安全类</strong></p><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为：它们的<strong>每个方法是原子</strong>的，但注意它们多个方法的<strong>组合不是原子</strong>的，见后面分析</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></div></td></tr></table></figure><p><strong>线程安全类方法的组合</strong></p><p>分析下面代码是否线程安全？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>    <span class="hljs-comment">// 线程1，线程2</span><br>    <span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>    table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_4.png" alt="线程安全类方法的组合不是线程安全的" /><figcaption aria-hidden="true">线程安全类方法的组合不是线程安全的</figcaption></figure><p><strong>不可变类线程安全性</strong> String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><h3 id="monitor-概念">5. Monitor 概念</h3><h4 id="java-对象头">5.1 Java 对象头</h4><p>以 32 位虚拟机为例</p><p>普通对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">|--------------------------------------------------------------|<br>| Object <span class="hljs-title function_">Header</span> <span class="hljs-params">(<span class="hljs-number">64</span> bits)</span>   |<br>|------------------------------------|-------------------------|<br>|  Mark <span class="hljs-title function_">Word</span> <span class="hljs-params">(<span class="hljs-number">32</span> bits)</span>  |  Klass <span class="hljs-title function_">Word</span> <span class="hljs-params">(<span class="hljs-number">32</span> bits)</span>  |<br>|------------------------------------|-------------------------|<br></code></pre></div></td></tr></table></figure><p>数组对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">|---------------------------------------------------------------------------------|<br>| Object <span class="hljs-title function_">Header</span> <span class="hljs-params">(<span class="hljs-number">96</span> bits)</span>   |<br>|--------------------------------|-----------------------|------------------------|<br>| Mark <span class="hljs-title function_">Word</span><span class="hljs-params">(32bits)</span>    |   Klass <span class="hljs-title function_">Word</span><span class="hljs-params">(32bits)</span>  |   array <span class="hljs-title function_">length</span><span class="hljs-params">(32bits)</span> |<br>|--------------------------------|-----------------------|------------------------|<br></code></pre></div></td></tr></table></figure><p>其中Mark Word结构为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">|-------------------------------------------------------|--------------------|<br>| Mark <span class="hljs-title function_">Word</span> <span class="hljs-params">(<span class="hljs-number">32</span> bits)</span> | State  |<br>|-------------------------------------------------------|--------------------|<br>| hashcode:<span class="hljs-number">25</span>         |  age:<span class="hljs-number">4</span>  |  biased_lock:<span class="hljs-number">0</span> |  <span class="hljs-number">01</span>  |    Normal   |<br>|-------------------------------------------------------|--------------------|<br>| thread:<span class="hljs-number">23</span> | epoch:<span class="hljs-number">2</span> |  age:<span class="hljs-number">4</span>  |  biased_lock:<span class="hljs-number">1</span> |  <span class="hljs-number">01</span>  |       Biased  |<br>|-------------------------------------------------------|--------------------|<br>|                  ptr_to_lock_record:<span class="hljs-number">30</span>     |  <span class="hljs-number">00</span>  | Lightweight Locked |<br>|-------------------------------------------------------|--------------------|<br>| ptr_to_heavyweight_monitor:<span class="hljs-number">30</span>    |  <span class="hljs-number">10</span>  | Heavyweight Locked |<br>|-------------------------------------------------------|--------------------|<br>|  |  <span class="hljs-number">11</span>  |    Marked <span class="hljs-keyword">for</span> GC   |<br>|-------------------------------------------------------|--------------------|<br></code></pre></div></td></tr></table></figure><p>64 位虚拟机 Mark Word</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">|--------------------------------------------------------------------|--------------------|<br>| Mark <span class="hljs-title function_">Word</span> <span class="hljs-params">(<span class="hljs-number">64</span> bits)</span>  |       State       |<br>|--------------------------------------------------------------------|--------------------|<br>| unused:<span class="hljs-number">25</span> | hashcode:<span class="hljs-number">31</span> | unused:<span class="hljs-number">1</span> | age:<span class="hljs-number">4</span> | biased_lock:<span class="hljs-number">0</span> |  <span class="hljs-number">01</span>   |        Normal    |<br>|--------------------------------------------------------------------|--------------------|<br>| thread:<span class="hljs-number">54</span> | epoch:<span class="hljs-number">2</span>     | unused:<span class="hljs-number">1</span> | age:<span class="hljs-number">4</span> | biased_lock:<span class="hljs-number">1</span> | <span class="hljs-number">01</span>  |    Biased   |<br>|--------------------------------------------------------------------|--------------------|<br>| ptr_to_lock_record:<span class="hljs-number">62</span>  | <span class="hljs-number">00</span>   | Lightweight Locked |<br>|--------------------------------------------------------------------|--------------------|<br>| ptr_to_heavyweight_monitor:<span class="hljs-number">62</span>   |  <span class="hljs-number">10</span>  | Heavyweight Locked |<br>|--------------------------------------------------------------------|--------------------|<br>|    | <span class="hljs-number">11</span> | Marked <span class="hljs-keyword">for</span> GC |<br>|--------------------------------------------------------------------|--------------------|<br></code></pre></div></td></tr></table></figure><h4 id="原理之monitor锁"><font color='blue' style='font-weight:blue'>5.2 * 原理之Monitor(锁)</font></h4><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong> 每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p>Monitor 结构如下</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_5.png" alt="Monitor 结构" /><figcaption aria-hidden="true">Monitor 结构</figcaption></figure><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后文<u>wait-notify原理</u>部分会分析</li></ul><blockquote><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h4 id="原理之-synchronized"><font color='blue' style='font-weight:blue'>5.3 * 原理之 synchronized</font></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    counter++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对应的字节码为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>descriptor: ([Ljava/lang/String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>            <span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br>            <span class="hljs-number">3</span>: dup<br>            <span class="hljs-number">4</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; slot 1</span><br>            <span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br>            <span class="hljs-number">6</span>: getstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// &lt;- i</span><br>            <span class="hljs-number">9</span>: iconst_1 <span class="hljs-comment">// 准备常数 1</span><br>            <span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br>            <span class="hljs-number">11</span>: putstatic #<span class="hljs-number">3</span> <span class="hljs-comment">// -&gt; i</span><br>            <span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>            <span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>            <span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br>            <span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e -&gt; slot 2</span><br>            <span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br>            <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br>            <span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e)</span><br>            <span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br>            <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span><br>Exception table:<br>from to target type<br>  <span class="hljs-number">6</span>  <span class="hljs-number">16</span>   <span class="hljs-number">19</span>   any<br>  <span class="hljs-number">19</span> <span class="hljs-number">22</span>   <span class="hljs-number">19</span>   any<br>LineNumberTable:<br>  line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>  line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br>  line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br>  line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br>LocalVariableTable:<br>  Start Length Slot Name Signature<br><span class="hljs-number">0</span>       <span class="hljs-number">25</span>    <span class="hljs-number">0</span> args [Ljava/lang/String;<br>StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>  frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>offset_delta = <span class="hljs-number">19</span><br>locals = [ class <span class="hljs-string">&quot;[Ljava/lang/String;&quot;</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Object ]<br>stack = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Throwable ]<br>frame_type = <span class="hljs-number">250</span> <span class="hljs-comment">/* chop */</span><br>offset_delta = <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意 方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><h4 id="synchronized-原理进阶"><font color='blue' style='font-weight:blue'>5.4 * synchronized 原理进阶</font></h4><h5 id="轻量级锁">5.4.1 轻量级锁</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法仍然是 <code>synchronized</code> 假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>    <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_6_1.png" alt="创建锁记录对象" /><figcaption aria-hidden="true">创建锁记录对象</figcaption></figure><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_6_2.png" alt="尝试CAS替换" /><figcaption aria-hidden="true">尝试CAS替换</figcaption></figure><ul><li>如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_6_3.png" alt="CAS替换成功" /><figcaption aria-hidden="true">CAS替换成功</figcaption></figure><ul><li>如果 cas 失败，有两种情况<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_6_4.png" alt="CAS失败" /><figcaption aria-hidden="true">CAS失败</figcaption></figure><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_6_5.png" alt="synchronized解锁过程示意图" /><figcaption aria-hidden="true">synchronized解锁过程示意图</figcaption></figure><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h5 id="锁膨胀">5.4.2 锁膨胀</h5><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_7_1.png" alt="加轻量级锁发生竞争" /><figcaption aria-hidden="true">加轻量级锁发生竞争</figcaption></figure><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_7_2.png" alt="锁膨胀流程" /><figcaption aria-hidden="true">锁膨胀流程</figcaption></figure><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h5 id="自旋优化">5.4.3 自旋优化</h5><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p>自旋重试成功的情况</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_8_1.png" alt="自旋重试成功的情况" /><figcaption aria-hidden="true">自旋重试成功的情况</figcaption></figure><p>自旋重试失败的情况</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_8_2.png" alt="自旋重试失败的情况" /><figcaption aria-hidden="true">自旋重试失败的情况</figcaption></figure><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h5 id="偏向锁">5.4.4 偏向锁</h5><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        m2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 B</span><br>        m3();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 C</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_9.png" alt="轻量级锁与偏向锁的锁重入时区别" /><figcaption aria-hidden="true">轻量级锁与偏向锁的锁重入时区别</figcaption></figure><p><strong>偏向状态</strong></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0。可在运行时在添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数<code>-XX:BiasedLockingStartupDelay=0</code>来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><p><strong>撤销 - 调用对象 hashCode</strong> 调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉·<code>-XX:-UseBiasedLocking</code></p><p><strong>撤销 - 其它线程使用对象</strong> 当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><p><strong>撤销 - 调用 wait/notify</strong></p><p><strong>批量重偏向</strong> 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID 当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p><p><strong>批量撤销</strong> 当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p><h3 id="wait-notify">6. wait notify</h3><h4 id="原理之-wait-notify"><font color='blue' style='font-weight:blue'>6.1 * 原理之 wait / notify</font></h4><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Monitor_5.png" alt="Monitor 结构" /><figcaption aria-hidden="true">Monitor 结构</figcaption></figure><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h4 id="api-介绍">6.2 API 介绍</h4><ul><li><code>obj.wait()</code> 让进入 object 监视器的线程到 waitSet 等待</li><li><code>obj.notify()</code>在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li><code>obj.notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>            obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-comment">// 主线程两秒后执行</span><br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notify(); <span class="hljs-comment">// 唤醒obj上一个线程</span><br>        <span class="hljs-comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>notify的一种结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">20</span>:<span class="hljs-number">00</span>:<span class="hljs-number">53.096</span> [Thread-<span class="hljs-number">0</span>] c.TestWaitNotify - 执行....<br><span class="hljs-number">20</span>:<span class="hljs-number">00</span>:<span class="hljs-number">53.099</span> [Thread-<span class="hljs-number">1</span>] c.TestWaitNotify - 执行....<br><span class="hljs-number">20</span>:<span class="hljs-number">00</span>:<span class="hljs-number">55.096</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br><span class="hljs-number">20</span>:<span class="hljs-number">00</span>:<span class="hljs-number">55.096</span> [Thread-<span class="hljs-number">0</span>] c.TestWaitNotify - 其它代码....<br></code></pre></div></td></tr></table></figure><p>notifyAll 的结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">15.457</span> [Thread-<span class="hljs-number">0</span>] c.TestWaitNotify - 执行....<br><span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">15.460</span> [Thread-<span class="hljs-number">1</span>] c.TestWaitNotify - 执行....<br><span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">17.456</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程<br><span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">17.456</span> [Thread-<span class="hljs-number">1</span>] c.TestWaitNotify - 其它代码....<br><span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">17.456</span> [Thread-<span class="hljs-number">0</span>] c.TestWaitNotify - 其它代码....<br></code></pre></div></td></tr></table></figure><p><code>wait()</code>方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止 <code>wait(long n)</code>有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p><h4 id="wait-notify-的正确姿势">6.3 wait notify 的正确姿势</h4><p>对于案例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (room) &#123;<br>    log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>    <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>    room.wait(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>            &#125;<br>&#125;<br>log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br><span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (room) &#123;<br>log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>&#125;<br>&#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>&#125;<br><br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (room) &#123;<br>    hasCigarette = <span class="hljs-literal">true</span>;<br>    log.debug(<span class="hljs-string">&quot;烟到了噢！&quot;</span>);<br>    room.notify();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br></code></pre></div></td></tr></table></figure><ul><li><p>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为<strong>【虚假唤醒】</strong></p></li><li><p>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</p></li><li><p>解决方法，用 while + wait，当条件不成立，再次 wait</p></li></ul><p>上述案例的最终实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCorrectPostureStep5</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 是否有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 是否有外卖</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 小南需要等待有烟</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span>(!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没有烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-comment">// 小女需要等待有外卖</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有外卖没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span>(!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没有外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有外卖没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其他人&quot;</span> + i).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>                room.notifyAll();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此，正确使用wait/notify的方案为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    <span class="hljs-keyword">while</span>(条件不成立) &#123;<br>        lock.wait();<br>    &#125;<br>    <span class="hljs-comment">// 干活</span><br>&#125;<br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="park-unpark">7 Park &amp; Unpark</h3><h4 id="基本使用">7.1 基本使用</h4><p>它们是 LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.park();<br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark(暂停线程对象)<br></code></pre></div></td></tr></table></figure><p>先 park 再 unpark</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park();<br>log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52.585</span> c.TestParkUnpark [t1] - start...<br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53.589</span> c.TestParkUnpark [t1] - park...<br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [main] - unpark...<br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c.TestParkUnpark [t1] - resume...<br></code></pre></div></td></tr></table></figure><p>先 unpark 再 park</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park();<br>    log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1);<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">50.765</span> c.TestParkUnpark [t1] - start...<br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">51.764</span> c.TestParkUnpark [main] - unpark...<br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - park...<br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c.TestParkUnpark [t1] - resume...<br></code></pre></div></td></tr></table></figure><h4 id="特点">7.2 特点</h4><p>与 Object 的 wait &amp; notify 相比</p><ul><li><p>wait &amp; notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park &amp; unpark 不必</p></li><li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p></li></ul><h3 id="多把锁">8. 多把锁</h3><p>一间大屋子有两个功能：睡觉、学习，互不相干。 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低 解决方法是准备多个房间（多个对象锁）</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// main中执行</span><br><span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    bigRoom.compute();<br>&#125;,<span class="hljs-string">&quot;小南&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    bigRoom.sleep();<br>&#125;,<span class="hljs-string">&quot;小女&quot;</span>).start();<br><br><span class="hljs-comment">// 某次执行结果</span><br><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">54.471</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55.476</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></div></td></tr></table></figure><p>改进</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 某次执行结果</span><br><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小南] c.BigRoom - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35.069</span> [小女] c.BigRoom - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></div></td></tr></table></figure><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h3 id="活跃性">9. 活跃性</h3><h4 id="死锁">9.1 死锁</h4><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 <code>t1 线程</code> 获得 <code>A对象</code>锁，接下来想获取 <code>B对象</code>的锁，<code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code>的锁 例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (A) &#123;<br>        log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (B) &#123;<br>        log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>t1.start();<br>t2.start();<br></code></pre></div></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t2] c.TestDeadLock - lock B<br><span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">06.962</span> [t1] c.TestDeadLock - lock A<br></code></pre></div></td></tr></table></figure><h4 id="定位死锁">9.2 定位死锁</h4><ul><li><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p></li><li><p>避免死锁要注意加锁顺序</p></li><li><p>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 <code>top -Hp进程id</code> 来定位是哪个线程，最后再用 jstack 排查</p></li></ul><h4 id="活锁">9.3 活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 期望减到 0 退出循环</span><br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            sleep(<span class="hljs-number">0.2</span>);<br>            count--;<br>            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 期望超过 20 退出循环</span><br>        <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>            sleep(<span class="hljs-number">0.2</span>);<br>            count++;<br>            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="reentrantlock">10. ReentrantLock</h3><p>相对于 synchronized 它具备如下特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><h4 id="基本语法">10.1 基本语法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 释放锁</span><br>reentrantLock.unlock();<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="可重入">10.2 可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method1();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>        method2();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>        method3();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.862</span> [main] c.TestReentrant - execute method1<br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method2<br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method3<br></code></pre></div></td></tr></table></figure><h4 id="可打断">10.3 可打断</h4><p>示例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>    sleep(<span class="hljs-number">1</span>);<br>    t1.interrupt();<br>    log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.520</span> [main] c.TestInterrupt - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">40.524</span> [t1] c.TestInterrupt - 启动...<br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.530</span> [main] c.TestInterrupt - 执行打断<br>java.lang.InterruptedException<br>at<br>java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">898</span>)<br>at<br>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">1222</span>)<br>at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>)<br>at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$<span class="hljs-number">0</span>(TestInterrupt.java:<span class="hljs-number">17</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-number">18</span>:<span class="hljs-number">02</span>:<span class="hljs-number">41.532</span> [t1] c.TestInterrupt - 等锁的过程中被打断<br></code></pre></div></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><h4 id="锁超时">10.4 锁超时</h4><p>立刻失败</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>        log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>    sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.918</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 启动...<br><span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">02.921</span> [t1] c.TestTimeout - 获取立刻失败，返回<br></code></pre></div></td></tr></table></figure><p>超时失败</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>            log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>    sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.537</span> [main] c.TestTimeout - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">40.544</span> [t1] c.TestTimeout - 启动...<br><span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">41.547</span> [t1] c.TestTimeout - 获取等待 1s 后失败，返回<br></code></pre></div></td></tr></table></figure><h4 id="公平锁">10.5 公平锁</h4><p>ReentrantLock 默认是不公平的，公平锁一般没有必要，会降低并发度。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认为false，表示不公平锁，改为true是公平锁</span><br></code></pre></div></td></tr></table></figure><h4 id="条件变量">10.6 条件变量</h4><p>synchronized 中也有条件变量，就是前文<u>synchronized 原理</u>里那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitCigaretteQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitbreakfastQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br><br>    sleep(<span class="hljs-number">1</span>);<br>    sendBreakfast();<br>    sleep(<span class="hljs-number">1</span>);<br>    sendCigarette();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>        hasCigrette = <span class="hljs-literal">true</span>;<br>        waitCigaretteQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>        hasBreakfast = <span class="hljs-literal">true</span>;<br>        waitbreakfastQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.680</span> [main] c.TestCondition - 送早餐来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">27.682</span> [Thread-<span class="hljs-number">1</span>] c.TestCondition - 等到了它的早餐<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [main] c.TestCondition - 送烟来了<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">28.683</span> [Thread-<span class="hljs-number">0</span>] c.TestCondition - 等到了它的烟<br></code></pre></div></td></tr></table></figure><h3 id="同步模式之顺序控制"><font color='orange' style='font-weight:yellow'>11 * 同步模式之顺序控制</font></h3><h4 id="固定运行顺序">11.1固定运行顺序</h4><p>比如，必须先 2 后 1 打印</p><p><strong>wait &amp; notify 版</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 用来同步的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// t2 运行标记， 代表 t2 是否执行过</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2runned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 方法一</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (room) &#123;<br>            <span class="hljs-comment">// 如果 t2 没有执行过</span><br>            <span class="hljs-keyword">while</span>(!t2runned) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// t1 先等一会</span><br>                    room.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (room) &#123;<br>            <span class="hljs-comment">// 修改运行标记</span><br>            t2runned = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 通知 room 上等待的线程（可能有多个，因此需要用 notifyAll）</span><br>            room.notify();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Park &amp; Unpark 版</strong></p><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该wait</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li></ul><p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>    <span class="hljs-comment">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span><br>    LockSupport.park();<br>    System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span><br>    LockSupport.unpark(t1);<br>&#125;);<br>t1.start();<br>t2.start();<br></code></pre></div></td></tr></table></figure><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，不需要『同步对象』和『运行标记』</p><h4 id="交替输出">11.2 交替输出</h4><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现？</p><p><strong>wait &amp; notify 版</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncWaitNotify</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SyncWaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag, String str)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestPrintAlternately1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPrintAlternately1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SyncWaitNotify</span> <span class="hljs-variable">syncWaitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncWaitNotify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncWaitNotify.print(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncWaitNotify.print(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncWaitNotify.print(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Lock 条件变量版</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.AwaitSignal&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Condition first)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>            first.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">this</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-built_in">this</span>.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await();<br>                System.out.print(str);<br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-built_in">this</span>.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestPrintAlternately2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPrintAlternately2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">aWaitSet</span> <span class="hljs-operator">=</span> as.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">bWaitSet</span> <span class="hljs-operator">=</span> as.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">cWaitSet</span> <span class="hljs-operator">=</span> as.newCondition();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;a&quot;</span>, aWaitSet, bWaitSet);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;b&quot;</span>, bWaitSet, cWaitSet);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            as.print(<span class="hljs-string">&quot;c&quot;</span>, cWaitSet, aWaitSet);<br>        &#125;).start();<br>        as.start(aWaitSet);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>该实现没有考虑 a，b，c 线程都就绪再开始</p></blockquote><p><strong>Park &amp; Unpark 版</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPrintAlternately3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SyncPark</span> <span class="hljs-variable">syncPark</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncPark</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            syncPark.print(<span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;);<br>        syncPark.setThreads(t1, t2, t3);<br>        syncPark.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncPark</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br>    <span class="hljs-keyword">private</span> Thread[] threads;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SyncPark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreads</span><span class="hljs-params">(Thread... threads)</span> &#123;<br>        <span class="hljs-built_in">this</span>.threads = threads;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Thread <span class="hljs-title function_">nextThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(threads[i] == current) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index &lt; threads.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> threads[index+<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> threads[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>        LockSupport.unpark(threads[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Monitor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——多线程基础知识</title>
    <link href="/JUC/Thread_Base/"/>
    <url>/JUC/Thread_Base/</url>
    
    <content type="html"><![CDATA[<h2 id="并发编程基础">并发编程基础</h2><h3 id="前置知识">1. 前置知识</h3><p>文章中所有输出基于<code>slf4j</code>日志，使用<code>lombok</code>简化<code>java bean</code>编写。需要先按以下<code>pom.xml</code>和<code>logback.xml</code>文件配置环境，其中<code>logback.xsd</code>文件本地没有的话需要联网下载。</p><p>pom.xml依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>logback.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://ch.qos.logback/xml/ns/logback</span></span><br><span class="hljs-string"><span class="hljs-tag">                https://raw.githubusercontent.com/enricopulatzo/logback-XSD/master/src/main/xsd/logback.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- &lt;pattern&gt;%date&#123;HH:mm:ss&#125; [%t] %logger - %m%n&lt;/pattern&gt; --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date&#123;HH:mm:ss.SSS&#125; [%t] %logger - %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="进程与线程">2. 进程与线程</h3><h4 id="进程与线程-1">2.1 进程与线程</h4><p><strong>进程</strong></p><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><p><strong>线程</strong></p><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</li></ul><p><strong>两者对比</strong></p><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享。</li><li>进程间通信较为复杂，同一台计算机的进程通信称为 IPC（Inter-process communication），不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。</li><li>线程通信相对简单，因为它们共享进程内的内存，多个线程可以访问同一个共享变量。</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</li></ul><h4 id="并行与并发">2.2 并行与并发</h4><p><strong>并发</strong></p><p>单核 cpu 下，线程实际还是<code>串行执行</code>的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感、觉是<code>同时运行</code>的 。总结为一句话就是： <code>微观串行，宏观并行</code> 。</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/ParallelAndConcurrency_1.png" alt="ParallelAndConcurrency" /><figcaption aria-hidden="true">ParallelAndConcurrency</figcaption></figure><p><strong>并行</strong></p><p>多核 cpu 下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的 cpu 在执行。</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/ParallelAndConcurrency_2.png" alt="ParallelAndConcurrency2" /><figcaption aria-hidden="true">ParallelAndConcurrency2</figcaption></figure><p><strong>二者对比</strong></p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间动手做（doing）多件事情的能力。</li></ul><p>例子</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）</li><li>雇了 3 个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li></ul><h4 id="应用">2.3 应用</h4><p><strong>同步和异步</strong></p><p>以调用方的角度讲，如果需要等待结果返回才能继续运行的话就是同步，不需要等待就是异步。</p><p><strong>1）设计</strong></p><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停...</p><p><strong>2）结论</strong></p><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程。</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><p><strong>3）总结</strong></p><ol type="1"><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活。</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的。<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率，但不是所有计算任务都能拆分。</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义。</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li></ol><h3 id="java线程">3. Java线程</h3><h4 id="创建和运行线程">3.1 创建和运行线程</h4><p><strong>方法一、直接使用Thread</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></div></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// run 方法内实现了要执行的任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;;<br>t1.start();<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">25</span> [t1] c.ThreadStarter - hello<br></code></pre></div></td></tr></table></figure><p><strong>方法二、使用 Runnable 配合 Thread</strong></p><p>把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        &#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br><br><span class="hljs-comment">// Java 8 以后可以使用 lambda 精简代码 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></div></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">25</span> [t2] c.ThreadStarter - hello<br></code></pre></div></td></tr></table></figure><p><strong>小结</strong></p><ul><li>方法 1 是把线程和任务合并在了一起，方法 2 是把线程和任务分开了。</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。</li></ul><p><strong>方法三、FutureTask 配合 Thread</strong></p><p>FutureTask 能够接收 <strong>Callable</strong> 类型的参数，用来处理<strong>有返回结果</strong>的情况</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">// 创建任务对象<br>FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">return</span> 100;<br>&#125;);<br><br>// 参数1 是任务对象; 参数2 是线程名字，推荐<br>new Thread(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>// 主线程阻塞，同步等待 task 执行完毕的结果<br>Integer result = task3.get();<br>log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, result);<br><br>// 输出<br>21:25:25 [t3] c.ThreadStarter - hello<br>21:25:25 [main] c.ThreadStarter - 结果是:100<br></code></pre></div></td></tr></table></figure><h4 id="查看进程线程的方法">3.2 查看进程线程的方法</h4><p><strong>Windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code>杀死进程</li></ul><p><strong>Linux</strong></p><ul><li><code>ps -fe</code> 查看所有进程。</li><li><code>ps -fT -p</code>查看某个进程（PID）的所有线程。</li><li><code>kill</code> 杀死进程。</li><li><code>top</code> 按大写 H 切换是否显示线程。</li><li><code>top -H -p</code> 查看某个进程（PID）的所有线程。</li></ul><p><strong>Java</strong></p><p><code>jps</code>命令查看所有 java 进程。 <code>jstack</code> 查看某个 java 进程（PID）的所有线程状态。 <code>jconsole</code> 来查看某个 java 进程中线程的运行情况（图形界面）。</p><h4 id="线程运行原理">3.3 线程运行原理</h4><p><strong>虚拟机栈与栈帧</strong></p><p>虚拟机栈描述的是 java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧 (stack frame) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程私有的。</p><ul><li>当 java 中使用多线程时，每个线程都会维护它自己的栈帧。</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><p><strong>线程上下文切换（Thread Context Switch）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：</p><ul><li>线程的 cpu 时间片用完 (每个线程轮流执行，看前面并行的概念)。</li><li>垃圾回收。</li><li>有更高优先级的线程需要运行。</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法。</li></ul><p>当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p><ul><li><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p></li><li><p>Context Switch 频繁发生会影响性能</p></li></ul><h4 id="常见方法">3.4 常见方法</h4><table><colgroup><col style="width: 11%" /><col style="width: 4%" /><col style="width: 41%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th style="text-align: left;">方法名</th><th style="text-align: left;">static</th><th style="text-align: left;">功能说明</th><th style="text-align: left;">注意</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">start()</td><td style="text-align: left;"></td><td style="text-align: left;">启动一个新线程，在新的线程运行 run 方法中的代码</td><td style="text-align: left;">start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td></tr><tr class="even"><td style="text-align: left;">run()</td><td style="text-align: left;"></td><td style="text-align: left;">新线程启动后会调用的方法</td><td style="text-align: left;">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr class="odd"><td style="text-align: left;">join()</td><td style="text-align: left;"></td><td style="text-align: left;">等待线程运行结束</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">join(long n)</td><td style="text-align: left;"></td><td style="text-align: left;">等待线程运行结束,最多等待 n毫秒</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">getId()</td><td style="text-align: left;"></td><td style="text-align: left;">获取线程长整型的 id</td><td style="text-align: left;">id 唯一</td></tr><tr class="even"><td style="text-align: left;">getName()</td><td style="text-align: left;"></td><td style="text-align: left;">获取线程名</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">setName(String)</td><td style="text-align: left;"></td><td style="text-align: left;">修改线程名</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">getPriority()</td><td style="text-align: left;"></td><td style="text-align: left;">获取线程优先级</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">setPriority(int)</td><td style="text-align: left;"></td><td style="text-align: left;">修改线程优先级</td><td style="text-align: left;">java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr class="even"><td style="text-align: left;">getState()</td><td style="text-align: left;"></td><td style="text-align: left;">获取线程状态</td><td style="text-align: left;">Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td></tr><tr class="odd"><td style="text-align: left;">isInterrupted()</td><td style="text-align: left;"></td><td style="text-align: left;">判断是否被打断</td><td style="text-align: left;">不会清除<code>打断标记</code></td></tr><tr class="even"><td style="text-align: left;">isAlive()</td><td style="text-align: left;"></td><td style="text-align: left;">线程是否存活（还没有运行完毕）</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">interrupt()</td><td style="text-align: left;"></td><td style="text-align: left;">打断线程</td><td style="text-align: left;">如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除<code>打断标记</code>；如果打断的正在运行的线程，则会设置<code>打断标记</code>；park 的线程被打断，也会设置<code>打断标记</code></td></tr><tr class="even"><td style="text-align: left;">interrupted()</td><td style="text-align: left;">static</td><td style="text-align: left;">判断当前线程是否被打断</td><td style="text-align: left;">会清除<code>打断标记</code></td></tr><tr class="odd"><td style="text-align: left;">currentThread()</td><td style="text-align: left;">static</td><td style="text-align: left;">获取当前正在执行的线程</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">sleep(long n)</td><td style="text-align: left;">static</td><td style="text-align: left;">让当前执行的线程休眠n毫秒，休眠时让出 cpu的时间片给其它线程</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">yield()</td><td style="text-align: left;">static</td><td style="text-align: left;">提示线程调度器让出当前线程对CPU的使用</td><td style="text-align: left;">主要是为了测试和调试</td></tr></tbody></table><h4 id="start-与-run">3.5 start 与 run</h4><p><strong>调用run</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>t1.run();<br>log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">22</span>:08:<span class="hljs-number">51</span> [main] c.TestStart - main running...<br><span class="hljs-number">22</span>:08:<span class="hljs-number">51</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things...<br></code></pre></div></td></tr></table></figure><p><strong>调用start</strong></p><p>将上述代码中的<code>t1.run()</code>改为<code>t1.start()</code>，输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">11</span>:<span class="hljs-number">19</span> [main] c.TestStart - <span class="hljs-keyword">do</span> other things...<br><span class="hljs-number">22</span>:<span class="hljs-number">11</span>:<span class="hljs-number">19</span> [t1] c.TestStart - t1 running...<br></code></pre></div></td></tr></table></figure><p><strong>小结</strong></p><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h4 id="sleep-与-yield">3.6 sleep 与 yield</h4><p><strong>sleep</strong></p><ol type="1"><li>调用 sleep 会让当前线程从 <em>Running</em> 进入 <em>Timed Waiting</em> 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛<code>InterruptedException</code></li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 <strong>TimeUnit</strong> 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><p><strong>yield</strong></p><ol type="1"><li>调用 yield 会让当前线程从 <em>Running</em> 进入 <em>Runnable</em> 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><p><strong>小结</strong></p><p>yield 使 cpu 调用其它线程，但是 cpu 可能会再分配时间片给该线程；而 sleep 需要等过了休眠时间之后才有可能被分配 cpu 时间片。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----&gt;1 &quot;</span> + count++);<br>    &#125;<br>&#125;;<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// Thread.yield();</span><br>        System.out.println(<span class="hljs-string">&quot;              ----&gt;2 &quot;</span> + count++);<br>    &#125;<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task1, <span class="hljs-string">&quot;t1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br><span class="hljs-comment">// t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="hljs-comment">// t2.setPriority(Thread.MAX_PRIORITY);</span><br>t1.start();<br>t2.start();<br></code></pre></div></td></tr></table></figure><p><strong>线程优先级</strong></p><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="join-详解">3.7 join 详解</h4><p><strong>为什么需要 join</strong></p><p>下面的代码执行，打印 r 是什么？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>test1();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        r = <span class="hljs-number">10</span>;<br>    &#125;);<br>    t1.start();<br>    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出<code>r=10</code></li><li>而主线程一开始就要打印 r 的结果，所以只能打印出<code>r=0</code></li></ul><p>解决方法</p><ul><li>用 sleep 行不行？为什么？</li><li>用 join，加在<code>t1.start()</code>之后即可</li></ul><p><font color='blue' style='font-weight:blue'><strong>* 应用之同步</strong></font></p><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><strong>等待多个结果</strong> 问，下面代码 cost 大约多少秒？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>test2();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r2 = <span class="hljs-number">20</span>;<br>    &#125;);<br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？ 最终都是输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">43.239</span> [main] c.TestJoin - r1: <span class="hljs-number">10</span> r2: <span class="hljs-number">20</span> cost: <span class="hljs-number">2005</span><br></code></pre></div></td></tr></table></figure><p><strong>有时效的 join</strong></p><p>等够时间</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>test3();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    t1.start();<br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">01.320</span> [main] c.TestJoin - r1: <span class="hljs-number">10</span> r2: <span class="hljs-number">0</span> cost: <span class="hljs-number">1010</span><br></code></pre></div></td></tr></table></figure><p>没等够时间</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>test3();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        r1 = <span class="hljs-number">10</span>;<br>    &#125;);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    t1.start();<br>    <span class="hljs-comment">// 线程执行结束会导致 join 结束</span><br>    t1.join(<span class="hljs-number">1500</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">15.623</span> [main] c.TestJoin - r1: <span class="hljs-number">0</span> r2: <span class="hljs-number">0</span> cost: <span class="hljs-number">1502</span><br></code></pre></div></td></tr></table></figure><h4 id="interrupt-方法详解">3.8 interrupt 方法详解</h4><p><strong>打断 sleep，wait，join 的线程</strong></p><p>这几个方法都会让线程进入阻塞状态 打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    sleep(<span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    t1.interrupt();<br>    log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.lang.InterruptedException: sleep interrupted<br>at java.lang.Thread.sleep(Native Method)<br>at java.lang.Thread.sleep(Thread.java:<span class="hljs-number">340</span>)<br>at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="hljs-number">386</span>)<br>at com.trisirt.JUC.util.Sleeper.sleep(Sleeper.java:<span class="hljs-number">8</span>)<br>at com.trisirt.JUC.Base.TestInterrupt.lambda$test1$<span class="hljs-number">3</span>(TestInterrupt.java:<span class="hljs-number">59</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-number">17</span>:<span class="hljs-number">05</span>:<span class="hljs-number">45.104</span> [main] c.TestInterrupt -  打断状态: <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><p>打断正常运行的线程，不会清空打断状态</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();<br>            <span class="hljs-keyword">if</span>(interrupted) &#123;<br>                log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    t2.interrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">06</span>:<span class="hljs-number">42.695</span> [t2] c.TestInterrupt -  打断状态: <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p><strong>* 模式之两阶段终止</strong></p><p>Two Phase Termination 在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/TwoPhaseTermination1.png" alt="两阶段终止" /><figcaption aria-hidden="true">两阶段终止</figcaption></figure><p><strong>错误思路</strong></p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><p><strong>两阶段终止模式之利用 isInterrupted</strong></p><p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestTwoPhaseTermination&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TPTInterrupt</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TPTInterrupt</span>();<br>        t.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        log.debug(<span class="hljs-string">&quot;stop&quot;</span>);<br>        t.stop();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.TPTInterrupt&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">16</span>:<span class="hljs-number">50</span>:<span class="hljs-number">56.696</span> [监控线程] c.TPTInterrupt - 将结果保存<br><span class="hljs-number">16</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57.702</span> [监控线程] c.TPTInterrupt - 将结果保存<br><span class="hljs-number">16</span>:<span class="hljs-number">50</span>:<span class="hljs-number">58.707</span> [监控线程] c.TPTInterrupt - 将结果保存<br><span class="hljs-number">16</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59.202</span> [main] c.TestTwoPhaseTermination - stop<br><span class="hljs-number">16</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59.202</span> [监控线程] c.TPTInterrupt - 料理后事<br></code></pre></div></td></tr></table></figure><p>两阶段终止还可以用<code>volatile</code>类型的停止标记实现，后续补充。</p><p><strong>打断 park 线程</strong></p><p>打断 park 线程, 不会清空打断状态</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>        LockSupport.park();<br>        log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    sleep(<span class="hljs-number">0.5</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.343</span> [t1] c.TestInterrupt - park...<br><span class="hljs-number">17</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.849</span> [t1] c.TestInterrupt - unpark...<br><span class="hljs-number">17</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.849</span> [t1] c.TestInterrupt - 打断状态：<span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.interrupted());<br>        &#125;<br>    &#125;);<br>    t1.start();<br><br><br>    sleep(<span class="hljs-number">1</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">01</span>:<span class="hljs-number">47.296</span> [Thread-<span class="hljs-number">0</span>] c.TestInterrupt - park...<br><span class="hljs-number">18</span>:<span class="hljs-number">01</span>:<span class="hljs-number">48.304</span> [Thread-<span class="hljs-number">0</span>] c.TestInterrupt - 打断状态：<span class="hljs-literal">true</span><br><span class="hljs-number">18</span>:<span class="hljs-number">01</span>:<span class="hljs-number">48.305</span> [Thread-<span class="hljs-number">0</span>] c.TestInterrupt - park...<br></code></pre></div></td></tr></table></figure><h4 id="不推荐的方法">3.9 不推荐的方法</h4><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p><table><thead><tr class="header"><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr class="odd"><td>stop()</td><td></td><td>停止线程运行</td></tr><tr class="even"><td>suspend()</td><td></td><td>挂起（暂停）线程运行</td></tr><tr class="odd"><td>resume()</td><td></td><td>恢复线程运行</td></tr></tbody></table><h4 id="主线程与守护线程">3.10 主线程与守护线程</h4><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;daemon&quot;</span>);<br><span class="hljs-comment">// 设置该线程为守护线程</span><br>t1.setDaemon(<span class="hljs-literal">true</span>);<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">18</span>:08:<span class="hljs-number">31.169</span> [main] c.TestDaemon - 开始运行...<br><span class="hljs-number">18</span>:08:<span class="hljs-number">31.202</span> [daemon] c.TestDaemon - 开始运行...<br><span class="hljs-number">18</span>:08:<span class="hljs-number">32.215</span> [main] c.TestDaemon - 运行结束...<br></code></pre></div></td></tr></table></figure><blockquote><p>注意</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul></blockquote><h4 id="五种状态">3.12 五种状态</h4><p>这是从<strong>操作系统</strong>层面来描述的</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/FiveThreadState1.png" alt="FiveThreadState" /><figcaption aria-hidden="true">FiveThreadState</figcaption></figure><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="六种状态">3.13 六种状态</h4><p>这是从 <strong>Java API</strong> 层面来描述的 根据 Thread.State 枚举，分为六种状态</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/SixThreadState1.png" alt="SixThreadState" /><figcaption aria-hidden="true">SixThreadState</figcaption></figure><ul><li><p><code>NEW</code>线程刚被创建，但是还没有调用 start() 方法</p></li><li><p><code>RUNNABLE</code> 当调用了 <code>start()</code>方法之后，注意，<strong>Java API</strong> 层面的 <code>RUNNABLE</code> 状态涵盖了 <strong>操作系统</strong> 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</p></li><li><p><code>BLOCKED</code>， <code>WAITING</code> ， <code>TIMED_WAITING</code>都是 <strong>Java API</strong> 层面对【阻塞状态】的细分，详见后文状态转换部分</p></li><li><p><code>TERMINATED</code> 当线程代码运行结束</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell编程进阶</title>
    <link href="/Linux/Shell_Advance/"/>
    <url>/Linux/Shell_Advance/</url>
    
    <content type="html"><![CDATA[<h2 id="shell脚本编程进阶">Shell脚本编程进阶</h2><h3 id="创建函数">创建函数</h3><h4 id="基本的脚本函数">基本的脚本函数</h4><h5 id="创建函数-1">创建函数</h5><p>有两种格式可以用来在bash shell脚本中创建函数。第一种格式采用关键字<strong>function</strong>，后跟分配给该代码块的函数名。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">function</span> name &#123;<br>commands<br>&#125;<br><span class="hljs-comment"># 方式二</span><br><span class="hljs-function"><span class="hljs-title">name</span></span>() &#123;<br>commands<br>&#125;<br></code></pre></div></td></tr></table></figure><p>name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。 在bash shell脚本中定义函数的第二种格式更接近于其他编程语言中定义函数的方式。</p><h5 id="使用函数">使用函数</h5><p>要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using a function in a script</span><br><span class="hljs-keyword">function</span> func1 &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an example of a function&quot;</span><br>&#125;<br>count=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ]<br><span class="hljs-keyword">do</span><br>func1<br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the end of the loop&quot;</span><br>func1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Now this is the end of the script&quot;</span><br>$<br>$ ./test1<br>This is an example of a <span class="hljs-keyword">function</span><br>This is an example of a <span class="hljs-keyword">function</span><br>This is an example of a <span class="hljs-keyword">function</span><br>This is an example of a <span class="hljs-keyword">function</span><br>This is an example of a <span class="hljs-keyword">function</span><br>This is the end of the loop<br>This is an example of a <span class="hljs-keyword">function</span><br>Now this is the end of the script<br></code></pre></div></td></tr></table></figure><p>每次引用函数名func1时，bash shell会找到func1函数的定义并执行你在那里定义的命令。 函数定义不一定非得是shell脚本中首先要做的事，但一定要小心。如果在<strong>函数被定义前使用函数</strong>，你会收到一条<strong>错误</strong>消息。</p><h4 id="返回值">返回值</h4><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成退出状态码。</p><h5 id="默认退出状态码">默认退出状态码</h5><p>默认情况下，函数的退出状态码是函数中<strong>最后一条命令</strong>返回的退出状态码。在函数执行结束后，可以用标准变量<strong>$?</strong> 来确定函数的退出状态码。</p><h5 id="使用return-命令">使用return 命令</h5><p>bash shell使用<strong>return命令</strong>来退出函数并返回特定的退出状态码。return命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using the return command in a function</span><br><span class="hljs-keyword">function</span> dbl &#123;<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;doubling the value&quot;</span><br><span class="hljs-built_in">return</span> $[ <span class="hljs-variable">$value</span> * 2 ]<br>&#125;<br>dbl<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is $?&quot;</span><br></code></pre></div></td></tr></table></figure><p><code>dbl</code>函数会将<code>$value</code>变量中用户输入的值翻倍，然后用<code>return</code>命令返回结果。脚本用<strong>$?</strong> 变量显示了该值。 但当用这种方法从函数中返回值时，要小心了。记住下面两条技巧来避免问题：</p><ul><li>记住，函数一结束就取返回值；</li><li>记住，退出状态码必须是<code>0~255</code>。</li></ul><p>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，<code>$?</code>变量会返回执行的最后一条命令的退出状态码。 第二个问题界定了返回值的取值范围。由于退出状态码<strong>必须小于256</strong>，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。</p><h5 id="使用函数输出">使用函数输出</h5><p>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using the echo to return a value</span><br><span class="hljs-keyword">function</span> dbl &#123;<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value<br><span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$value</span> * 2 ]<br>&#125;<br>result=$(dbl)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is <span class="hljs-variable">$result</span>&quot;</span><br>$<br>$ ./test5b<br>Enter a value: 200<br>The new value is 400<br>$<br>$ ./test5b<br>Enter a value: 1000<br>The new value is 2000<br></code></pre></div></td></tr></table></figure><p>新函数会用<strong>echo语句</strong>来显示计算的结果。该脚本会获取<code>dbl</code>函数的输出，而不是查看退出状态码。通过这种技术，你还可以<strong>返回浮点值</strong>和<strong>字符串值</strong>。这使它成为一种<strong>获取函数返回值的强大方法</strong>。</p><p>这个例子中演示了一个不易察觉的技巧。你会注意到<code>dbl</code>函数实际上输出了两条消息。<code>read</code>命令输出了一条简短的消息来向用户询问输入值。bash shell脚本非常聪明，并不将其作为STDOUT输出的一部分，并且<strong>忽略</strong>掉它。如果你用<code>echo</code>语句生成这条消息来向用户查询，那么它会与输出值<strong>一起被读进shell变量</strong>中。</p><h4 id="在函数中使用变量">在函数中使用变量</h4><h5 id="向函数传递参数"><strong>向函数传递参数</strong></h5><p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。 在脚本中指定函数时，必须将参数和函数放在同一行，像这样：<code>func1 $value1 10</code>，然后函数可以用参数环境变量来获得参数值。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># passing parameters to a function</span><br><span class="hljs-keyword">function</span> addem &#123;<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ] || [ <span class="hljs-variable">$#</span> -gt 2 ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> -1<br>    <span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$#</span> -eq 1 ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$1</span> ]<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ]<br>    <span class="hljs-keyword">fi</span><br>&#125;<br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Adding 10 and 15: &quot;</span><br>value=$(addem 10 15)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Let&#x27;s try adding just one number: &quot;</span><br>value=$(addem 10)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Now trying adding no numbers: &quot;</span><br>value=$(addem)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Finally, try adding three numbers: &quot;</span><br>value=$(addem 10 15 20)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span><br>$<br>$ ./test6<br>Adding 10 and 15: 25<br>Let<span class="hljs-string">&#x27;s try adding just one number: 20</span><br><span class="hljs-string">Now trying adding no numbers: -1</span><br><span class="hljs-string">Finally, try adding three numbers: -1</span><br></code></pre></div></td></tr></table></figure><p>由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。下面的例子将会运行失败。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> badtest1<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># trying to access script parameters inside a function</span><br><span class="hljs-keyword">function</span> badfunc1 &#123;<br><span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ]<br>&#125;<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 2 ]<br><span class="hljs-keyword">then</span><br>value=$(badfunc1)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$value</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: badtest1 a b&quot;</span><br><span class="hljs-keyword">fi</span><br>$ ./badtest1<br>Usage: badtest1 a b<br>$ ./badtest1 10 15<br>./badtest1: * : syntax error: operand expected (error token is <span class="hljs-string">&quot;*</span><br><span class="hljs-string">&quot;</span>)<br>The result is<br>$<br></code></pre></div></td></tr></table></figure><p>尽管函数也使用了<code>$1</code>和<code>$2</code>变量，但它们和脚本主体中的<code>$1</code>和<code>$2</code>变量<strong>并不相同</strong>。要在函数中使用这些值，必须在调用函数时<strong>手动将它们传过去</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test7<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># trying to access script parameters inside a function</span><br><span class="hljs-keyword">function</span> func7 &#123;<br><span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ]<br>&#125;<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 2 ]<br><span class="hljs-keyword">then</span><br>value=$(func7 <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$value</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: badtest1 a b&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test7<br>Usage: badtest1 a b<br>$ ./test7 10 15<br>The result is 150<br></code></pre></div></td></tr></table></figure><p>通过将<code>$1</code>和<code>$2</code>变量传给函数，它们就能跟其他变量一样供函数使用了。</p><h5 id="在函数中处理变量">在函数中处理变量</h5><p><strong>1) 全局变量</strong></p><p>全局变量是在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。</p><p><strong>默认</strong>情况下，你在脚本中定义的任何变量<strong>都是全局变量</strong>。在函数外定义的变量可在函数内正常访问。</p><p><strong>2) 局部变量</strong> 无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这一点，只要在变量声明的前面加上<strong>local关键字</strong>就可以了。也可以在变量赋值语句中使用local关键字：</p><p><code>local temp=$[ $value + 5 ]</code></p><p>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test9<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># demonstrating the local keyword</span><br><span class="hljs-keyword">function</span> func1 &#123;<br>    <span class="hljs-built_in">local</span> temp=$[ <span class="hljs-variable">$value</span> + 5 ]<br>    result=$[ <span class="hljs-variable">$temp</span> * 2 ]<br>&#125;<br>temp=4<br>value=6<br>func1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$result</span>&quot;</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$temp</span> -gt <span class="hljs-variable">$value</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;temp is larger&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;temp is smaller&quot;</span><br><span class="hljs-keyword">fi</span><br>$ ./test9<br>The result is 22<br>temp is smaller<br></code></pre></div></td></tr></table></figure><h4 id="数组变量和函数">数组变量和函数</h4><h5 id="向函数传数组参数">向函数传数组参数</h5><p>向脚本函数传递数组变量的方法会有点不好理解。将数组变量当作单个参数传递的话，它不会起作用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> badtest3<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># trying to pass an array variable</span><br><span class="hljs-keyword">function</span> testit &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The parameters are: <span class="hljs-variable">$@</span>&quot;</span><br>    thisarray=<span class="hljs-variable">$1</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The received array is <span class="hljs-variable">$&#123;thisarray[*]&#125;</span>&quot;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is: <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span><br>testit <span class="hljs-variable">$myarray</span><br>$<br>$ ./badtest3<br>The original array is: 1 2 3 4 5<br>The parameters are: 1<br>The received array is 1<br></code></pre></div></td></tr></table></figure><p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，你<strong>必须将该数组变量的值分解成单个的值</strong>，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。下面是个具体的例子。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># array variable to function test</span><br><span class="hljs-keyword">function</span> testit &#123;<br>    <span class="hljs-built_in">local</span> newarray<br>    newarray=(;<span class="hljs-string">&#x27;echo &quot;$@&quot;&#x27;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new array value is: <span class="hljs-variable">$&#123;newarray[*]&#125;</span>&quot;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span><br>testit <span class="hljs-variable">$&#123;myarray[*]&#125;</span><br>$<br>$ ./test10<br>The original array is 1 2 3 4 5<br>The new array value is: 1 2 3 4 5<br></code></pre></div></td></tr></table></figure><p>该脚本用<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test11<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># adding values in an array</span><br><span class="hljs-keyword">function</span> addarray &#123;<br>    <span class="hljs-built_in">local</span> <span class="hljs-built_in">sum</span>=0<br>    <span class="hljs-built_in">local</span> newarray<br>    newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>))<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;newarray[*]&#125;</span><br>    <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">sum</span>=$[ <span class="hljs-variable">$sum</span> + <span class="hljs-variable">$value</span> ]<br>    <span class="hljs-keyword">done</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is: <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span><br>arg1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myarray[*]&#125;</span>)<br>result=$(addarray <span class="hljs-variable">$arg1</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$result</span>&quot;</span><br>$<br>$ ./test11<br>The original array is: 1 2 3 4 5<br>The result is 15<br></code></pre></div></td></tr></table></figure><h5 id="从函数返回数组">从函数返回数组</h5><p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># returning an array value</span><br><span class="hljs-keyword">function</span> arraydblr &#123;<br><span class="hljs-built_in">local</span> origarray<br><span class="hljs-built_in">local</span> newarray<br><span class="hljs-built_in">local</span> elements<br><span class="hljs-built_in">local</span> i<br>origarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>))<br>newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>))<br>elements=$[ <span class="hljs-variable">$#</span> - 1 ]<br><span class="hljs-keyword">for</span> (( i = 0; i &lt;= <span class="hljs-variable">$elements</span>; i++ ))<br>&#123;<br>newarray[<span class="hljs-variable">$i</span>]=$[ <span class="hljs-variable">$&#123;origarray[$i]&#125;</span> * 2 ]<br>&#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;newarray[*]&#125;</span><br>&#125;<br>myarray=(1 2 3 4 5)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is: <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span><br>arg1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myarray[*]&#125;</span>)<br>result=($(arraydblr <span class="hljs-variable">$arg1</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new array is: <span class="hljs-variable">$&#123;result[*]&#125;</span>&quot;</span><br>$<br>$ ./test12<br>The original array is: 1 2 3 4 5<br>The new array is: 2 4 6 8 10<br></code></pre></div></td></tr></table></figure><p>该脚本用<code>$arg1</code>变量将数组值传给<code>arraydblr</code>函数。<code>arraydblr</code>函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。 <code>arraydblr</code>函数使用<code>echo</code>语句来输出每个数组元素的值。脚本用<code>arraydblr</code>函数的输出来重新生成一个新的数组变量。</p><h4 id="函数递归">函数递归</h4><p>递归算法的经典例子是计算阶乘。阶乘函数用它自己来计算阶乘的值：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using recursion</span><br><span class="hljs-keyword">function</span> factorial &#123;<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -eq 1 ]<br>    <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> 1<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">local</span> temp=$[ <span class="hljs-variable">$1</span> - 1 ]<br>        <span class="hljs-built_in">local</span> result=$(factorial <span class="hljs-variable">$temp</span>)<br>        <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$result</span> * <span class="hljs-variable">$1</span> ]<br>    <span class="hljs-keyword">fi</span><br>&#125;<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter value: &quot;</span> value<br>result=$(factorial <span class="hljs-variable">$value</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The factorial of <span class="hljs-variable">$value</span> is: <span class="hljs-variable">$result</span>&quot;</span><br>$<br>$ ./test13<br>Enter value: 5<br>The factorial of 5 is: 120<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Shell编程基础</title>
    <link href="/Linux/Shell/"/>
    <url>/Linux/Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="shell脚本编程基础">shell脚本编程基础</h2><h3 id="构建基本脚本">构建基本脚本</h3><h4 id="使用多个命令">使用多个命令</h4><p>shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:~<span class="hljs-comment"># date ; who                             </span><br>2022年 04月 21日 星期四 11:50:18 CST                  <br>root     pts/0        2022-04-21 10:52 (192.168.200.3)<br>root     pts/1        2022-04-21 10:56 (tmux(2135).%0)<br>root     pts/2        2022-04-21 11:00 (tmux(2135).%1)<br></code></pre></div></td></tr></table></figure><h4 id="创建shell-脚本文件">创建shell 脚本文件</h4><p>创建一个shell文件，名为<code>test1.sh</code>, shell文件格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This script displays the <span class="hljs-built_in">date</span> and <span class="hljs-built_in">who</span><span class="hljs-string">&#x27;s logged on</span></span><br>date<br>who<br></code></pre></div></td></tr></table></figure><p>运行过程：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 直接运行出错</span><br>$ test1<br>bash: test1: <span class="hljs-built_in">command</span> not found<br><span class="hljs-comment"># 解决办法：</span><br><span class="hljs-comment"># 1.将shell脚本文件所处的目录添加到PATH环境变量中；</span><br><span class="hljs-comment"># 2.在提示符中用绝对或相对文件路径来引用shell脚本文件。</span><br>$ ./test1<br>bash: ./test1: Permission denied<br><br>$ <span class="hljs-built_in">chmod</span> u+x test1<br>$ ./test1<br>root@Ubuntu:/home/seon/shell/ch11<span class="hljs-comment"># ./test1.sh </span><br>2022年 04月 21日 星期四 14:39:29 CST                  <br>root     pts/0        2022-04-21 10:52 (192.168.200.3)<br>root     pts/1        2022-04-21 10:56 (tmux(2135).%0)<br>root     pts/2        2022-04-21 11:00 (tmux(2135).%1)<br>root     pts/3        2022-04-21 11:56 (tmux(2135).%3)<br></code></pre></div></td></tr></table></figure><h4 id="显示消息">显示消息</h4><p>修改<code>test1.sh</code>文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This script displays the <span class="hljs-built_in">date</span> and <span class="hljs-built_in">who</span><span class="hljs-string">&#x27;s logged on</span></span><br>echo The time and date are:<br>date<br>echo &quot;Let&#x27;s see who&#x27;s logged into the system:&quot;<br>who<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:/home/seon/shell/ch11<span class="hljs-comment"># ./test1.sh</span><br>The time and <span class="hljs-built_in">date</span> are:<br>2022年 04月 21日 星期四 15:34:40 CST<br>Let<span class="hljs-string">&#x27;s see who&#x27;</span>s logged into the system:<br>root     pts/0        2022-04-21 10:52 (192.168.200.3)<br>root     pts/1        2022-04-21 10:56 (tmux(2135).%0)<br>root     pts/2        2022-04-21 11:00 (tmux(2135).%1)<br>root     pts/3        2022-04-21 11:56 (tmux(2135).%3)<br>root     pts/4        2022-04-21 14:51 (tmux(2135).%4<br></code></pre></div></td></tr></table></figure><p>但如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用<strong>echo</strong>语句的<strong>-n</strong>参数。只要将第一个echo语句改成这样就行：<code>echo -n "The time and date are: "</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:/home/seon/shell/ch11<span class="hljs-comment"># ./test1.sh       </span><br>The time and <span class="hljs-built_in">date</span> are: 2022年 04月 21日 星期四 15:37:57 CST <br>...<br></code></pre></div></td></tr></table></figure><h4 id="使用变量">使用变量</h4><h5 id="用户变量">用户变量</h5><p>用户变量可以是任何由<strong>字母、数字或下划线</strong>组成的文本字符串，长度不超过20个。用户变量<strong>区分大小写</strong>，所以变量Var1和变量var1是不同的。使用等号将值赋给用户变量。在变量、等号和值之间<strong>不能出现空格</strong>。</p><p>与系统变量类似，用户变量可通过<strong>美元符</strong><code>$</code>引用。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">var1=10<br>var2=-57<br>var3=testing<br>var4=&quot;still more testing&quot;<br><br>days=10<br>guest=&quot;Katie&quot;<br>echo &quot;$guest checked in $days days ago&quot;<br>days=5<br>guest=&quot;Jessica&quot;<br>echo &quot;$guest checked in $days days ago&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出结果</span><br>Katie checked in 10 days ago<br>Jessica checked in 5 days ago<br></code></pre></div></td></tr></table></figure><p>shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉。</p><h5 id="命令替换">命令替换</h5><p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：</p><ul><li>反引号字符（`）</li><li><code>$()</code>格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5<br><span class="hljs-comment">#!/bin/bash</span><br>testing=$(<span class="hljs-built_in">date</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The date and time are: &quot;</span> <span class="hljs-variable">$testing</span><br>$ <span class="hljs-built_in">chmod</span> u+x test5<br>$ ./test5<br>The <span class="hljs-built_in">date</span> and time are: Mon Jan 31 20:23:25 EDT 2014<br></code></pre></div></td></tr></table></figure><h4 id="重定向输入和输出">重定向输入和输出</h4><h5 id="输出重定向">输出重定向</h5><p>最基本的重定向将命令的输出发送到一个文件中。bash shell用<strong>大于号（&gt;）</strong>来完成这项功能：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">date</span> &gt; test6<br>$ <span class="hljs-built_in">ls</span> -l test6<br>-rw-r--r-- 1 user user 29 Feb 10 17:56 test6<br>$ <span class="hljs-built_in">cat</span> test6<br>Thu Feb 10 17:56:58 EDT 2014<br></code></pre></div></td></tr></table></figure><p>有时，你可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如你正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用<strong>双大于号（&gt;&gt;）</strong>来<strong>追加</strong>数据。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">who</span> &gt;&gt; test6<br>$ <span class="hljs-built_in">cat</span> test6<br>user pts/0 Feb 10 17:55<br>Thu Feb 10 18:02:14 EDT 2014<br>user pts/0 Feb 10 17:55<br></code></pre></div></td></tr></table></figure><h5 id="输入重定向">输入重定向</h5><p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是<strong>小于号（&lt;）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">wc</span> &lt; test6<br>2 11 60<br></code></pre></div></td></tr></table></figure><p><strong><code>wc</code>命令</strong>可以对对数据中的文本进行<strong>计数</strong>。默认情况下，它会输出3个值：</p><ul><li>文本的行数</li><li>文本的词数</li><li>文本的字节数</li></ul><p>还有另外一种输入重定向的方法，称为<strong>内联输入重定向</strong>（inline input redirection）。这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。内联输入重定向符号是<strong>远小于号（&lt;&lt;）</strong>。除了这个符号，你必须指定一个<strong>文本标记</strong>来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记<strong>必须一致</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">wc</span> &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&gt; test string 1</span><br><span class="hljs-string">&gt; test string 2</span><br><span class="hljs-string">&gt; test string 3</span><br><span class="hljs-string">&gt; EOF</span><br>3 9 42<br></code></pre></div></td></tr></table></figure><h4 id="管道">管道</h4><p>管道被放在命令之间，将一个命令的输出重定向到另一个命令中。不要以为由管道串起的两个命令会依次执行。Linux系统实际上会<strong>同时运行</strong>这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p><p><strong><code>rpm</code>命令</strong>通过Red Hat包管理系统（RPM）对系统（比如上例中的Fedora系统）上安装的软件包进行管理。配合<code>-qa</code>选项使用时，它会生成已安装包的列表，但这个列表并不会遵循某种特定的顺序现在，可以利用管道将rpm命令的输出送入sort命令来按字母顺序对软件包名称进行排序。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rpm -qa | <span class="hljs-built_in">sort</span><br>abrt-1.1.14-1.fc14.i686<br>abrt-addon-ccpp-1.1.14-1.fc14.i686<br>abrt-addon-kerneloops-1.1.14-1.fc14.i686<br>abrt-addon-python-1.1.14-1.fc14.i686<br>abrt-desktop-1.1.14-1.fc14.i686<br>abrt-gui-1.1.14-1.fc14.i686<br>abrt-libs-1.1.14-1.fc14.i686<br>abrt-plugin-bugzilla-1.1.14-1.fc14.i686<br>abrt-plugin-logger-1.1.14-1.fc14.i686<br>abrt-plugin-runapp-1.1.14-1.fc14.i686<br>acl-2.2.49-8.fc14.i686<br>[...]<br></code></pre></div></td></tr></table></figure><h4 id="执行数学运算">执行数学运算</h4><h5 id="expr-命令">expr 命令</h5><p>最开始，Bourne shell提供了一个特别的命令用来处理数学表达式。expr命令允许在命令行上处理数学表达式，但是特别笨拙。以下列出expr命令支持的常见运算符。</p><p><strong>算术运算符</strong></p><p>以下表格均假定变量 a 为 10，变量 b 为 20</p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">+</td><td style="text-align: left;">加法</td><td style="text-align: left;"><code>expr $a + $b</code> 结果为 30。</td></tr><tr class="even"><td style="text-align: left;">-</td><td style="text-align: left;">减法</td><td style="text-align: left;"><code>expr $a - $b</code> 结果为 -10。</td></tr><tr class="odd"><td style="text-align: left;">*</td><td style="text-align: left;">乘法</td><td style="text-align: left;"><code>expr $a \* $b</code> 结果为 200。</td></tr><tr class="even"><td style="text-align: left;">/</td><td style="text-align: left;">除法</td><td style="text-align: left;"><code>expr $b / $a</code> 结果为 2。</td></tr><tr class="odd"><td style="text-align: left;">%</td><td style="text-align: left;">取余</td><td style="text-align: left;"><code>expr $b % $a</code> 结果为 0。</td></tr><tr class="even"><td style="text-align: left;">=</td><td style="text-align: left;">赋值</td><td style="text-align: left;"><code>a=$b</code> 把变量 b 的值赋给 a。</td></tr><tr class="odd"><td style="text-align: left;">==</td><td style="text-align: left;">相等。用于比较两个数字，相同则返回 true。</td><td style="text-align: left;"><code>[ $a == $b ]</code> 返回 false。</td></tr><tr class="even"><td style="text-align: left;">!=</td><td style="text-align: left;">不相等。用于比较两个数字，不相同则返回 true。</td><td style="text-align: left;"><code>[ $a != $b ]</code> 返回 true。</td></tr></tbody></table><p><strong>关系运算符</strong></p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">-eq</td><td style="text-align: left;">检测两个数是否相等，相等返回 true。</td><td style="text-align: left;"><code>[ $a -eq $b ]</code> 返回 false。</td></tr><tr class="even"><td style="text-align: left;">-ne</td><td style="text-align: left;">检测两个数是否不相等，不相等返回 true。</td><td style="text-align: left;"><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr class="odd"><td style="text-align: left;">-gt</td><td style="text-align: left;">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align: left;"><code>[ $a -gt $b ]</code>返回 false。</td></tr><tr class="even"><td style="text-align: left;">-lt</td><td style="text-align: left;">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align: left;"><code>[ $a -lt $b ]</code>返回 true。</td></tr><tr class="odd"><td style="text-align: left;">-ge</td><td style="text-align: left;">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style="text-align: left;"><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr class="even"><td style="text-align: left;">-le</td><td style="text-align: left;">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align: left;"><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><p><strong>布尔运算符</strong></p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">!</td><td style="text-align: left;">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align: left;"><code>[ ! false ]</code> 返回 true。</td></tr><tr class="even"><td style="text-align: left;">-o</td><td style="text-align: left;">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align: left;"><code>[ $a -lt 20 -o $b -gt 100 ]</code>返回 true。</td></tr><tr class="odd"><td style="text-align: left;">-a</td><td style="text-align: left;">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align: left;"><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><p><strong>逻辑运算符</strong></p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">&amp;&amp;</td><td style="text-align: left;">逻辑的 AND</td><td style="text-align: left;"><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code>返回 false</td></tr><tr class="even"><td style="text-align: left;">||</td><td style="text-align: left;">逻辑的 OR</td><td style="text-align: left;"><code>[[ $a -lt 100 \|\| $b -gt 100 ]]</code> 返回 true</td></tr></tbody></table><p><strong>字符运算符</strong></p><p>以下假定变量 a 为 "abc"，变量 b 为 "efg"</p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">=</td><td style="text-align: left;">检测两个字符串是否相等，相等返回 true。</td><td style="text-align: left;"><code>[ $a = $b ]</code>返回 false。</td></tr><tr class="even"><td style="text-align: left;">!=</td><td style="text-align: left;">检测两个字符串是否不相等，不相等返回 true。</td><td style="text-align: left;"><code>[ $a != $b ]</code>返回 true。</td></tr><tr class="odd"><td style="text-align: left;">-z</td><td style="text-align: left;">检测字符串长度是否为0，为0返回 true。</td><td style="text-align: left;"><code>[ -z $a ]</code> 返回 false。</td></tr><tr class="even"><td style="text-align: left;">-n</td><td style="text-align: left;">检测字符串长度是否不为 0，不为 0 返回 true。</td><td style="text-align: left;"><code>[ -n "$a" ]</code>返回 true。</td></tr><tr class="odd"><td style="text-align: left;">$</td><td style="text-align: left;">检测字符串是否为空，不为空返回 true。</td><td style="text-align: left;"><code>[ $a ]</code>返回 true。</td></tr></tbody></table><p>尽管标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。许多expr命令操作符在shell中另有含义（比如星号）。当它们出现在在expr命令中时，会得到一些诡异的结果。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">expr</span> 5 * 2<br><span class="hljs-built_in">expr</span>: syntax error<br><span class="hljs-comment"># 转义*</span><br>$ <span class="hljs-built_in">expr</span> 5 \* 2<br>10<br></code></pre></div></td></tr></table></figure><p>要解决这个问题，对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符（反斜线）将其标出来。</p><p>在shell脚本中使用expr命令也同样复杂：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># An example of using the expr command</span><br>var1=10<br>var2=20<br>var3=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$var2</span> / <span class="hljs-variable">$var1</span>)<br><span class="hljs-built_in">echo</span> The result is <span class="hljs-variable">$var3</span><br><br>$ <span class="hljs-built_in">chmod</span> u+x test6<br>$ ./test6<br>The result is 2<br></code></pre></div></td></tr></table></figure><h5 id="使用方括号">使用方括号</h5><p>bash shell为了保持跟Bourne shell的兼容而包含了expr命令，但它同样也提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用<strong>美元符和方括号（$[ operation ]）</strong>将数学表达式围起来。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ var1=$[1 + 5]<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>6<br>$ var2=$[<span class="hljs-variable">$var1</span> * 2]<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var2</span><br>12<br></code></pre></div></td></tr></table></figure><p>这种技术也适用于shell脚本。同样，注意在使用方括号来计算公式时，不用担心shell会误解乘号或其他符号。shell知道它不是通配符，因为它在方括号内。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test7<br><span class="hljs-comment">#!/bin/bash</span><br>var1=100<br>var2=50<br>var3=45<br>var4=$[<span class="hljs-variable">$var1</span> * (<span class="hljs-variable">$var2</span> - <span class="hljs-variable">$var3</span>)]<br><span class="hljs-built_in">echo</span> The final result is <span class="hljs-variable">$var4</span><br><br><span class="hljs-comment"># 运行结果</span><br>$ <span class="hljs-built_in">chmod</span> u+x test7<br>$ ./test7<br>The final result is 500<br></code></pre></div></td></tr></table></figure><p>bash shell数学运算符<strong>只支持整数</strong>运算。若要进行任何实际的数学计算，这是一个巨大的限制。</p><blockquote><p>z shell（zsh）提供了完整的浮点数算术操作。如果需要在shell脚本中进行浮点数运算，可以考虑看看z shell。</p></blockquote><h5 id="浮点解决方案">浮点解决方案</h5><p>有几种解决方案能够克服bash中数学运算的整数限制。最常见的方案是用内建的<strong>bash计算器</strong>，叫作<strong>bc</strong>。bash计算器实际上是一种编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。bash计算器能够识别：</p><ul><li>数字（整数和浮点数）</li><li>变量（简单变量和数组）</li><li>注释（以#或C语言中的/* */开始的行）</li><li>表达式</li><li>编程语句（例如if-then语句）</li><li>函数</li></ul><p><strong>bc基本使用</strong></p><p>可以在shell提示符下通过bc命令访问bash计算器，要退出bash计算器，必须输入<strong>quit</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:~<span class="hljs-comment"># bc -h</span><br>usage: bc [options] [file ...]<br>  -h  --<span class="hljs-built_in">help</span>         <span class="hljs-built_in">print</span> this usage and <span class="hljs-built_in">exit</span><br>  -i  --interactive  force interactive mode<br>  -l  --mathlib      use the predefined math routines<br>  -q  --quiet        don<span class="hljs-string">&#x27;t print initial banner</span><br><span class="hljs-string">  -s  --standard     non-standard bc constructs are errors</span><br><span class="hljs-string">  -w  --warn         warn about non-standard bc constructs</span><br><span class="hljs-string">  -v  --version      print version information and exit</span><br><span class="hljs-string">root@Ubuntu:~#</span><br><span class="hljs-string">root@Ubuntu:~# bc</span><br><span class="hljs-string">bc 1.07.1</span><br><span class="hljs-string">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.</span><br><span class="hljs-string">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="hljs-string">For details type `warranty&#x27;</span>.<br>12 * 5.4<br>64.8<br>3.156 * (3 + 5)<br>25.248<br>quit<br>root@Ubuntu:~<br></code></pre></div></td></tr></table></figure><p>浮点运算是由<strong>内建变量scale</strong>控制的。必须将这个值设置为你希望在计算结果中保留的小数位数，否则无法得到期望的结果。scale变量的<strong>默认值是0</strong>。在scale值被设置前，bash计算器的计算结果不包含小数位。<code>-q</code>命令行选项可以不显示bash计算器冗长的欢迎信息。除了普通数字，bash计算器还能<strong>支持变量</strong>。变量一旦被定义，你就可以在整个bash计算器会话中使用该变量了。print语句允许你打印变量和数字。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ bc -q<br>3.44 / 5<br>0<br>scale=4<br>3.44 / 5<br>.6880<br>quit<br>$<br><br>$ bc -q<br>var1=10<br>var1 * 4<br>40<br>var2 = var1 / 5<br><span class="hljs-built_in">print</span> var2<br>2<br>quit<br>$<br></code></pre></div></td></tr></table></figure><p><strong>在脚本中使用bc</strong></p><p>bash计算器是如何在shell脚本中帮助处理浮点运算？可以用<strong>命令替换</strong>运行bc命令，并将输出赋给一个变量。基本格式如下： <code>variable=$(echo "options; expression" | bc)</code></p><p>第一部分options允许你设置变量。如果你需要不止一个变量，可以用分号将其分开。expression参数定义了通过bc执行的数学表达式。见如下例子：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10<br><span class="hljs-comment">#!/bin/bash</span><br>var1=100<br>var2=45<br>var3=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=4; <span class="hljs-variable">$var1</span> / <span class="hljs-variable">$var2</span>&quot;</span> | bc)<br><span class="hljs-built_in">echo</span> The answer <span class="hljs-keyword">for</span> this is <span class="hljs-variable">$var3</span><br>$<br>$ ./test10<br>The answer <span class="hljs-keyword">for</span> this is 2.2222<br></code></pre></div></td></tr></table></figure><p>这个方法适用于较短的运算，但有时你会涉及更多的数字。如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。有一个方法可以解决这个问题。bc命令能识别输入重定向，允许你将一个文件重定向到bc命令来处理。但这同样会叫人头疼，因为你还得将表达式存放到文件中。最好的办法是使用<strong>内联输入重定向</strong>，它允许你直接在命令行中重定向数据。在shell脚本中，你可以将输出赋给一个变量。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">variable=$(bc &lt;&lt; EOF<br>options<br>statements<br>expressions<br>EOF<br>)<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:/home/shell/ch11<span class="hljs-comment"># cat ./test12</span><br><span class="hljs-comment">#!/bin/bash</span><br>var1=10.46<br>var2=43.67<br>var3=33.2<br>var4=71<br>var5=$(bc &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">scale = 4</span><br><span class="hljs-string">a1 = ( $var1 * $var2)</span><br><span class="hljs-string">b1 = ($var3 * $var4)</span><br><span class="hljs-string">a1 + b1</span><br><span class="hljs-string">EOF</span><br>)<br><span class="hljs-built_in">echo</span> The final answer <span class="hljs-keyword">for</span> this mess is <span class="hljs-variable">$var</span><br>root@Ubuntu:/home/shell/ch11<span class="hljs-comment">#</span><br>root@Ubuntu:/home/shell/ch11<span class="hljs-comment"># ./test12</span><br>The final answer <span class="hljs-keyword">for</span> this mess is 2813.9882<br></code></pre></div></td></tr></table></figure><h4 id="退出脚本">退出脚本</h4><p>shell中运行的每个命令都使用<strong>退出状态码</strong>（exit status）告诉shell它已经运行完毕。退出状态码是一个<strong>0～255</strong>的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。</p><h5 id="查看退出状态码">查看退出状态码</h5><p>Linux提供了一个专门的<strong>变量$?</strong> 来保存上个已执行命令的退出状态码。对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用<code>\$?</code>变量。它的值会变成由shell所执行的最后一条命令的退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">date</span><br>Sat Jan 15 10:01:30 EDT 2014<br>$ <span class="hljs-built_in">echo</span> $?<br>0<br>$ asdfg<br>-bash: asdfg: <span class="hljs-built_in">command</span> not found<br>$ <span class="hljs-built_in">echo</span> $?<br>127<br>$<br>$ ./myprog.c<br>-bash: ./myprog.c: Permission denied<br>$ <span class="hljs-built_in">echo</span> $?<br>126<br>$ <span class="hljs-built_in">date</span> %t<br><span class="hljs-built_in">date</span>: invalid <span class="hljs-built_in">date</span> <span class="hljs-string">&#x27;%t&#x27;</span><br>$ <span class="hljs-built_in">echo</span> $?<br>1<br></code></pre></div></td></tr></table></figure><p>按照惯例，一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态。无效命令会返回一个退出状态码127。Linux错误退出状态码没有什么标准可循，但有一些可用的参考，如下表所示。</p><table><thead><tr class="header"><th style="text-align: center;">状态码</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">命令成功结束</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">一般性未知错误</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">不适合的shell命令</td></tr><tr class="even"><td style="text-align: center;">126</td><td style="text-align: center;">命令不可执行</td></tr><tr class="odd"><td style="text-align: center;">127</td><td style="text-align: center;">没找到命令</td></tr><tr class="even"><td style="text-align: center;">128</td><td style="text-align: center;">无效的退出参数</td></tr><tr class="odd"><td style="text-align: center;">128+x</td><td style="text-align: center;">与Linux信号x相关的严重错误</td></tr><tr class="even"><td style="text-align: center;">130</td><td style="text-align: center;">通过Ctrl+C终止的命令</td></tr><tr class="odd"><td style="text-align: center;">255</td><td style="text-align: center;">正常范围之外的退出状态码</td></tr></tbody></table><p>你可以改变这种默认行为，返回自己的退出状态码。exit命令允许你在脚本结束时指定一个退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the exit status</span><br>var1=10<br>var2=30<br>var3=$[<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>]<br><span class="hljs-built_in">echo</span> The answer is <span class="hljs-variable">$var3</span><br><span class="hljs-built_in">exit</span> 5<br><br><span class="hljs-comment"># 测试结果：</span><br>$ <span class="hljs-built_in">chmod</span> u+x test13<br>$ ./test13<br>The answer is 40<br>$ <span class="hljs-built_in">echo</span> $?<br>5<br>$<br><br><span class="hljs-comment"># 也可以在exit命令的参数中使用变量</span><br>$ <span class="hljs-built_in">cat</span> test14<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the exit status</span><br>var1=10<br>var2=30<br>var3=$[<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>]<br><span class="hljs-built_in">exit</span> <span class="hljs-variable">$var3</span><br><span class="hljs-comment"># 测试结果：</span><br>$ <span class="hljs-built_in">chmod</span> u+x test14<br>$ ./test14<br>$ <span class="hljs-built_in">echo</span> $?<br>40<br>$<br><br></code></pre></div></td></tr></table></figure><p>注意这个功能，因为退出状态码最大只能是255。看下面例子中会怎样:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test14b<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the exit status</span><br>var1=10<br>var2=30<br>var3=$[<span class="hljs-variable">$var1</span> * <span class="hljs-variable">$var2</span>]<br><span class="hljs-built_in">echo</span> The value is <span class="hljs-variable">$var3</span><br><span class="hljs-built_in">exit</span> <span class="hljs-variable">$var3</span><br>$<br><span class="hljs-comment"># 运行结果：</span><br>$ ./test14b<br>The value is 300<br>$ <span class="hljs-built_in">echo</span> $?<br>44<br></code></pre></div></td></tr></table></figure><p>退出状态码被缩减到了0～255的区间。shell通过模运算得到这个结果。一个值的模就是被除后的余数。最终的结果是指定的数值除以256后得到的余数。在这个例子中，指定的值是300（返回值），余数是44，因此这个余数就成了最后的状态退出码。</p><h3 id="结构化命令">结构化命令</h3><h4 id="使用if-then-语句">使用if-then 语句</h4><p>最基本的结构化命令就是<code>if-then</code>语句。<code>if-then</code>语句有如下格式。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 过if-then语句的另一种形式：</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span>; <span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># 通过把分号放在待求值的命令尾部，就可以将then语句放在同一行上了，这样看起来更像其他编程语言中的if-then语句。</span><br></code></pre></div></td></tr></table></figure><p>bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码（参见第11章）是0（该命令成功运行），位于<code>then</code>部分的命令就会被执行。如果该命令的退出状态码是其他值，<code>then</code>部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。<code>fi</code>语句用来表示<code>if-then</code>语句到此结束。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">root@Ubuntu:/home/shell/ch12<span class="hljs-comment"># cat test1</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the if statement</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">pwd</span><br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;It worked&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 运行结果：shell执行了if行中的pwd命令。由于退出状态码是0，它就又执行了then部分的echo语句 </span><br>root@Ubuntu:/home/shell/ch12<span class="hljs-comment"># ./test1</span><br>/home/seon/shell/ch12<br>It worked<br></code></pre></div></td></tr></table></figure><p>在then部分，你可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell会将这些命令当成一个块，如果if语句行的命令的退出状态值为0，所有的命令都会被执行；如果if语句行的命令的退出状态不为0，所有的命令都会被跳过。</p><h4 id="if-then-else-语句">if-then-else 语句</h4><p>当if语句中的命令返回退出状态码<code>0</code>时，<code>then</code>部分中的命令会被执行，这跟普通的<code>if-then</code>语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行<code>else</code>部分中的命令。<code>if-then-else</code>语句结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">else</span><br>commands<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cp</span> test3.sh test4.sh<br>$<br>$ nano test4.sh<br>$<br>$ <span class="hljs-built_in">cat</span> test4.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the else section</span><br><span class="hljs-comment">#</span><br>testuser=NoSuchUser<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> grep <span class="hljs-variable">$testuser</span> /etc/passwd<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The bash files for user <span class="hljs-variable">$testuser</span> are:&quot;</span><br><span class="hljs-built_in">ls</span> -a /home/<span class="hljs-variable">$testuser</span>/.b*<br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The user <span class="hljs-variable">$testuser</span> does not exist on this system.&quot;</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test4.sh<br>The user NoSuchUser does not exist on this system.<br></code></pre></div></td></tr></table></figure><h4 id="嵌套if">嵌套if</h4><p>要检查<code>/etc/passwd</code>文件中是否存在某个用户名以及该用户的目录是否尚在，可以使用嵌套的<code>if-then</code>语句。嵌套的<code>if-then</code>语句位于主<code>if-then-else</code>语句的<code>else</code>代码块中。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -d /home/NoSuchUser/<br>/home/NoSuchUser/<br>$<br>$ <span class="hljs-built_in">cat</span> test5.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Testing nested ifs</span><br><span class="hljs-comment">#</span><br>testuser=NoSuchUser<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> grep <span class="hljs-variable">$testuser</span> /etc/passwd<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The user <span class="hljs-variable">$testuser</span> exists on this system.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The user <span class="hljs-variable">$testuser</span> does not exist on this system.&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">ls</span> -d /home/<span class="hljs-variable">$testuser</span>/<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;However, <span class="hljs-variable">$testuser</span> has a directory.&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test5.sh<br>The user NoSuchUser does not exist on this system.<br>/home/NoSuchUser/<br>However, NoSuchUser has a directory.<br></code></pre></div></td></tr></table></figure><p>这个脚本准确无误地发现，尽管登录名已经从<code>/etc/passwd</code>中删除了，但是该用户的目录仍然存在。在脚本中使用这种嵌套<code>if-then</code>语句的问题在于代码不易阅读，很难理清逻辑流程。可以使用<code>else</code>部分的另一种形式：<code>elif</code>。这样就不用再书写多个<code>if-then</code>语句了。<code>elif</code>使用另一个<code>if-then</code>语句延续<code>else</code>部分。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> command1<br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">elif</span> command2<br><span class="hljs-keyword">then</span><br>more commands<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p><code>elif</code>语句行提供了另一个要测试的命令，这类似于原始的<code>if</code>语句行。如果<code>elif</code>后命令的退出状态码是<code>0</code>，则bash会执行第二个<code>then</code>语句部分的命令。使用这种嵌套方法，代码更清晰，逻辑更易懂。甚至可以更进一步，让脚本检查拥有目录的不存在用户以及没有拥有目录的不存在用户。这可以通过在嵌套<code>elif</code>中加入一个<code>else</code>语句来实现。</p><p>记住，在<code>elif</code>语句中，紧跟其后的<code>else</code>语句属于<code>elif</code>代码块。它们并不属于之前的<code>if-then</code>代码块。可以继续将多个<code>elif</code>语句串起来，形成一个大的<code>if-then-elif</code>嵌套组合。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> command1<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 1<br><span class="hljs-keyword">elif</span> command2<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 2<br><span class="hljs-keyword">elif</span> command3<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 3<br><span class="hljs-keyword">elif</span> command4<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 4<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p>每块命令都会根据命令是否会返回退出状态码0来执行。记住，bash shell会依次执行if语句，只有第一个返回退出状态码0的语句中的then部分会被执行。</p><h4 id="test命令">test命令</h4><p>test命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码<code>0</code>。这样<code>if-then</code>语句就与其他编程语言中的<code>if-then</code>语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得<code>if-then</code>语句不会再被执行。</p><p>test命令的格式非常简单：<code>test condition</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p>如果不写test命令的<code>condition</code>部分，它会以非零的退出状态码退出，并执行<code>else</code>语句块。当你加入一个条件时，test命令会测试该条件。例如，可以使用test命令确定变量中是否有内容，这只需要一个简单的条件表达式：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Testing the test command</span><br><br>my_variable=<span class="hljs-string">&quot;Full&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$my_variable</span><br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$my_variable</span> expression returns a True&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$my_variable</span> expression returns a False&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test6.sh<br>The Full expression returns a True<br><span class="hljs-comment"># 当调整为 my_variable=&quot;&quot; 会输出else部分内容</span><br></code></pre></div></td></tr></table></figure><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]<br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p><strong>方括号</strong>定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p><p>test命令可以判断三类条件：</p><ul><li>数值比较</li><li>字符串比较</li><li>文件比较</li></ul><h5 id="数值比较">数值比较</h5><p>数值条件测试可以用在数字和变量上，但是涉及浮点值时，数值条件测试会有一个限制。bash shell只能处理整数。如果你只是要通过echo语句来显示浮点数结果，那没问题。但是，在基于数字的函数中就不行了。</p><p>比较的命令参见上一章<code>expr命令</code>小节中的表格<strong>关系运算符</strong>，常用的有：<code>-eq/-ge/-gt/-le/-lt/-ne</code>等。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.整数测试</span><br>$ <span class="hljs-built_in">cat</span> numeric_test.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Using numeric test evaluations</span><br>value1=10<br>value2=11<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -gt 5 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The test value <span class="hljs-variable">$value1</span> is greater than 5&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -eq <span class="hljs-variable">$value2</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The values are equal&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The values are different&quot;</span><br><span class="hljs-keyword">fi</span><br><br>$ ./numeric_test.sh<br>The <span class="hljs-built_in">test</span> value 10 is greater than 5<br>The values are different<br><br><span class="hljs-comment"># 2.浮点数测试出现问题</span><br>$ <span class="hljs-built_in">cat</span> floating_point_test.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Using floating point numbers in test evaluations</span><br><span class="hljs-comment">#</span><br>value1=5.555<br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The test value is <span class="hljs-variable">$value1</span>&quot;</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -gt 5 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The test value <span class="hljs-variable">$value1</span> is greater than 5&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#</span><br>$ ./floating_point_test.sh<br>The <span class="hljs-built_in">test</span> value is 5.555<br>./floating_point_test.sh: line 8:<br>[: 5.555: <span class="hljs-built_in">integer</span> expression expected<br></code></pre></div></td></tr></table></figure><h5 id="字符串比较">字符串比较</h5><p>以下假定变量 a 为 "abc"，变量 b 为 "efg"</p><table><colgroup><col style="width: 14%" /><col style="width: 53%" /><col style="width: 31%" /></colgroup><thead><tr class="header"><th style="text-align: left;">字符串运算符</th><th style="text-align: left;">说明</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">=</td><td style="text-align: left;">检测两个字符串是否相等，相等返回 true。</td><td style="text-align: left;">[ $a = $b ] 返回 false。</td></tr><tr class="even"><td style="text-align: left;">!=</td><td style="text-align: left;">检测两个字符串是否不相等，不相等返回 true。</td><td style="text-align: left;">[ $a != $b ] 返回 true。</td></tr><tr class="odd"><td style="text-align: left;">&lt;</td><td style="text-align: left;">检查a是否比b小</td><td style="text-align: left;">[ $a 0 $b ] 返回true。</td></tr><tr class="even"><td style="text-align: left;">&gt;</td><td style="text-align: left;">检查a是否比b大</td><td style="text-align: left;">[ $a 0 $b ] 返回false。</td></tr><tr class="odd"><td style="text-align: left;">-z</td><td style="text-align: left;">检测字符串长度是否为0，为0返回 true。</td><td style="text-align: left;">[ -z $a ] 返回 false。 | | -n | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。</td></tr><tr class="even"><td style="text-align: left;">$</td><td style="text-align: left;">检测字符串是否为空，不为空返回 true。</td><td style="text-align: left;">[ $a ] 返回 true。</td></tr></tbody></table><p>注意以下问题：</p><ul><li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件 名；</li><li>大于和小于顺序和<strong>sort命令</strong>所采用的不同。</li><li>空的和未初始化的变量会对shell脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过-n或-z来测试一下变量是否含有值。</li></ul><h5 id="文件比较">文件比较</h5><p>最后一类比较测试很有可能是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。</p><table><thead><tr class="header"><th style="text-align: center;">比较</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-d file</td><td style="text-align: center;">检查file是否存在并是一个目录</td></tr><tr class="even"><td style="text-align: center;">-e file</td><td style="text-align: center;">检查file是否存在，可用于文件和目录</td></tr><tr class="odd"><td style="text-align: center;">-f file</td><td style="text-align: center;">检查file是否存在并是一个文件</td></tr><tr class="even"><td style="text-align: center;">-r file</td><td style="text-align: center;">检查file是否存在并可读</td></tr><tr class="odd"><td style="text-align: center;">-s file</td><td style="text-align: center;">检查file是否存在并非空</td></tr><tr class="even"><td style="text-align: center;">-w file</td><td style="text-align: center;">检查file是否存在并可写</td></tr><tr class="odd"><td style="text-align: center;">-x file</td><td style="text-align: center;">检查file是否存在并可执行</td></tr><tr class="even"><td style="text-align: center;">-O file</td><td style="text-align: center;">检查file是否存在并属当前用户所有</td></tr><tr class="odd"><td style="text-align: center;">-G file</td><td style="text-align: center;">检查file是否存在并且默认组与当前用户相同</td></tr><tr class="even"><td style="text-align: center;">file1 -nt file2</td><td style="text-align: center;">检查file1是否比file2新</td></tr><tr class="odd"><td style="text-align: center;">file1 -ot file2</td><td style="text-align: center;">检查file1是否比file2旧</td></tr></tbody></table><h4 id="复合条件测试">复合条件测试</h4><p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p><p><code>[ condition1 ] &amp;&amp; [ condition2 ]</code> 或者<code>[ condition1 ] || [ condition2 ]</code></p><p>例如，AND布尔运算符的使用：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test22.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing compound comparisons</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$HOME</span> ] &amp;&amp; [ -w <span class="hljs-variable">$HOME</span>/testing ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The file exists and you can write to it&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I cannot write to the file&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test22.sh<br>I cannot write to the file<br>$<br>$ <span class="hljs-built_in">touch</span> <span class="hljs-variable">$HOME</span>/testing<br>$<br>$ ./test22.sh<br>The file exists and you can write to it<br></code></pre></div></td></tr></table></figure><h4 id="if-then-的高级特性">if-then 的高级特性</h4><p>bash shell提供了两项可在if-then语句中使用的高级特性：</p><ul><li><p>用于数学表达式的双括号</p></li><li><p>用于高级字符串处理功能的双方括号</p></li></ul><h5 id="使用双括号">使用双括号</h5><p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号，这些符号对于用过其他编程语言的程序员而言并不陌生。双括号命令的格式如下：</p><p><code>(( expression ))</code></p><p>expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，下表列出了双括号命令中会用到的其他运算符。</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">val++</td><td style="text-align: center;">后增</td></tr><tr class="even"><td style="text-align: center;">val--</td><td style="text-align: center;">后减</td></tr><tr class="odd"><td style="text-align: center;">++val</td><td style="text-align: center;">先增</td></tr><tr class="even"><td style="text-align: center;">--val</td><td style="text-align: center;">先减</td></tr><tr class="odd"><td style="text-align: center;">!</td><td style="text-align: center;">逻辑求反</td></tr><tr class="even"><td style="text-align: center;">~</td><td style="text-align: center;">位求反</td></tr><tr class="odd"><td style="text-align: center;">**</td><td style="text-align: center;">幂运算</td></tr><tr class="even"><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">左位移</td></tr><tr class="odd"><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">右位移</td></tr><tr class="even"><td style="text-align: center;">&amp;</td><td style="text-align: center;">位布尔和</td></tr><tr class="odd"><td style="text-align: center;">|</td><td style="text-align: center;">位布尔或</td></tr><tr class="even"><td style="text-align: center;">&amp;&amp;</td><td style="text-align: center;">逻辑和</td></tr><tr class="odd"><td style="text-align: center;">||</td><td style="text-align: center;">逻辑或</td></tr></tbody></table><p>可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。注意，<strong>不需要</strong>将双括号中表达式里的<strong>大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test23.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using double parenthesis</span><br><span class="hljs-comment">#</span><br>val1=10<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> (( <span class="hljs-variable">$val1</span> ** 2 &gt; 90 ))<br><span class="hljs-keyword">then</span><br>(( val2 = <span class="hljs-variable">$val1</span> ** 2 ))<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The square of <span class="hljs-variable">$val1</span> is <span class="hljs-variable">$val2</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test23.sh<br>The square of 10 is 100<br></code></pre></div></td></tr></table></figure><h5 id="使用双方括号">使用双方括号</h5><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式为：<code>[[ expression ]]</code>。</p><p>双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——<strong>模式匹配</strong>（pattern matching）。在模式匹配中，可以定义一个正则表达式（见后文）来匹配字符串值。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test24.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using pattern matching</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$USER</span> == r* ]]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, I do not know you&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test24.sh<br>Hello rich<br></code></pre></div></td></tr></table></figure><p>在上面的脚本中，我们使用了<strong>双等号（==）</strong>。双等号将右边的字符串（<code>r*</code>）视为一个模式，并应用模式匹配规则。双方括号命令<code>$USER</code>环境变量进行匹配，看它是否以字母<code>r</code>开头。如果是的话，比较通过，shell会执行then部分的命令。</p><h4 id="case-命令">case 命令</h4><p>有了case命令，就不需要再写出所有的elif语句来不停地检查同一个变量的值了。case命令会采用列表格式来检查单个变量的多个值。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> variable <span class="hljs-keyword">in</span><br>pattern1 | pattern2) commands1;;<br>pattern3) commands2;;<br>*) default commands;;<br><span class="hljs-keyword">esac</span><br></code></pre></div></td></tr></table></figure><p>case命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过<strong>竖线</strong>操作符在一行中分隔出<strong>多个模式</strong>模式。<strong>星号</strong>会捕获所有与已知模式<strong>不匹配</strong>的值。case命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。</p><h3 id="更多的结构化命令">更多的结构化命令</h3><h4 id="for-命令">for 命令</h4><p>bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash shell中for命令的基本格式。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>commands<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>在list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个值，以此类推，直到列表中的所有值都过一遍。在do和done语句之间输入的命令可以是一条或多条标准的bash shell命令。在这些命令中，$var变量包含着这次迭代对应的当前列表项中的值。</p><blockquote><p>只要你愿意，也可以将do语句和for语句放在同一行，但必须用分号将其同列表中的值分开：for var in list; do。</p></blockquote><h5 id="读取列表中的值">读取列表中的值</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1b<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the for variable after the looping</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The next state is <span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The last state we visited was <span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-built_in">test</span>=Connecticut<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Wait, now we&#x27;re visiting <span class="hljs-variable">$test</span>&quot;</span><br>$ ./test1b<br>The next state is Alabama<br>The next state is Alaska<br>The next state is Arizona<br>The next state is Arkansas<br>The next state is California<br>The next state is Colorado<br>The last state we visited was Colorado<br>Wait, now we<span class="hljs-string">&#x27;re visiting Connecticut</span><br><span class="hljs-string"># $test变量保持了其值，也允许我们修改它的值，并在for命令循环之外跟其他变量一样使用。</span><br></code></pre></div></td></tr></table></figure><h5 id="读取列表中的复杂值">读取列表中的复杂值</h5><p>shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> badtest1<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># another example of how not to use the for command</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> I don<span class="hljs-string">&#x27;t know if this&#x27;</span>ll work<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;word:<span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./badtest1<br>word:I<br>word:dont know <span class="hljs-keyword">if</span> thisll<br>word:work<br>$<br></code></pre></div></td></tr></table></figure><p>有两种办法可解决这个问题：</p><ul><li>使用转义字符（反斜线）来将单引号转义；</li><li>使用双引号来定义用到单引号的值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test2<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># another example of how not to use the for command</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> I don\<span class="hljs-string">&#x27;t know if &quot;this&#x27;</span>ll<span class="hljs-string">&quot; work</span><br><span class="hljs-string">do</span><br><span class="hljs-string">echo &quot;</span>word:<span class="hljs-variable">$test</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">done</span><br><span class="hljs-string">$ ./test2</span><br><span class="hljs-string">word:I</span><br><span class="hljs-string">word:don&#x27;t</span><br><span class="hljs-string">word:know</span><br><span class="hljs-string">word:if</span><br><span class="hljs-string">word:this&#x27;ll</span><br><span class="hljs-string">word:work</span><br></code></pre></div></td></tr></table></figure><p>如果在单独的数据值中有空格，就必须用双引号将这些值圈起来。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test3<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># an example of how to properly define values</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> Nevada <span class="hljs-string">&quot;New Hampshire&quot;</span> <span class="hljs-string">&quot;New Mexico&quot;</span> <span class="hljs-string">&quot;New York&quot;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Now going to <span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test3<br>Now going to Nevada<br>Now going to New Hampshire<br>Now going to New Mexico<br>Now going to New York<br></code></pre></div></td></tr></table></figure><h5 id="从变量读取列表">从变量读取列表</h5><p>通常shell脚本遇到的情况是，你将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表。也可以通过for命令完成这个任务。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using a variable to hold the list</span><br>list=<span class="hljs-string">&quot;Alabama Alaska Arizona Arkansas Colorado&quot;</span><br>list=<span class="hljs-variable">$list</span><span class="hljs-string">&quot; Connecticut&quot;</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> <span class="hljs-variable">$list</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Have you ever visited <span class="hljs-variable">$state</span>?&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test4<br>Have you ever visited Alabama?<br>Have you ever visited Alaska?<br>Have you ever visited Arizona?<br>Have you ever visited Arkansas?<br>Have you ever visited Colorado?<br>Have you ever visited Connecticut?<br></code></pre></div></td></tr></table></figure><p><code>$list</code>变量包含了用于迭代的标准文本值列表。注意，代码还是用了另一个赋值语句向<code>$list</code>变量包含的已有列表中添加（或者说是拼接）了一个值。这是向变量中存储的已有文本字符串尾部添加文本的一个常用方法。</p><h5 id="从命令读取值">从命令读取值</h5><p>生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># reading values from a file</span><br>file=<span class="hljs-string">&quot;states&quot;</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> <span class="hljs-variable">$file</span>)<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Visit beautiful <span class="hljs-variable">$state</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ <span class="hljs-built_in">cat</span> states<br>Alabama<br>Colorado<br>Connecticut<br>Delaware<br>Florida<br>...<br>$ ./test5<br>Visit beautiful Alabama<br>Visit beautiful Colorado<br>Visit beautiful Connecticut<br>Visit beautiful Delaware<br>Visit beautiful Florida<br>...<br></code></pre></div></td></tr></table></figure><p>这个例子在命令替换中使用了cat命令来输出文件states的内容。你会注意到states文件中每一行有一个州，而不是通过空格分隔的。for命令仍然以每次一行的方式遍历了cat命令的输出，假定每个州都是在单独的一行上。但这并没有解决数据中有空格的问题。如果你列出了一个名字中有空格的州，for命令仍然会将每个单词当作单独的值。这是有原因的，下一节我们将会了解。</p><h5 id="更改字段分隔符">更改字段分隔符</h5><p>造成上一节问题的原因是特殊的环境变量IFS，叫作内部字段分隔符（internal field separator）。IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p><ul><li>空格</li><li>制表符</li><li>换行符</li></ul><p>要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。例如，如果你想修改IFS的值，使其只能识别换行符，那就必须这么做：<code>IFS=$'\n'</code>。将这个语句加入到脚本中，告诉bash shell在数据值中忽略空格和制表符。对前一个脚本使用这种方法，将获得如下输出。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># reading values from a file</span><br>file=<span class="hljs-string">&quot;states&quot;</span><br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> <span class="hljs-variable">$file</span>)<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Visit beautiful <span class="hljs-variable">$state</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test5b<br>Visit beautiful Alabama<br>Visit beautiful Colorado<br>Visit beautiful Connecticut<br>Visit beautiful Delaware<br>Visit beautiful Florida<br>Visit beautiful New York<br>Visit beautiful New Hampshire<br>Visit beautiful North Carolina<br>...<br></code></pre></div></td></tr></table></figure><p>现在，shell脚本就能够使用列表中含有空格的值了。</p><div class="note note-info">            <p>在处理代码量较大的脚本时，可能在一个地方需要修改IFS的值，然后忽略这次修改，在脚本的其他地方继续沿用IFS的默认值。一个可参考的安全实践是在改变IFS之前保存原来的IFS值，之后再恢复它。 这种技术可以这样实现： <code>IFS.OLD=$IFS</code> <code>IFS=$'\n'</code> <在代码中使用新的IFS值> <code>IFS=$IFS.OLD</code> 这就保证了在脚本的后续操作中使用的是IFS的默认值。</p>          </div><p>还有其他一些IFS环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在/etc/passwd文件中）。你要做的就是将IFS的值设为冒号。 <code>IFS=:</code> 如果要指定多个IFS字符，只要将它们在赋值行串起来就行。 <code>IFS=$'\n':;"</code> 这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。</p><h5 id="用通配符读取目录">用通配符读取目录</h5><p>最后，可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。如果不知道所有的文件名，这个特性在处理目录中的文件时就非常好用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># iterate through all the files in a directory</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/test/*<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br><span class="hljs-keyword">elif</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br>$ ./test6<br>/home/rich/test/dir1 is a directory<br>/home/rich/test/myprog.c is a file<br>/home/rich/test/myprog is a file<br>/home/rich/test/myscript is a file<br>/home/rich/test/newdir is a directory<br>/home/rich/test/newfile is a file<br>/home/rich/test/newfile2 is a file<br>/home/rich/test/testdir is a directory<br>/home/rich/test/testing is a file<br>/home/rich/test/testprog is a file<br>/home/rich/test/testprog.c is a file<br></code></pre></div></td></tr></table></figure><p>注意，我们在这个例子的if语句中做了一些不同的处理：<code>if [ -d "$file" ]</code>。在Linux中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将<code>$file</code>变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./test6: line 6: [: too many arguments<br>./test6: line 9: [: too many arguments<br></code></pre></div></td></tr></table></figure><p>在test命令中，bash shell会将额外的单词当作参数，进而造成错误。</p><p>也可以在for命令中列出<strong>多个目录通配符</strong>，如：<code>for file in /home/rich/.b* /home/rich/badtest</code>，将目录查找和列表合并进同一个for语句。for语句首先使用了文件扩展匹配来遍历通配符生成的文件列表，然后它会遍历列表中的下一个文件。可以将任意多的通配符放进列表中。</p><h4 id="c-语言风格的for-命令">C 语言风格的for 命令</h4><p>以下是bash中C语言风格的for循环的基本格式：</p><p><code>for (( variable assignment ; condition ; iteration process ))</code></p><p>C语言风格的for循环的格式会让bash shell脚本程序员摸不着头脑，因为它使用了C语言风格的变量引用方式而不是shell风格的变量引用方式。C语言风格的for命令看起来如下。 <code>for (( a = 1; a &lt; 10; a++ ))</code> 注意，有些部分并没有遵循bash shell标准的for命令：</p><ul><li>变量赋值可以有空格；</li><li>条件中的变量不以美元符开头；</li><li>迭代过程的算式未用expr命令格式。</li></ul><p>C语言风格的for命令也允许为迭代使用<strong>多个变量</strong>。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你<strong>只能在for循环中定义一种条件</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test9<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># multiple variables</span><br><span class="hljs-keyword">for</span> (( a=1, b=10; a &lt;= 10; a++, b-- ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test9<br>1 - 10<br>2 - 9<br>3 - 8<br>4 - 7<br>5 - 6<br>6 - 5<br>7 - 4<br>8 - 3<br>9 - 2<br>10 - 1<br></code></pre></div></td></tr></table></figure><h4 id="while-命令">while 命令</h4><p>while命令某种意义上是if-then语句和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的一开始测试test命令。在test命令返回非零退出状态码时，while命令会停止执行那组命令。</p><p>while命令的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>other commands<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><p>while命令中定义的test command和if-then语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用test命令进行条件测试，比如测试变量值。最常见的test command的用法是用<strong>方括号</strong>来检查循环命令中用到的shell变量的值。</p><p>while命令允许你在while语句行定义<strong>多个测试命令</strong>。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。注意，每个测试命令都出现在<strong>单独的一行</strong>上。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test11<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing a multicommand while loop</span><br>var1=10<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>[ <span class="hljs-variable">$var1</span> -ge 0 ]<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is inside the loop&quot;</span><br>var1=$[ <span class="hljs-variable">$var1</span> - 1 ]<br><span class="hljs-keyword">done</span><br>$ ./test11<br>10<br>This is inside the loop<br>9<br>This is inside the loop<br>8<br>This is inside the loop<br>7<br>This is inside the loop<br>6<br>This is inside the loop<br>5<br>This is inside the loop<br>4<br>This is inside the loop<br>3<br>This is inside the loop<br>2<br>This is inside the loop<br>1<br>This is inside the loop<br>0<br>This is inside the loop<br>-1<br></code></pre></div></td></tr></table></figure><h4 id="until-命令">until 命令</h4><p>until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回<strong>非零退出状态码</strong>的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。和while命令类似，你可以在until命令语句中放入<strong>多个测试命令</strong>。只有<strong>最后一个</strong>命令的退出状态码决定了bash shell是否执行已定义的other commands。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">until <span class="hljs-built_in">test</span> commands<br><span class="hljs-keyword">do</span><br>other commands<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using the until command</span><br>var1=100<br>until <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>[ <span class="hljs-variable">$var1</span> -eq 0 ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> Inside the loop: <span class="hljs-variable">$var1</span><br>    var1=$[ <span class="hljs-variable">$var1</span> - 25 ]<br><span class="hljs-keyword">done</span><br>$ ./test13<br>100<br>Inside the loop: 100<br>75<br>Inside the loop: 75<br>50<br>Inside the loop: 50<br>25<br>Inside the loop: 25<br>0<br></code></pre></div></td></tr></table></figure><h4 id="嵌套循环">嵌套循环</h4><p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫作嵌套循环（nested loop）。注意，在使用嵌套循环时，你是在迭代中使用迭代，与命令运行的次数是乘积关系。不注意这点的话，有可能会在脚本中造成问题。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test14<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># nesting for loops</span><br><span class="hljs-keyword">for</span> (( a = 1; a &lt;= 3; a++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting loop <span class="hljs-variable">$a</span>:&quot;</span><br><span class="hljs-keyword">for</span> (( b = 1; b &lt;= 3; b++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Inside loop: <span class="hljs-variable">$b</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$ ./test14<br>Starting loop 1:<br>Inside loop: 1<br>Inside loop: 2<br>Inside loop: 3<br>Starting loop 2:<br>Inside loop: 1<br>Inside loop: 2<br>Inside loop: 3<br>Starting loop 3:<br>Inside loop: 1<br>Inside loop: 2<br>Inside loop: 3<br></code></pre></div></td></tr></table></figure><h4 id="控制循环">控制循环</h4><h5 id="break-命令">break 命令</h5><p>break命令是退出循环的一个简单方法。可以用break命令来退出任意类型的循环，包括while和until循环。</p><p><strong>跳出单个循环</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test18<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># breaking out of a while loop</span><br>var1=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$var1</span> -lt 10 ]<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$var1</span> -eq 5 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">break</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Iteration: <span class="hljs-variable">$var1</span>&quot;</span><br>var1=$[ <span class="hljs-variable">$var1</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The while loop is completed&quot;</span><br>$ ./test18<br>Iteration: 1<br>Iteration: 2<br>Iteration: 3<br>Iteration: 4<br>The <span class="hljs-keyword">while</span> loop is completed<br></code></pre></div></td></tr></table></figure><p><strong>跳出内部循环</strong> 在处理多个循环时，break命令会自动终止你所在的最内层的循环。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test19<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># breaking out of an inner loop</span><br><span class="hljs-keyword">for</span> (( a = 1; a &lt; 4; a++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Outer loop: <span class="hljs-variable">$a</span>&quot;</span><br><span class="hljs-keyword">for</span> (( b = 1; b &lt; 100; b++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$b</span> -eq 5 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">break</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Inner loop: <span class="hljs-variable">$b</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$ ./test19<br>Outer loop: 1<br>Inner loop: 1<br>Inner loop: 2<br>Inner loop: 3<br>Inner loop: 4<br>Outer loop: 2<br>Inner loop: 1<br>Inner loop: 2<br>Inner loop: 3<br>Inner loop: 4<br>Outer loop: 3<br>Inner loop: 1<br>Inner loop: 2<br>Inner loop: 3<br>Inner loop: 4<br></code></pre></div></td></tr></table></figure><p><strong>跳出外部循环</strong> 有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：</p><p><code>break n</code></p><p>其中n指定了要跳出的循环层级。<strong>默认情况下，n为1</strong>，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test20<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># breaking out of an outer loop</span><br><span class="hljs-keyword">for</span> (( a = 1; a &lt; 4; a++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Outer loop: <span class="hljs-variable">$a</span>&quot;</span><br><span class="hljs-keyword">for</span> (( b = 1; b &lt; 100; b++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$b</span> -gt 4 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">break</span> 2<br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Inner loop: <span class="hljs-variable">$b</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$ ./test20<br>Outer loop: 1<br>Inner loop: 1<br>Inner loop: 2<br>Inner loop: 3<br>Inner loop: 4<br></code></pre></div></td></tr></table></figure><h5 id="continue-命令">continue 命令</h5><p>continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。这里有个在for循环中使用continue命令的简单例子。</p><p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环： <code>continue n</code></p><p>其中n定义了要继续的循环层级。下面是继续外部for循环的一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test22<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># continuing an outer loop</span><br><span class="hljs-keyword">for</span> (( a = 1; a &lt;= 5; a++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Iteration <span class="hljs-variable">$a</span>:&quot;</span><br><span class="hljs-keyword">for</span> (( b = 1; b &lt; 3; b++ ))<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -gt 2 ] &amp;&amp; [ <span class="hljs-variable">$a</span> -lt 4 ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">continue</span> 2<br><span class="hljs-keyword">fi</span><br>var3=$[ <span class="hljs-variable">$a</span> * <span class="hljs-variable">$b</span> ]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; The result of <span class="hljs-variable">$a</span> * <span class="hljs-variable">$b</span> is <span class="hljs-variable">$var3</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$ ./test22<br>Iteration 1:<br>The result of 1 * 1 is 1<br>The result of 1 * 2 is 2<br>Iteration 2:<br>The result of 2 * 1 is 2<br>The result of 2 * 2 is 4<br>Iteration 3:<br>Iteration 4:<br>The result of 4 * 1 is 4<br>The result of 4 * 2 is 8<br>Iteration 5:<br>The result of 5 * 1 is 5<br>The result of 5 * 2 is 10<br></code></pre></div></td></tr></table></figure><p>此处用continue命令来停止处理循环内的命令，但会继续处理外部循环。注意，值为3的那次迭代并没有处理任何内部循环语句，因为尽管continue命令停止了处理过程，但外部循环依然会继续。</p><h4 id="处理循环的输出">处理循环的输出</h4><p>最后，在shell脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在done命令之后添加一个处理命令来实现。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br><span class="hljs-keyword">elif</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br></code></pre></div></td></tr></table></figure><p>shell会将for命令的结果重定向到文件output.txt中，而不是显示在屏幕上。</p><p>这种方法同样适用于将循环的结果管接给另一个命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test24<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># piping a loop to another command</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;North Dakota&quot;</span> Connecticut Illinois Alabama Tennessee<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$state</span> is the next place to go&quot;</span><br><span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This completes our travels&quot;</span><br>$ ./test24<br>Alabama is the next place to go<br>Connecticut is the next place to go<br>Illinois is the next place to go<br>North Dakota is the next place to go<br>Tennessee is the next place to go<br>This completes our travels<br></code></pre></div></td></tr></table></figure><h3 id="处理用户输入">处理用户输入</h3><h4 id="命令行参数">命令行参数</h4><p>向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。例如：<code>$ ./addem 10 30</code>。</p><h5 id="读取参数">读取参数</h5><p>bash shell会将一些称为<strong>位置参数</strong>（positional parameter）的特殊变量分配给输入到命令行中的所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字：<code>$0</code>是<strong>程序名</strong>，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，依次类推，直到第九个参数<code>$9</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># using one command line parameter</span><br><span class="hljs-comment">#</span><br>factorial=1<br><span class="hljs-keyword">for</span> (( number = 1; number &lt;= <span class="hljs-variable">$1</span> ; number++ ))<br><span class="hljs-keyword">do</span><br>factorial=$[ <span class="hljs-variable">$factorial</span> * <span class="hljs-variable">$number</span> ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> The factorial of <span class="hljs-variable">$1</span> is <span class="hljs-variable">$factorial</span><br>$<br>$ ./test1.sh 5<br>The factorial of 5 is 120<br></code></pre></div></td></tr></table></figure><p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开。也可以在命令行上用<strong>文本字符串</strong>，但碰到含有空格的文本字符串时就会出现问题，记住，每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。</p><p>如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上<strong>花括号</strong>，比如<code>$&#123;10&#125;</code>。下面是一个这样的例子。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># handling lots of parameters</span><br><span class="hljs-comment">#</span><br>total=$[ <span class="hljs-variable">$&#123;10&#125;</span> * <span class="hljs-variable">$&#123;11&#125;</span> ]<br><span class="hljs-built_in">echo</span> The tenth parameter is <span class="hljs-variable">$&#123;10&#125;</span><br><span class="hljs-built_in">echo</span> The eleventh parameter is <span class="hljs-variable">$&#123;11&#125;</span><br><span class="hljs-built_in">echo</span> The total is <span class="hljs-variable">$total</span><br>$<br>$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12<br>The tenth parameter is 10<br>The eleventh parameter is 11<br>The total is 110<br></code></pre></div></td></tr></table></figure><h5 id="读取脚本名">读取脚本名</h5><p>可以用<code>$0</code>参数获取shell在命令行启动的<strong>脚本名</strong>。这在编写多功能工具时很方便。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Testing the $0 parameter</span><br><span class="hljs-built_in">echo</span> The zero parameter is <span class="hljs-built_in">set</span> to: <span class="hljs-variable">$0</span><br>$<br>$ bash test5.sh<br>The zero parameter is <span class="hljs-built_in">set</span> to: test5.sh<br><span class="hljs-comment"># 通过以下两种命令执行脚本会出现问题：返回值包含命令的路径</span><br>$ ./test5.sh<br>The zero parameter is <span class="hljs-built_in">set</span> to: ./test5.sh<br>$ bash /home/Christine/test5.sh<br>The zero parameter is <span class="hljs-built_in">set</span> to: /home/Christine/test5.sh<br></code></pre></div></td></tr></table></figure><p><code>basename</code>命令会返回不包含路径的脚本名。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Using basename with the $0 parameter</span><br>name=$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$0</span>)<br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> The script name is: <span class="hljs-variable">$name</span><br>$ bash /home/Christine/test5b.sh<br>The script name is: test5b.sh<br>$<br>$ ./test5b.sh<br>The script name is: test5b.sh<br></code></pre></div></td></tr></table></figure><h5 id="测试参数">测试参数</h5><p>在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test7.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing parameters before use</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> Hello <span class="hljs-variable">$1</span>, glad to meet you.<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, you did not identify yourself. &quot;</span><br><span class="hljs-keyword">fi</span><br>$ ./test7.sh Rich<br>Hello Rich, glad to meet you.<br>$ ./test7.sh<br>Sorry, you did not identify yourself.<br></code></pre></div></td></tr></table></figure><h4 id="特殊参数变量">特殊参数变量</h4><h5 id="参数统计">参数统计</h5><p>特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p><p>这个变量还提供了一个简便方法来获取命令行中<strong>最后一个参数</strong>，完全不需要知道实际上到底用了多少个参数。</p><p>如果你仔细考虑过，可能会觉得既然<code>$#</code>变量含有参数的总数，那么变量<code>$&#123;$#&#125;</code>就代表了最后一个命令行参数变量。试试看会发生什么。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> badtest1.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing grabbing last parameter</span><br><span class="hljs-built_in">echo</span> The last parameter was <span class="hljs-variable">$&#123;$#&#125;</span><br>$ ./badtest1.sh 10<br>The last parameter was 15354<br></code></pre></div></td></tr></table></figure><p>它表明你<strong>不能在花括号内使用美元符</strong>。必须将美元符换成感叹号。很奇怪，但的确管用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Grabbing the last parameter</span><br>params=<span class="hljs-variable">$#</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> The last parameter is <span class="hljs-variable">$params</span><br><span class="hljs-built_in">echo</span> The last parameter is <span class="hljs-variable">$&#123;!#&#125;</span><br><span class="hljs-built_in">echo</span><br>$ bash test10.sh 1 2 3 4 5<br>The last parameter is 5<br>The last parameter is 5<br>$ bash test10.sh<br>The last parameter is 0<br>The last parameter is test10.sh<br></code></pre></div></td></tr></table></figure><h5 id="抓取所有的数据">抓取所有的数据</h5><p><strong>$*</strong> 和**$<span class="citation" data-cites="*">@*</span>* 变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</p><p><strong>$*</strong> 变量会将命令行上提供的所有参数当作<strong>一个</strong>单词保存。这个单词包含了命令行中出现的每一个参数值。基本上<strong>$*</strong> 变量会将这些参数视为一个整体，而不是多个个体。 另一方面，<strong>$<span class="citation" data-cites="*">@*</span>* 变量会将命令行上提供的所有参数当作同一字符串中的</strong>多个**独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过<code>for</code>命令完成。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing $* and $@</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\$* Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$param</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\$@ Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$param</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br>$ ./test12.sh rich barbara katie jessica<br><br>$* Parameter <span class="hljs-comment">#1 = rich barbara katie jessica</span><br><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#1 = rich</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#2 = barbara</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#3 = katie</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#4 = jessica</span><br></code></pre></div></td></tr></table></figure><h4 id="移动变量">移动变量</h4><p>bash shell工具箱中另一件工具是<strong>shift命令</strong>。bash shell的shift命令能够用来操作命令行参数。跟字面上的意思一样，shift命令会根据它们的相对位置来移动命令行参数。</p><p>在使用shift命令时，默认情况下它会将每个参数变量<strong>向左移动</strong>一个位置。所以，变量<code>$3</code>的值会移到<code>$2</code>中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值，也就是程序名，不会改变）。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># demonstrating the shift command</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$1</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br>$ ./test13.sh rich barbara katie jessica<br>Parameter <span class="hljs-comment">#1 = rich</span><br>Parameter <span class="hljs-comment">#2 = barbara</span><br>Parameter <span class="hljs-comment">#3 = katie</span><br>Parameter <span class="hljs-comment">#4 = jessica</span><br></code></pre></div></td></tr></table></figure><p>使用shift命令的时候要小心。如果某个参数被移出，它的值就被丢弃了，无法再恢复。另外，你也可以<strong>一次性移动多个</strong>位置，只需要给shift命令<strong>提供一个参数</strong>，指明要移动的位置数就行了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test14.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># demonstrating a multi-position shift</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original parameters: $*&quot;</span><br><span class="hljs-built_in">shift</span> 2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Here&#x27;s the new first parameter: <span class="hljs-variable">$1</span>&quot;</span><br>$ ./test14.sh 1 2 3 4 5<br>The original parameters: 1 2 3 4 5<br>Here<span class="hljs-string">&#x27;s the new first parameter: 3</span><br></code></pre></div></td></tr></table></figure><h4 id="处理选项">处理选项</h4><h5 id="查找选项">查找选项</h5><p><strong>处理简单选项</strong></p><p>在提取每个单独参数时，用case语句来判断某个参数是否为选项。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test15.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options as parameters</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>    -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;;<br>    -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span> ;;<br>    -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>    *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span> ;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br>$ ./test15.sh -a -b -c -d<br>Found the -a option<br>Found the -b option<br>Found the -c option<br>-d is not an option<br></code></pre></div></td></tr></table></figure><p><strong>分离参数和选项</strong></p><p>你会经常遇到想在shell脚本中<strong>同时使用选项和参数</strong>的情况。Linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p><p>对Linux来说，这个特殊字符是<strong>双破折线（--）</strong>。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了。要检查双破折线，只要在case语句中加一项就行了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test16.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting options and parameters</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>    -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;;<br>    -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span>;;<br>    -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>    --) <span class="hljs-built_in">shift</span><br>    <span class="hljs-built_in">break</span> ;;<br>*) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$param</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 对于第一个测试，试试用一组普通的选项和参数来运行这个脚本，测试结果1：</span><br>$ ./test16.sh -c -a -b test1 test2 test3<br>Found the -c option<br>Found the -a option<br>Found the -b option<br>test1 is not an option<br>test2 is not an option<br>test3 is not an option<br><span class="hljs-comment"># 结果说明在处理时脚本认为所有的命令行参数都是选项。</span><br><span class="hljs-comment"># 用双破折线来将命令行上的选项和参数划分开来，测试结果2：</span><br>$ ./test16.sh -c -a -b -- test1 test2 test3<br>Found the -c option<br>Found the -a option<br>Found the -b option<br>Parameter <span class="hljs-comment">#1: test1</span><br>Parameter <span class="hljs-comment">#2: test2</span><br>Parameter <span class="hljs-comment">#3: test3</span><br><span class="hljs-comment"># 当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</span><br></code></pre></div></td></tr></table></figure><p>上述代码在遇到双破折线时，脚本用break命令来跳出while循环。由于过早地跳出了循环，我们需要再加一条shift命令来将双破折线移出参数变量。</p><p><strong>处理带值的选项</strong></p><p>有些选项会带上一个额外的参数值。在这种情况下，命令行看起来像下面这样。</p><p><code>$ ./testing.sh -a test1 -b -c -d test2</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test17.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options and values</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span>;;<br>        -b) param=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option, with parameter value <span class="hljs-variable">$param</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> ;;<br>-c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span>;;<br>--) <span class="hljs-built_in">shift</span><br><span class="hljs-built_in">break</span> ;;<br>*) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br>count=1<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$param</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br>$<br>$ ./test17.sh -a -b test1 -d<br>Found the -a option<br>Found the -b option, with parameter value test1<br>-d is not an option<br></code></pre></div></td></tr></table></figure><p>在这个例子中，case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>（因为所有的参数在处理完之后都会被移出）。只要将参数值从<code>$2</code>变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。</p><h4 id="获得用户输入">获得用户输入</h4><h5 id="基本的读取">基本的读取</h5><p><strong>read命令</strong>从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。read命令包含了<strong>-p选项</strong>（可选），允许你直接在read命令行<strong>指定提示符</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test22.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing the read -p option</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter your age: &quot;</span> age<br>days=$[ <span class="hljs-variable">$age</span> * 365 ]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;That makes you over <span class="hljs-variable">$days</span> days old! &quot;</span><br><span class="hljs-comment">#</span><br>$<br>$ ./test22.sh<br>Please enter your age: 10<br>That makes you over 3650 days old!<br></code></pre></div></td></tr></table></figure><p>read命令会将提示符后输入的所有数据分配给<strong>单个变量</strong>，要么你就<strong>指定多个变量</strong>。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test23.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># entering multiple variables</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter your name: &quot;</span> first last<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Checking data for <span class="hljs-variable">$last</span>, <span class="hljs-variable">$first</span>…&quot;</span><br>$ ./test23.sh<br>Enter your name: Rich Blum<br>Checking data <span class="hljs-keyword">for</span> Blum, Rich...<br></code></pre></div></td></tr></table></figure><p>也可以在read命令行中<strong>不指定变量</strong>。如果是这样，read命令会将它收到的任何数据都放进特殊<strong>环境变量REPLY</strong>中。REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test24.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Testing the REPLY Environment variable</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter your name: &quot;</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> Hello <span class="hljs-variable">$REPLY</span>, welcome to my program.<br>$ ./test24.sh<br>Enter your name: Christine<br>Hello Christine, welcome to my program.<br></code></pre></div></td></tr></table></figure><h5 id="超时">超时</h5><p>使用read命令时要当心。脚本很可能会一直苦等着脚本用户的输入。如果不管是否有数据输入，脚本都必须继续执行，你可以用<strong>-t选项</strong>来指定一个计时器。-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test25.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># timing the data entry</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">read</span> -t 5 -p <span class="hljs-string">&quot;Please enter your name: &quot;</span> name<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>, welcome to my script&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, too slow! &quot;</span><br><span class="hljs-keyword">fi</span><br>$<br>$ ./test25.sh<br>Please enter your name: Rich<br>Hello Rich, welcome to my script<br>$ ./test25.sh<br>Please enter your name:<br>Sorry, too slow!<br></code></pre></div></td></tr></table></figure><p>也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test26.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># getting just one character of input</span><br><span class="hljs-built_in">read</span> -n1 -p <span class="hljs-string">&quot;Do you want to continue [Y/N]? &quot;</span> answer<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$answer</span> <span class="hljs-keyword">in</span><br>Y | y) <span class="hljs-built_in">echo</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;fine, continue on…&quot;</span>;;<br>N | n) <span class="hljs-built_in">echo</span><br>   <span class="hljs-built_in">echo</span> OK, goodbye<br>   <span class="hljs-built_in">exit</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the end of the script&quot;</span><br>$ ./test26.sh<br>Do you want to <span class="hljs-built_in">continue</span> [Y/N]? Y<br>fine, <span class="hljs-built_in">continue</span> on…<br>This is the end of the script<br>$ ./test26.sh<br>Do you want to <span class="hljs-built_in">continue</span> [Y/N]? n<br>OK, goodbye<br></code></pre></div></td></tr></table></figure><p>本例中将<strong>-n选项</strong>和<strong>值1</strong>一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。</p><h5 id="隐藏方式读取">隐藏方式读取</h5><p>有时你需要从脚本用户处得到输入，但又在屏幕上显示输入信息。其中典型的例子就是输入的密码，但除此之外还有很多其他需要隐藏的数据类型。<strong>-s选项</strong>可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。</p><h5 id="从文件中读取">从文件中读取</h5><p>最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。</p><p>其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test28.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># reading data from a file</span><br><span class="hljs-comment">#</span><br>count=1<br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line <span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>count=$[ <span class="hljs-variable">$count</span> + 1]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Finished processing the file&quot;</span><br>$ <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span><br>The quick brown dog jumps over the lazy fox.<br>This is a <span class="hljs-built_in">test</span>, this is only a <span class="hljs-built_in">test</span>.<br>O Romeo, Romeo! Wherefore art thou Romeo?<br>$ ./test28.sh<br>Line 1: The quick brown dog jumps over the lazy fox.<br>Line 2: This is a <span class="hljs-built_in">test</span>, this is only a <span class="hljs-built_in">test</span>.<br>Line 3: O Romeo, Romeo! Wherefore art thou Romeo?<br>Finished processing the file<br></code></pre></div></td></tr></table></figure><h3 id="呈现数据">呈现数据</h3><h4 id="理解输入和输出">理解输入和输出</h4><h5 id="标准文件描述符">标准文件描述符</h5><p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用<strong>文件描述符</strong>（filedescriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（0、1和2）。</p><table><thead><tr class="header"><th style="text-align: center;">文件描述符</th><th style="text-align: center;">缩写</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">STDIN</td><td style="text-align: center;">标准输入</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">STDOUT</td><td style="text-align: center;">标准输出</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">STDERR</td><td style="text-align: center;">标准错误</td></tr></tbody></table><p>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</p><p><strong>1. STDIN</strong></p><p>STDIN文件描述符代表shell的<strong>标准输入</strong>。对终端界面来说，标准输入是<strong>键盘</strong>。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p><p>在使用<strong>输入重定向符号</strong>（&lt;）时，Linux会用重定向指定的<strong>文件</strong>来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 当在命令行上只输入cat命令时，它会从STDIN接受输入。</span><br>$ <span class="hljs-built_in">cat</span><br>this is a <span class="hljs-built_in">test</span><br>this is a <span class="hljs-built_in">test</span><br>this is a second <span class="hljs-built_in">test</span>.<br>this is a second <span class="hljs-built_in">test</span>.<br><span class="hljs-comment"># 也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入</span><br>$ <span class="hljs-built_in">cat</span> &lt; testfile<br>This is the first line.<br>This is the second line.<br>This is the third line.<br></code></pre></div></td></tr></table></figure><p><strong>2. STDOUT</strong> STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到<strong>标准输出</strong>中，也就是<strong>显示器</strong>。 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，你可以用输出重定向来改变。</p><p>你也可以将数据<strong>追加</strong>到某个文件。这可以用<strong>&gt;&gt;符号</strong>来完成。</p><p>当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al badfile &gt; test3<br><span class="hljs-built_in">ls</span>: cannot access badfile: No such file or directory<br>$ <span class="hljs-built_in">cat</span> test3<br></code></pre></div></td></tr></table></figure><p>shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。</p><p><strong>3. STDERR</strong> shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。 默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p><h5 id="重定向错误">重定向错误</h5><p><strong>只重定向错误</strong></p><p>可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值<strong>必须紧紧地放在重定向符号前</strong>，否则不会工作。以下示例中的命令生成的任何错误消息都会保存在输出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al badfile 2&gt; test4<br>$ <span class="hljs-built_in">cat</span> test4<br><span class="hljs-built_in">ls</span>: cannot access badfile: No such file or directory<br></code></pre></div></td></tr></table></figure><p><strong>重定向错误和数据</strong></p><p>如果想重定向错误和正常输出，必须用<strong>两个</strong>重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badtest 2&gt; test6 1&gt; test7<br>$ <span class="hljs-built_in">cat</span> test6<br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-built_in">test</span>: No such file or directory<br><span class="hljs-built_in">ls</span>: cannot access badtest: No such file or directory<br>$ <span class="hljs-built_in">cat</span> test7<br>-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2<br>-rw-rw-r-- 1 rich rich 0 2014-10-16 11:33 test3<br></code></pre></div></td></tr></table></figure><p>可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息，再不用在成千上万行正常输出数据中翻腾了。 另外，如果愿意，也可以将STDERR和STDOUT的输出重定向到<strong>同一个输出文件</strong>。为此bash shell提供了特殊的重定向符号<code>&amp;&gt;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badtest &amp;&gt; test7<br>$ <span class="hljs-built_in">cat</span> test7<br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-built_in">test</span>: No such file or directory<br><span class="hljs-built_in">ls</span>: cannot access badtest: No such file or directory<br>-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2<br>-rw-rw-r-- 1 rich rich 0 2014-10-16 11:33 test3<br></code></pre></div></td></tr></table></figure><p>当使用<code>&amp;&gt;</code>符时，命令生成的所有输出都会发送到同一位置，包括数据和错误。你会注意到其中一条错误消息出现的位置和预想中的不一样。badtest文件（列出的最后一个文件）的这条错误消息出现在输出文件中的第二行。为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。这样你能够集中浏览错误信息了。</p><h4 id="在脚本中重定向输出">在脚本中重定向输出</h4><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。</p><h5 id="临时重定向">临时重定向</h5><p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个<strong>&amp;</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test8<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing STDERR messages</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an error&quot;</span> &gt;&amp;2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is normal output&quot;</span><br><br><span class="hljs-comment"># 默认情况下，Linux会将STDERR导向STDOUT</span><br>$ ./test8<br>This is an error<br>This is normal output<br><span class="hljs-comment"># 如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向</span><br>$ ./test8 2&gt; test9<br>This is normal output<br>$ <span class="hljs-built_in">cat</span> test9<br>This is an error<br></code></pre></div></td></tr></table></figure><h5 id="永久重定向">永久重定向</h5><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用<strong>exec命令</strong>告诉shell在脚本执行期间重定向某个特定文件描述符。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test11<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># redirecting output to different locations</span><br><span class="hljs-built_in">exec</span> 2&gt;testerror<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the start of the script&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;now redirecting all output to another location&quot;</span><br><span class="hljs-built_in">exec</span> 1&gt;testout<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This output should go to the testout file&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;but this should go to the testerror file&quot;</span> &gt;&amp;2<br>$<br>$ ./test11<br>This is the start of the script<br>now redirecting all output to another location<br>$ <span class="hljs-built_in">cat</span> testout<br>This output should go to the testout file<br>$ <span class="hljs-built_in">cat</span> testerror<br>but this should go to the testerror file<br></code></pre></div></td></tr></table></figure><h3 id="控制脚本">控制脚本</h3><h4 id="以后台模式运行脚本">以后台模式运行脚本</h4><p>在用ps命令时，会看到运行在Linux系统上的一系列不同进程。显然，所有这些进程都不是运行在你的终端显示器上的。这样的现象被称为在后台（background）运行进程。在后台模式中，进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联。</p><h5 id="后台运行脚本">后台运行脚本</h5><p>以后台模式运行shell脚本非常简单。只要在命令后加个 <strong>&amp;</strong> 符就行了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Test running in the background</span><br>count=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 10 ]<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">sleep</span> 1<br>count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br>$ ./test4.sh &amp;<br>[1] 3231<br></code></pre></div></td></tr></table></figure><p>当&amp;符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。显示的第一行是：</p><p><code>[1] 3231</code></p><p>方括号中的数字是shell分配给后台进程的作业号。下一个数是Linux系统分配给进程的进程ID（PID）。Linux系统上运行的每个进程都必须有一个唯一的PID。 一旦系统显示了这些内容，新的命令行界面提示符就出现了。你可以回到shell，而你所执行的命令正在以后台模式安全的运行。这时，你可以在提示符输入新的命令。</p><p>当后台进程结束时，它会在终端上显示出一条消息：</p><p><code>[1] Done ./test4.sh</code></p><p>这表明了作业的作业号以及作业状态（Done），还有用于启动作业的命令。 注意，当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./test5.sh &amp;<br>[1] 3319<br>$ Start the <span class="hljs-built_in">test</span> script<br>Loop <span class="hljs-comment">#1</span><br>Loop <span class="hljs-comment">#2</span><br>Loop <span class="hljs-comment">#3</span><br><span class="hljs-built_in">ls</span> myprog*<br>myprog myprog.c<br>$ Loop <span class="hljs-comment">#4</span><br>Loop <span class="hljs-comment">#5</span><br>Test script is complete<br>[1]+ Done ./test5.sh<br></code></pre></div></td></tr></table></figure><p>当脚本test5.sh运行在后台模式时，我们输入了命令<code>ls myprog*</code>。脚本输出、输入的命令以及命令输出全都混在了一起。最好是将后台运行的脚本的STDOUT和STDERR进行重定向，避免这种杂乱的输出。</p><h5 id="运行多个后台作业">运行多个后台作业</h5><p>可以在命令行提示符下同时启动多个后台作业。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./test6.sh &amp;<br>[1] 3568<br>$ This is Test Script <span class="hljs-comment">#1</span><br>$ ./test7.sh &amp;<br>[2] 3570<br>$ This is Test Script <span class="hljs-comment">#2</span><br>$ ./test8.sh &amp;<br>[3] 3573<br>$ And...another Test script<br>$ ./test9.sh &amp;<br>[4] 3576<br>$ Then...there was one more <span class="hljs-built_in">test</span> script<br><br>$ ps<br>PID TTY TIME CMD<br>2431 pts/0 00:00:00 bash<br>3568 pts/0 00:00:00 test6.sh<br>3570 pts/0 00:00:00 test7.sh<br>3573 pts/0 00:00:00 test8.sh<br>3574 pts/0 00:00:00 <span class="hljs-built_in">sleep</span><br>3575 pts/0 00:00:00 <span class="hljs-built_in">sleep</span><br>3576 pts/0 00:00:00 test9.sh<br>3577 pts/0 00:00:00 <span class="hljs-built_in">sleep</span><br>3578 pts/0 00:00:00 <span class="hljs-built_in">sleep</span><br>3579 pts/0 00:00:00 ps<br></code></pre></div></td></tr></table></figure><p>每次启动新作业时，Linux系统都会为其分配一个新的作业号和PID。通过ps命令，可以看到所有脚本处于运行状态。</p><h4 id="定时运行作业">定时运行作业</h4><h5 id="用at-命令来计划执行作业">用at 命令来计划执行作业</h5><p>at命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。</p><p>atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。</p><p><strong>at命令的格式</strong></p><p>at命令的基本格式非常简单：<code>at [-f filename] time</code></p><p>默认情况下，at命令会将STDIN的输入放到队列中，可以用<strong>-f参数</strong>来指定用于读取命令（脚本文件）的<strong>文件</strong>名。<strong>time参数</strong>指定了Linux系统<strong>何时</strong>运行该作业。如果你指定的时间已经错过，at命令会在<strong>第二天</strong>的那个时间运行指定的作业。</p><p>at命令能识别多种不同的时间格式：</p><ul><li><p>标准的小时和分钟格式，比如10:15。</p></li><li><p>AM/PM指示符，比如10:15 PM。</p></li><li><p>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。</p></li></ul><p>除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</p><ul><li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。</li><li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li><li>你也可以指定时间增量。<ul><li>当前时间+25 min</li><li>明天10:15 PM</li><li>10:15+7天</li></ul></li></ul><p>在你使用at命令时，该作业会被提交到<strong>作业队列</strong>（job queue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母<code>a~z</code>和大写字母<code>A~Z</code>来指代。</p><p>作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。</p><p><strong>获取作业的输出</strong></p><p>当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户。</p><p>使用e-mail作为at命令的输出极其不便。at命令利用sendmail应用程序来发送邮件。如果你的系统中没有安装sendmail，那就无法获得任何输出！因此在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向，如下例所示。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13b.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># Test using at command</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This script ran at <span class="hljs-subst">$(date +%B%d,%T)</span>&quot;</span> &gt; test13b.out<br><span class="hljs-built_in">echo</span> &gt;&gt; test13b.out<br><span class="hljs-built_in">sleep</span> 5<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the script&#x27;s end...&quot;</span> &gt;&gt; test13b.out<br><span class="hljs-comment">#</span><br>$<br>$ at -M -f test13b.sh now<br>job 8 at 2015-07-14 12:48<br>$<br>$ <span class="hljs-built_in">cat</span> test13b.out<br>This script ran at July14,12:48:18<br>This is the script<span class="hljs-string">&#x27;s end...</span><br></code></pre></div></td></tr></table></figure><p>如果不想在at命令中使用邮件或重定向，最好加上<strong>-M选项</strong>来屏蔽作业产生的输出信息。</p><p><strong>列出等待的作业</strong> <strong>atq命令</strong>可以查看系统中有哪些作业在等待。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ at -M -f test13b.sh teatime<br>job 17 at 2015-07-14 16:00<br>$<br>$ at -M -f test13b.sh tomorrow<br>job 18 at 2015-07-15 13:03<br>$<br>$ at -M -f test13b.sh 13:30<br>job 19 at 2015-07-14 13:30<br>$<br>$ at -M -f test13b.sh now<br>job 20 at 2015-07-14 13:03<br>$<br>$ atq<br>20 2015-07-14 13:03 = Christine<br>18 2015-07-15 13:03 a Christine<br>17 2015-07-14 16:00 a Christine<br>19 2015-07-14 13:30 a Christine<br></code></pre></div></td></tr></table></figure><p>作业列表中显示了作业号、系统运行该作业的日期和时间及其所在的作业队列。</p><p><strong>删除作业</strong> 一旦知道了哪些作业在作业队列中等待，就能用<strong>atrm命令</strong>来删除等待中的作业。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ atq<br>18 2015-07-15 13:03 a Christine<br>17 2015-07-14 16:00 a Christine<br>19 2015-07-14 13:30 a Christine<br>$<br>$ atrm 18<br>$<br>$ atq<br>17 2015-07-14 16:00 a Christine<br>19 2015-07-14 13:30 a Christine<br></code></pre></div></td></tr></table></figure><h4 id="安排需要定期执行的脚本">安排需要定期执行的脚本</h4><p>Linux系统使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作<strong>cron时间表</strong>），以获知已安排执行的作业。</p><h5 id="cron时间表">cron时间表</h5><p>cron时间表采用一种特别的格式来指定作业何时运行。其格式如下： <code>min hour dayofmonth month dayofweek command</code> cron时间表允许你用特定值、取值范围（比如1~5）或者是<strong>通配符（星号）</strong>来指定条目。例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：<code>15 10 * * * command</code>。</p><p>可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定<code>dayofweek</code>表项。</p><div class="note note-success">            <p>关于如何设置一个在每个月的最后一天执行的命令？由于无法设置<code>dayofmonth</code>的值来涵盖所有的月份，这个问题困扰着Linux和Unix程序员，也激发了不少解决办法。常用的方法是加一条使用<code>date</code>命令的<code>if-then</code>语句来检查明天的日期是不是<code>01</code>： 00 12 * * * if [<code>date +%d -d tomorrow = 01</code> ] ; then ; command 它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>          </div><p>命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号。 <code>15 10 * * * /home/rich/test4.sh &gt; test4out</code> cron程序会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的输出文件的权限。</p><p><strong>构建cron时间表</strong> 每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了<strong>crontab命令</strong>来处理cron时间表。要列出已有的cron时间表，可以用<strong>-l选项</strong>。</p><p>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用<strong>-e选项</strong>。在添加条目时，crontab命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容（或者是一个空文件，如果时间表不存在的话）。</p><p><strong>浏览cron目录</strong> 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly。因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/cron.*ly<br>/etc/cron.daily:<br>cups makewhatis.cron prelink tmpwatch<br>logrotate mlocate.cron readahead.cron<br>/etc/cron.hourly:<br>0anacron<br>/etc/cron.monthly:<br>readahead-monthly.cron<br>/etc/cron.weekly:<br></code></pre></div></td></tr></table></figure><h3 id="参考资料">参考资料</h3><ul><li>Linux命令行与Shell脚本编程大全（第3版）</li><li><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程|菜鸟教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识</title>
    <link href="/Linux/Base/"/>
    <url>/Linux/Base/</url>
    
    <content type="html"><![CDATA[<h2 id="linux常用命令">Linux常用命令</h2><h3 id="文件管理">文件管理</h3><p><code>ctrl c</code>：取消命令，并且换行 <code>ctrl u</code>：清空本行命令 <code>tab</code>：可以补全命令和文件名 如果补全不了快速按两下tab键，可以显示备选选项 <code>ls</code>：列出当前目录下所有文件</p><ul><li><p>蓝色的是文件夹</p></li><li><p>白色的是普通文件</p></li><li><p>绿色的是可执行文件</p></li></ul><p><code>pwd</code>：显示当前路径 <code>cd XXX</code>：进入 <code>XXX</code>目录下 <code>cd ..</code>： 返回上层目录 <code>cp XXX YYY</code>： 将<code>XXX</code> 文件复制成 <code>YYY</code>，<code>XXX</code>和 <code>YYY</code>可以是一个路径，比如<code>../dir_c/a.txt</code>，表示上层目录下的 <code>dir_c</code>文件夹下的文件<code>a.txt</code> <code>mkdir XXX</code>：创建目录<code>XXX</code> <code>rm XXX</code>：删除普通文件 <code>rm XXX -r</code>：删除文件夹 <code>mv XXX YYY</code>：将 <code>XXX</code>文件移动到<code>YYY</code> 和<code>cp</code>命令一样，<code>XXX</code>和<code>YYY</code>可以是一个路径 重命名也是用这个命令 <code>touch XXX</code>： 创建一个文件 <code>cat XXX</code>： 展示文件 XXX 中的内容 复制文本 windows/Linux 下：<code>Ctrl + insert</code> Mac 下：<code>command + c</code> 粘贴文本 windows/Linux 下：<code>Shift + insert</code> Mac 下：<code>command + v</code></p><h3 id="性能监控">性能监控</h3><p>参考文章：</p><ul><li><a href="https://jeremyxu2010.github.io/2019/12/60%E7%A7%92%E5%AE%8C%E6%88%90linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E8%AF%91/">60秒完成Linux系统的性能分析(译)</a></li><li><a href="https://blog.51cto.com/quantfabric/2593644">Linux性能优化（三）——sysstat性能监控工具</a></li></ul><h4 id="常用命令汇总">常用命令汇总</h4><p>一个性能诊断过程的前60秒内，可以通过运行以下十个命令来了解有关系统资源使用和运行进程的信息。其中的一些命令需要安装<code>sysstat</code>软件包。这些命令暴露出的指标将帮助您完成一些USE方法：一种查找性能瓶颈的方法。它们涉及检查所有资源（CPU、内存、磁盘等）的利用率，饱和度和错误指标。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">uptime<br>dmesg | tail<br>vmstat 1<br>mpstat -P ALL 1<br>pidstat 1<br>iostat -xz 1<br>free -m<br>sar -n DEV 1<br>sar -n TCP,ETCP 1<br>top<br></code></pre></div></td></tr></table></figure><p><strong>sysstat简介</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sysstat提供了Linux性能监控工具集，包括sar、sadf、mpstat、iostat、pidstat等，用于监控Linux系统性能和使用情况。<br>iostat - 提供CPU统计，存储I/O统计（磁盘设备，分区及网络文件系统）<br>mpstat - 提供单个或组合CPU相关统计<br>pidstat - 提供Linux进程级别统计：I/O、CPU、内存等<br>sar - 收集、报告、保存系统活动信息：CPU、内存、磁盘、中断、网络接口、TTY、内核表等<br>sadc - 系统活动数据收集器，作为sar后端使用<br>sa1 - 收集系统活动日常数据，并二进制格式存储，它作为sadc的工具的前端，可以通过cron来调用<br>sa2 - 生成系统每日活动报告，同样可作为sadc的工具的前端，可以通过cron来调用<br>sadf - 可以以CSV、XML格式等显示sar收集的性能数据，这样非常方便的将系统数据导入到数据库中，或导入到Excel中来生成图表<br>nfsiostat-sysstat: 提供NFS I/O统计<br>cifsiostat: 提供CIFS统计<br>pidstat输出结果的%<span class="hljs-built_in">wait</span>指标，代表进程等待CPU的时间百分比，systat 11.5.5版本才引入新指标。<br></code></pre></div></td></tr></table></figure><h2 id="linux常用工具">Linux常用工具</h2><h3 id="vim">vim</h3><p><strong>功能</strong>: 1. 命令行模式下的文本编辑器。 2. 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 3. 使用方式: <code>vim filename</code> 1. 如果已有该文件，则打开它。 2. 如果没有该文件，则打开个一个新的文件，并命名为<code>filename</code></p><p><strong>模式</strong>: 1. <strong>一般命令模式</strong> 默认模式。 命令输入方式: 类似于打游戏放技能，按不同字符，即可进行不同操作。 可以复制、粘贴、删除文本等。 2. <strong>编辑模式</strong> 在 一般命令模式 里按下 i ，会进入 编辑模式 。 按下 ESC 会退出 编辑模式 ，返回到 一般命令模式 。 3. <strong>命令行模式</strong> 在 一般命令模式 里按下 :/? 三个字母中的任意一个，会进入 命令行模式 。 命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。</p><p><strong>操作</strong>：</p><ol type="1"><li><p>一般模式切换到编辑模式（常用）</p><ul><li><code>i</code>: 在光标所处位置 直接 开始</li><li><code>a</code> : 在光标所处位置的 下一个字符 开始</li><li><code>o</code> : 在光标所处位置的 下一行 开始</li><li><code>r</code> : 取代当前光标处的字符，然后开始</li><li><code>[ESC]</code> : 退出编辑模式，回到一般模式</li></ul></li><li><p>光标移动操作</p><ul><li><code>h</code> 或 <code>左箭头键</code> : 光标向 左 移动 一个字符</li><li><code>j</code>或 <code>向下箭头</code> : 光标向 下 移动 一个字符</li><li><code>k</code> 或 <code>向上箭头</code> : 光标向 上 移动 一个字符</li><li><code>l</code>或 <code>向右箭头</code> : 光标向 右 移动 一个字符</li><li><code>n&lt;Space&gt;</code> : n 为数字，光标 向右移动这一行的n个字符</li><li><code>n&lt;Enter&gt;</code> : n 为数字，光标 向下移动n行</li><li><code>0</code>或 <code>功能键[Home]</code>: 光标移动到 本行开头</li><li><code>$</code>或<code>功能键[End]</code>: 光标移动到 本行末尾</li><li><code>G</code>: 光标移动到 最后一行</li><li><code>:n</code> 或 <code>nG</code>: n 为数字，光标移动到 第n行</li><li><code>gg</code>: 光标移动到 第一行 ，相当于 <code>1G</code></li></ul></li><li><p>查找、替换操作</p><ul><li><code>/word</code> : 向 光标之下 寻找 第一个值为 <code>word</code> 的字符串。</li><li><code>?word</code> : 向 光标之上 寻找 第一个值为 <code>word</code> 的字符串。</li><li><code>n</code> : 重复 前一个 查找操作</li><li><code>N</code> : 反向 重复 前一个 查找操作</li><li><code>:n1,n2s/word1/word2/g</code> : <code>n1</code>与 <code>n2</code> 为数字，在第 <code>n1</code> 行与 <code>n2</code> 行之间寻找 <code>word1</code> 这个字符串，并将该字符串 替换 为 <code>word2</code></li><li><code>:1,$s/word1/word2/g</code> : 将全文的 <code>word1</code> 替换为 <code>word2</code></li><li><code>:1,$s/word1/word2/gc</code> : 将全文的 <code>word1</code> 替换为 <code>word2</code> ，且在替换前 要求用户确认。</li></ul></li><li><p>文本操作（可搭配 <code>数字+&lt;Enter&gt;/&lt;Space&gt;、0、G、$</code> 等使用，达到预期组合效果）</p><ul><li><code>v</code>: 选中文本</li><li><code>d</code> : 删除选中的文本</li><li><code>dd</code> : 删除当前行</li><li><code>y</code> : 复制选中的文本</li><li><code>yy</code> : 复制当前行</li><li><code>p</code> : 将复制的数据在光标的下一行/下一个位置 粘贴</li><li><code>u</code> : 撤销</li><li><code>Ctrl + r</code> : 取消撤销</li><li><code>&gt;</code>: 将选中的文本整体 向右缩进一次</li><li><code>&lt;</code>: 将选中的文本整体 向左缩进一次</li></ul></li><li><p>命令行操作</p><ul><li><code>:w</code> : 保存</li><li><code>:w!</code> : 强制保存</li><li><code>:q</code> : 退出</li><li><code>:q!</code> : 强制退出</li><li><code>:wq</code> : 保存并退出</li><li><code>:set paste</code> : 设置成粘贴模式，取消代码自动缩进</li><li><code>:set nopaste</code> : 取消粘贴模式，开启代码自动缩进</li><li><code>:set nu</code> : 显示行号</li><li><code>:set nonu</code> : 隐藏行号</li><li><code>:noh</code> :关闭查找关键词高亮</li></ul></li><li><p><code>gg=G</code> : 将全文代码格式化</p></li><li><p><code>Ctrl + q</code> : 当vim卡死时，可以 取消当前正在执行的命令</p></li><li><p><strong>异常处理</strong></p><ul><li>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种:<ul><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件即可</li></ul></li></ul></li></ol><h3 id="tmux">tmux</h3><p>参考文章：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程-阮一峰</a></li><li><a href="https://zhuanlan.zhihu.com/p/90464490">tmux常用命令及快捷方式</a></li></ul><h4 id="tmux是什么">tmux是什么</h4><p>tmux是一款强大的终端多路复用器，支持一个终端中的多个程序之间轻松切换，分离它们（它们在后台运行）并将其重新连接到不同的终端。</p><p>tmux中有三个概念：会话(session)、窗口(window)和窗格(panel)</p><ul><li>会话：会话表示用户和计算机之间的一个交流关系，一个会话可以建立多个窗口。会话有两个对立状态，attached(连接)和detached(分离)，连接就是用户和会话之间建立了正常连接，可以交互。当用户关闭终端attached状态就会变为detached状态，也可以手动转为detached状态；分离就是用户和会话之间断开了连接，需要先转为attached状态才能交互。</li><li>窗口：window就是当前终端的窗口，如果终端全屏也就是你一眼可以看到的整个屏幕。</li><li>窗格：一个窗口可以分成多个窗格，就是将当前屏幕分成好几块（分屏）。</li></ul><h4 id="tmux作用">tmux作用</h4><p>tmux 就是会话与窗口的"解绑"工具，将它们彻底分离。</p><blockquote><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 （2） 它可以让新窗口"接入"已经存在的会话。 （3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 （4）它还支持窗口任意的垂直和水平拆分。</p></blockquote><h4 id="基本用法">基本用法</h4><h5 id="安装">安装</h5><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><span class="hljs-comment"># CentOS 或 Fedora</span><br>$ sudo yum install tmux<br><span class="hljs-comment"># Mac</span><br>$ brew install tmux<br></code></pre></div></td></tr></table></figure><h5 id="启动与退出">启动与退出</h5><p>安装完成后，键入<code>tmux</code>命令，就进入了 tmux 窗口。按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tmux<br>$ <span class="hljs-built_in">exit</span> <span class="hljs-comment"># 或 ctrl+d 退出</span><br></code></pre></div></td></tr></table></figure><h5 id="前缀键">前缀键</h5><p>tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><p>会话管理</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.新建会话 下面命令新建一个指定名称的会话</span><br><span class="hljs-comment"># 第一个启动的 tmux 窗口，编号是0，第二个窗口的编号是1</span><br><span class="hljs-comment"># 使用编号区分会话，不太直观，更好的方法是为会话起名</span><br>$ tmux new -s &lt;session-name&gt;<br><br><span class="hljs-comment"># 2.分离会话</span><br>$ tmux detach <span class="hljs-comment"># or Ctrl+b d</span><br><span class="hljs-comment"># 上面命令执行后，就会退出当前 tmux 窗口，但是会话和里面的进程仍然在后台运行</span><br><span class="hljs-comment"># 查看当前所有的 tmux 会话</span><br>$ tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>$ tmux list-session<br><br><span class="hljs-comment"># 3.接入会话</span><br><span class="hljs-comment"># 使用会话编号</span><br>$ tmux attach -t 0<br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux attach -t &lt;session-name&gt;<br><br><span class="hljs-comment"># 4.杀死会话</span><br><span class="hljs-comment"># 使用会话编号</span><br>$ tmux kill-session -t 0<br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux kill-session -t &lt;session-name&gt;<br><br><span class="hljs-comment"># 5.切换会话</span><br><span class="hljs-comment"># 使用会话编号</span><br>$ tmux switch -t 0<br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux switch -t &lt;session-name&gt;<br><br><span class="hljs-comment"># 6.重命名会话</span><br>$ tmux rename-session -t 0 &lt;new-name&gt;<br><br><span class="hljs-comment"># 7.会话快捷键</span><br>Ctrl+b d：分离当前会话。<br>Ctrl+b s：列出所有会话。<br>Ctrl+b $：重命名当前会话。<br></code></pre></div></td></tr></table></figure><h4 id="最简操作流程">最简操作流程</h4><blockquote><ol type="1"><li>新建会话<code>tmux new -s my_session</code>。</li><li>在tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li></ol></blockquote><h4 id="窗格操作">窗格操作</h4><p>tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 tmux 窗口中执行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.划分窗格</span><br><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-window<br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-window -h<br><br><span class="hljs-comment"># 2.移动光标</span><br><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br><br><span class="hljs-comment"># 3.交换窗格位置</span><br><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br><br><span class="hljs-comment"># 4.窗格快捷键</span><br>Ctrl+b %：划分左右两个窗格。<br>Ctrl+b <span class="hljs-string">&quot;：划分上下两个窗格。</span><br><span class="hljs-string">Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="hljs-string">Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="hljs-string">Ctrl+b o：光标切换到下一个窗格。</span><br><span class="hljs-string">Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="hljs-string">Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="hljs-string">Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="hljs-string">Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="hljs-string">Ctrl+b x：关闭当前窗格。</span><br><span class="hljs-string">Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="hljs-string">Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="hljs-string">Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="hljs-string">Ctrl+b q：显示窗格编号。</span><br></code></pre></div></td></tr></table></figure><h4 id="窗口管理">窗口管理</h4><p>除了将一个窗口划分成多个窗格，tmux 也允许新建多个窗口。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.新建窗口</span><br>$ tmux new-window<br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br><br><span class="hljs-comment"># 2.切换窗口</span><br><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br><br><span class="hljs-comment"># 3.重命名窗口</span><br>$ tmux rename-window &lt;new-name&gt;<br><br><span class="hljs-comment"># 4.窗口快捷键</span><br>Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。<br>Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。<br>Ctrl+b n：切换到下一个窗口。<br>Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。<br>Ctrl+b w：从列表中选择窗口。<br>Ctrl+b ,：窗口重命名。<br></code></pre></div></td></tr></table></figure><h4 id="其他命令">其他命令</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有快捷键，及其对应的 tmux 命令</span><br>$ tmux list-keys<br><br><span class="hljs-comment"># 列出所有 tmux 命令及其参数</span><br>$ tmux list-commands<br><br><span class="hljs-comment"># 列出当前所有 tmux 会话的信息</span><br>$ tmux info<br><br><span class="hljs-comment"># 重新加载当前的 tmux 配置</span><br>$ tmux source-file ~/.tmux.conf<br></code></pre></div></td></tr></table></figure><p><strong>其他技巧</strong></p><p><strong>1.tmux/screen rz/sz 文件卡死快速退出方法。</strong>(tmux 暂不能使用rz/sz)</p><ul><li>按住Ctrl键, 再按五次x键 (强行终断传输)</li></ul><p><strong>2.实现鼠标选中窗格和移动</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 配置文件使用参照下一节</span><br><span class="hljs-comment"># 在tmux.conf里加一句：</span><br>$ <span class="hljs-built_in">set</span> -g mouse on <br></code></pre></div></td></tr></table></figure><p><strong>3.tmux复制文字到系统剪贴板</strong></p><p>有如下几种方式：</p><ol type="1"><li>传统的无鼠标选中模式下，只能通过<code>Ctrl+B [</code>开启，同时移动位置选中复制区域，<code>Ctrl+B ]</code>粘贴，不方便。</li><li>配置文件开启鼠标选中之后，就可以按下<code>Shift+Alt</code>，同时鼠标按下选中要复制的文字，即可将文字复制进系统粘贴板。直接按<code>Shift</code>加鼠标复制会出现跨屏复制，有多余的竖线。</li><li>按照下方配置文件中的，安装<code>xclip</code>，配置为鼠标选中同时按下<code>Enter</code>复制内容即可。<strong>（推荐)</strong></li></ol><h4 id="tmux更改配置文件">tmux更改配置文件</h4><p>如果没有配置文件<code>.tmux.conf</code>，可自行在<code>~</code>目录下创建：使用命令<code>touch ~/.tmux.conf</code></p><p>使用<code>vim</code>向配置文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将r 设置为加载配置文件，并显示<span class="hljs-string">&quot;reloaded!&quot;</span>信息</span><br>bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use Shift-arrow keys to switch panes</span><br>bind -n S-Left select-pane -L<br>bind -n S-Right select-pane -R<br>bind -n S-Up select-pane -U<br>bind -n S-Down select-pane -D<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Alt-arrow to switch windows</span><br>bind -n M-Left previous-window<br>bind -n M-Right next-window<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Enable mouse mode (tmux 2.1 and above)</span><br>setw -g mouse on<br>set -g mouse on<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置鼠标选中同时按下 回车(Enter)键复制选中内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">会将选中内容复制到系统剪贴板，可以随意粘贴 在tmux分屏或者linux终端或宿主机中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前提是安装xclip sudo apt install xclip</span><br>set-option -g mouse on<br>set-option -s set-clipboard on<br>bind-key  -T copy-mode-vi Enter  send-keys -X copy-pipe-and-cancel &quot;xclip -in -selection clipboard&quot;<br>bind-key  -T copy-mode Enter  send-keys -X copy-pipe-and-cancel &quot;xclip -in -selection clipboard&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Enable oh my zsh <span class="hljs-keyword">in</span> tmux</span><br>set -g default-command /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mouse based copy 苹果系统有效 linux貌似不行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bind-key -T copy-mode MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">&quot;reattach-to-user-namespace pbcopy&quot;</span></span>  <br></code></pre></div></td></tr></table></figure><p>新建一个tmux窗口并进入，输入命令<code>ctrl+B :</code>进入命令行模式，底部出现命令行：再输入:<code>source ~/.tmux.conf</code>，或者进入tmux窗口后直接输入<code>ctrl+B r</code>，因为<code>r</code>键已经在配置文件第一行绑定为<code>source ~/.tmux.conf</code>，以上步骤使配置文件生效。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础语法</title>
    <link href="/MySQL/Base/"/>
    <url>/MySQL/Base/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql基础语法">MySQL基础语法</h2><h3 id="sql规范">1.SQL规范</h3><h4 id="基本规则">1.1 基本规则</h4><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 或 </li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（' '）表示</li><li>列的别名，尽量使用双引号（" "），而且不建议省略as</li></ul></li></ul><h4 id="sql大小写规范">1.2 SQL大小写规范</h4><ul><li><strong>MySQL在Windows环境下是大小写不敏感的</strong></li><li><strong>MySQL在Linux环境下是大小写敏感的</strong><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li><strong>推荐采用统一的书写规范：</strong><ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><h4 id="注-释">1.3 注 释</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">单行注释：#注释文字(MySQL特有的方式)<br>单行注释：<span class="hljs-comment">-- 注释文字(--后面必须包含一个空格。)</span><br>多行注释：<span class="hljs-comment">/* 注释文字 */</span><br></code></pre></div></td></tr></table></figure><h4 id="命名规则">1.4 命名规则</h4><ul><li>数据库、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h3 id="基础查询">2. 基础查询</h3><h4 id="查询语句">2.1 查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- SELECT ...</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 没有任何子句</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">FROM</span> DUAL; <span class="hljs-comment">-- dual：伪表</span><br><br><span class="hljs-comment">-- SELECT ... FROM</span><br><span class="hljs-comment">-- 查询单列</span><br><span class="hljs-keyword">SELECT</span>  column_name<br><span class="hljs-keyword">FROM</span> table_name;<br><span class="hljs-comment">-- 查询多列</span><br><span class="hljs-keyword">SELECT</span>  column_name1, column_name2, ...<br><span class="hljs-keyword">FROM</span> table_name;<br><span class="hljs-comment">-- 查询所有</span><br><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></div></td></tr></table></figure><h4 id="列的别名">2.2 列的别名</h4><ul><li>重命名一个列</li><li>便于计算</li><li>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</li><li>AS 可以省略</li><li>建议别名简短，见名知意</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> col_name1 <span class="hljs-keyword">AS</span> new_name1, col_name2, new_name2 <br><span class="hljs-keyword">FROM</span> table_name;<br><br><span class="hljs-keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span> &quot;Annual Salary&quot;<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></div></td></tr></table></figure><h4 id="去重">3.3 去重</h4><p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p><p>例题：<a href="https://www.nowcoder.com/practice/88aa923a9a674253b861a8fa56bac8e5?tpId=199&amp;tqId=1975674&amp;ru=/exam/oj&amp;qru=/ta/sql-quick-study/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%25E7%25AF%2587%26topicId%3D199">牛客SQL22 统计每个学校的答过题的用户的平均答题数</a></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.`DISTINCT`需要放到所有列名的前面</span><br><span class="hljs-comment">-- 2.`DISTINCT`是对后面所有列名的组合进行去重,如果想要看都有哪些不同的部门，只需要写`DISTINCT department_id`即可</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id, salary <br><span class="hljs-keyword">FROM</span> employees;<br><br><span class="hljs-comment">-- 3.聚合函数中也可以加上DISTINCT去重</span><br><span class="hljs-comment">-- 例如牛客SQL22 统计每个学校的答过题的用户的平均答题数</span><br><span class="hljs-keyword">SELECT</span> up.university, ROUND(<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>(up.device_id)), <span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> avg_answer_cnt<br><span class="hljs-keyword">FROM</span> user_profile up<br><span class="hljs-keyword">JOIN</span> question_practice_detail qpd<br><span class="hljs-keyword">ON</span> up.device_id <span class="hljs-operator">=</span> qpd.device_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> up.university;<br></code></pre></div></td></tr></table></figure><h3 id="运算符">3.运算符</h3><h4 id="算术运算符">3.1 算术运算符</h4><table><thead><tr class="header"><th>运算符</th><th>名称</th><th>作用</th><th>实例</th></tr></thead><tbody><tr class="odd"><td>+</td><td>加法运算符</td><td>计算两个值或表达式的和</td><td>SELECT A + B</td></tr><tr class="even"><td>-</td><td>减法运算符</td><td>计算两个值或表达式的差</td><td>SELECT A - B</td></tr><tr class="odd"><td>*</td><td>乘法运算符</td><td>计算两个值或表达式的乘积</td><td>SELECT A * B</td></tr><tr class="even"><td>/ 或 DIV</td><td>除法运算符</td><td>计算两个值或表达式的商</td><td>SELECT A / B 或者 SELECT A DIV B</td></tr><tr class="odd"><td>% 或 MOD</td><td>求模（求余）运算符</td><td>计算两个值或表达式的余数</td><td>SELECT A % B 或者 SELECT A MOD B</td></tr></tbody></table><h4 id="比较运算符">3.2 比较运算符</h4><table><colgroup><col style="width: 6%" /><col style="width: 12%" /><col style="width: 52%" /><col style="width: 28%" /></colgroup><thead><tr class="header"><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>=</td><td>等于运算符</td><td>判断两个值、字符串或表达式是否相等</td><td>SELECT C FROM TABLE WHERE A = B</td></tr><tr class="even"><td>&lt;=&gt;</td><td>安全等于运算符</td><td>安全地判断两个值、字符串或表达式是否相等</td><td>SELECT C FROM TABLE WHERE A &lt;=&gt; B</td></tr><tr class="odd"><td>&lt;&gt; 或 !=</td><td>不等于运算符</td><td>判断两个值、字符串或表达式是否不相等</td><td>SELECT C FROM TABLE WHERE A &lt;&gt; B</td></tr><tr class="even"><td>&lt;</td><td>小于运算符</td><td>判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &lt; B</td></tr><tr class="odd"><td>&lt;=</td><td>小于等于运算符</td><td>判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &lt;= B</td></tr><tr class="even"><td>&gt;</td><td>大于运算符</td><td>判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &gt; B</td></tr><tr class="odd"><td>&gt;=</td><td>大于等于运算符</td><td>判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &gt;= B</td></tr></tbody></table><p>其他比较运算符</p><table><colgroup><col style="width: 16%" /><col style="width: 13%" /><col style="width: 33%" /><col style="width: 36%" /></colgroup><thead><tr class="header"><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>IS NULL</td><td>为空运算符</td><td>判断值、字符串或表达式是否为空</td><td>SELECT B FROM TABLE WHERE A IS NULL</td></tr><tr class="even"><td>IS NOTNULL</td><td>不为空运算符</td><td>判断值、字符串或表达式是否不为空</td><td>SELECT B FROM TABLE WHERE A IS NOT NULL</td></tr><tr class="odd"><td>LEAST</td><td>最小值运算符</td><td>在多个值中返回最小值</td><td>SELECT D FROM TABLE WHERE C LEAST(A, B)</td></tr><tr class="even"><td>GREATEST</td><td>最大值运算符</td><td>在多个值中返回最大值</td><td>SELECT D FROM TABLE WHERE C GREATEST(A, B)</td></tr><tr class="odd"><td>BETWEEN ... AND ...</td><td>两值之间的运算符</td><td>判断一个值是否在两个值之间</td><td>SELECT D FROM TABLE WHERE C BETWEEN A AND B</td></tr><tr class="even"><td>ISNULL</td><td>为空运算符</td><td>判断一个值、字符串或表达式是否为空</td><td>SELECT B FROM TABLE WHERE A ISNULL</td></tr><tr class="odd"><td>IN</td><td>属于运算符</td><td>判断一个值是否为列表中的任意一个值</td><td>SELECT D FROM TABLE WHERE C IN(A, B)</td></tr><tr class="even"><td>NOT IN</td><td>不属于运算符</td><td>判断一个值是否不是一个列表中的任意一个值</td><td>SELECT D FROM TABLE WHERE C NOT IN(A, B)</td></tr><tr class="odd"><td>LIKE</td><td>模糊匹配运算符</td><td>判断一个值是否符合模糊匹配规则</td><td>SELECT C FROM TABLE WHERE A LIKE B</td></tr><tr class="even"><td>REGEXP</td><td>正则表达式运算符</td><td>判断一个值是否符合正则表达式的规则</td><td>SELECT C FROM TABLE WHERE A REGEXPB</td></tr><tr class="odd"><td>RLIKE</td><td>正则表达式运算符</td><td>判断一个值是否符合正则表达式的规则</td><td>SELECT C FROM TABLE WHERE A RLIKEB</td></tr></tbody></table><p><strong>LIKE运算符</strong></p><p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p><p>LIKE运算符通常使用如下通配符：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">“<span class="hljs-operator">%</span>”：匹配<span class="hljs-number">0</span>个或多个字符。<br>“_”：只能匹配一个字符。<br></code></pre></div></td></tr></table></figure><p><strong>ESCAPE</strong></p><ul><li>回避特殊符号的：<strong>使用转义符</strong>。</li><li>如果使用，要省略ESCAPE。如果不是，则要加上ESCAPE。</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 案例：查询第2个字符是_且第3个字符是&#x27;a&#x27;的员工信息</span><br><span class="hljs-comment">-- 需要使用转义字符: \ </span><br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_\_a%&#x27;</span>;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_$_a%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;$&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p><strong>REGEXP运算符</strong></p><p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果NULL。</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">（1）‘^’匹配以该字符后面的字符开头的字符串。<br>（2）‘$’匹配以该字符前面的字符结尾的字符串。<br>（3）‘.’匹配任何一个单字符。<br>（4）“<span class="hljs-comment">[...]</span>”匹配在方括号内的任何字符。例如，“<span class="hljs-comment">[abc]</span>”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“<span class="hljs-comment">[a-z]</span>”匹配任何字母，而“<span class="hljs-comment">[0-9]</span>”匹配任何数字。<br>（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“<span class="hljs-comment">[0-9]</span>*”匹配任何数量的数字， 而“*”匹配任何数量的任何字符。<br></code></pre></div></td></tr></table></figure><h4 id="逻辑运算符">3.3 逻辑运算符</h4><table><thead><tr class="header"><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>NOT 或 !</td><td>逻辑非</td><td>SELECT NOT A</td></tr><tr class="even"><td>AND 或 &amp;&amp;</td><td>逻辑与</td><td>SELECT A AND B</td></tr><tr class="odd"><td>OR 或 ||</td><td>逻辑或</td><td>SELECT A OR B</td></tr><tr class="even"><td>XOR</td><td>逻辑异或</td><td>SELECT A XOR B</td></tr></tbody></table><h4 id="位运算符">3.4 位运算符</h4><table><thead><tr class="header"><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>&amp;</td><td>按位与（位AND）</td><td>SELECT A &amp; B</td></tr><tr class="even"><td>|</td><td>按位或（位OR）</td><td>SELECT A | B</td></tr><tr class="odd"><td>^</td><td>按位异或（为XOR）</td><td>SELECT A ^ B</td></tr><tr class="even"><td>~</td><td>按位取反</td><td>SELECT ~A</td></tr><tr class="odd"><td>&gt;&gt;</td><td>按位右移</td><td>SELECT A &gt;&gt; 2</td></tr><tr class="even"><td>&lt;&lt;</td><td>按位左移</td><td>SELECT B &lt;&lt; 2</td></tr></tbody></table><h3 id="排序与分页">4.排序与分页</h3><h4 id="排序数据">4.1 排序数据</h4><h5 id="排序规则"><strong>排序规则</strong></h5><ul><li>使用 ORDER BY 子句排序<ul><li><strong>ASC（ascend）:升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><strong>ORDER BY子句在SELECT语句的结尾。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 单列排序</span><br><span class="hljs-comment">-- 如果在ORDER BY 后没有显式指名排序的方式的话，则默认按照升序排列</span><br><span class="hljs-keyword">SELECT</span> col_name1, col_name2, col_name3,...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col_name4; <br><span class="hljs-comment">-- 可以使用列的别名，进行排序</span><br><span class="hljs-keyword">SELECT</span> col_name1, col_name2 new_col_name2<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> new_col_name2;<br><span class="hljs-comment">-- 多列排序</span><br><span class="hljs-keyword">SELECT</span> col_name1, col_name2, col_name3,...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col_name1 <span class="hljs-keyword">DESC</span>, col_name2 <span class="hljs-keyword">ASC</span>;<br></code></pre></div></td></tr></table></figure><ul><li>可以使用不在SELECT列表中的列排序。</li><li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li></ul><h4 id="分页">4.2 分页</h4><h5 id="实现规则"><strong>实现规则</strong></h5><ul><li><strong>MySQL中使用LIMIT实现分页</strong></li><li>格式：</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">LIMIT [位置偏移量,] 行数<br></code></pre></div></td></tr></table></figure><ul><li>“偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 前10条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">10</span>; <br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 第11至20条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">10</span>,<span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 第21至30条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">20</span>,<span class="hljs-number">10</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p></blockquote><ul><li>分页显式公式：**（当前页数-1）*每页条数，每页条数**</li><li><strong>注意：LIMIT子句必须放在整个SELECT语句的最后！</strong></li></ul><h3 id="多表查询">5.多表查询</h3><h4 id="笛卡尔积交叉连接">5.1 笛卡尔积（交叉连接）</h4><p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是<code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工姓名和所在部门名称 </span><br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees,departments;<br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> departments;<br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments;<br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">JOIN</span> departments;<br></code></pre></div></td></tr></table></figure><p>为了避免笛卡尔积， 可以<strong>在WHERE加入有效的连接条件。</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.column, table2.column<br><span class="hljs-keyword">FROM</span> table1, table2<br><span class="hljs-keyword">WHERE</span> table1.column1 <span class="hljs-operator">=</span> table2.column2; <span class="hljs-comment">-- 连接条件</span><br></code></pre></div></td></tr></table></figure><p>在表中有相同列时，在列名之前加上表名前缀。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 案例：查询员工的姓名及其部门名称</span><br><span class="hljs-keyword">SELECT</span> last_name, department_name<br><span class="hljs-keyword">FROM</span> employees e, departments d<br><span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.department_id;<br></code></pre></div></td></tr></table></figure><h4 id="多表查询-1">5.2 多表查询</h4><h5 id="等值连接vs非等值连接">5.2.1 等值连接vs非等值连接</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 等值连接 </span><br><span class="hljs-comment">-- 多个表中有相同列时，必须在列名之前加上表名前缀。</span><br><span class="hljs-comment">-- 使用别名可以简化查询, 列名前使用表名前缀可以提高查询效率。</span><br><span class="hljs-comment">-- 连接n个表,至少需要n-1个连接条件</span><br><span class="hljs-keyword">SELECT</span> e.employee_id, e.last_name, e.department_id,<br>d.department_id, d.location_id<br><span class="hljs-keyword">FROM</span> employees e , departments d<br><span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.department_id;<br><br><span class="hljs-comment">-- 非等值连接的例子</span><br><span class="hljs-comment">-- 求employees表中的列工资在job_grades表中最高工资与最低工资之间的工资等级</span><br><span class="hljs-keyword">SELECT</span> e.last_name,e.salary,j.grade_level<br><span class="hljs-keyword">FROM</span> employees e,job_grades j<br><span class="hljs-comment">-- where e.`salary` between j.`lowest_sal` and j.`highest_sal`;</span><br><span class="hljs-keyword">WHERE</span> e.`salary` <span class="hljs-operator">&gt;=</span> j.`lowest_sal` <span class="hljs-keyword">AND</span> e.`salary` <span class="hljs-operator">&lt;=</span> j.`highest_sal`;<br></code></pre></div></td></tr></table></figure><h5 id="自连接vs非自连接">5.2.2 自连接vs非自连接</h5><ul><li>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两 个表再进行内连接，外连接等查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 自连接的例子：查询employees表，返回“Xxx works for Xxx”</span><br><span class="hljs-comment">-- CONCAT() mysql中连接字符串的函数</span><br><span class="hljs-keyword">SELECT</span> CONCAT(worker.last_name ,<span class="hljs-string">&#x27; works for &#x27;</span><br>, manager.last_name)<br><span class="hljs-keyword">FROM</span> employees worker, employees manager<br><span class="hljs-keyword">WHERE</span> worker.manager_id <span class="hljs-operator">=</span> manager.employee_id ;<br></code></pre></div></td></tr></table></figure><h5 id="内连接-vs-外连接">5.2.3 内连接 vs 外连接</h5><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p><ul><li>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</li><li>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</li></ul></li></ul><h4 id="sql99-语法实现多表查询">5.3 SQL99 语法实现多表查询</h4><h5 id="基本语法">5.3.1 基本语法</h5><ul><li>使用JOIN...ON子句创建连接的语法结构：</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.column, table2.column, table3.column<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1 和 table2 的连接条件<br><span class="hljs-keyword">JOIN</span> table3<br><span class="hljs-keyword">ON</span> table2 和 table3 的连接条件<br></code></pre></div></td></tr></table></figure><h5 id="内连接inner-join的实现">5.3.2 内连接(INNER JOIN)的实现</h5><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></div></td></tr></table></figure><h5 id="外连接outer-join的实现"><strong>3.3</strong> <strong>外连接(OUTER JOIN)的实现</strong></h5><h6 id="左外连接left-outer-join">3.3.1 左外连接(LEFT OUTER JOIN)</h6><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></div></td></tr></table></figure><h6 id="右外连接right-outer-join">3.3.2 右外连接(RIGHT OUTER JOIN)</h6><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></div></td></tr></table></figure><h6 id="满外连接full-outer-join">3.3.3 满外连接(FULL OUTER JOIN)</h6><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li><li>MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT JOIN代替。</li><li>LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在， 只能用 (+) 表示。</li></ul><h4 id="union的使用">5.4. UNION的使用</h4><p><strong>合并查询结果</strong>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并 时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p><p>语法格式</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span>,... <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span>,... <span class="hljs-keyword">FROM</span> table2<br></code></pre></div></td></tr></table></figure><p><strong>UNION操作符</strong></p><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p><p><strong>UNION ALL操作符</strong></p><p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p><blockquote><p>执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p></blockquote><h4 id="种sql-joins的实现">5.5 7种SQL JOINS的实现</h4><figure><img src="/img/MySQL/Base/sql_join.png" alt="7种SQL_Joins" /><figcaption aria-hidden="true">7种SQL_Joins</figcaption></figure><h5 id="举例">5.5.1 举例</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 中图：内连接</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br><span class="hljs-comment">-- 左上图：左外连接</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br><span class="hljs-comment">-- 右上图：右外连接</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br><span class="hljs-comment">-- 左中图：</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-comment">-- 右中图：</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-comment">-- 左下图：满外连接</span><br><span class="hljs-comment">-- 方式1：左上图 UNION ALL 右中图</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-comment">-- 方式2：左中图 UNION ALL 右上图</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br><span class="hljs-comment">-- 右下图：左中图  UNION ALL 右中图</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></div></td></tr></table></figure><h5 id="语法格式小结">5.5.2 语法格式小结</h5><ul><li>左中图</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--实现A - A∩B</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><ul><li>右中图</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--实现B - A∩B</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><ul><li>左下图</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 实现查询结果是A∪B</span><br><span class="hljs-comment">-- 用左外的A，union 右外的B</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 等其他子句<br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 等其他子句;<br></code></pre></div></td></tr></table></figure><ul><li>右下图</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）</span><br><span class="hljs-comment">-- 使用左外的 (A - A∩B) union 右外的（B - A∩B）</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句<br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句<br></code></pre></div></td></tr></table></figure><h4 id="sql99语法新特性">5.6. SQL99语法新特性</h4><h5 id="自然连接">5.6.1 自然连接</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">AND</span> e.`manager_id` <span class="hljs-operator">=</span> d.`manager_id`;<br><span class="hljs-comment">-- NATURAL JOIN : 它会帮你自动查询两张连接表中`所有相同的字段`，然后进行`等值连接`。</span><br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> departments d;<br></code></pre></div></td></tr></table></figure><h5 id="using连接">5.6.2 USING连接</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id;<br><span class="hljs-comment">-- 指定数据表里的同名字段进行等值连接，只能配合JOIN一起使用。</span><br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">USING</span> (department_id);<br></code></pre></div></td></tr></table></figure><blockquote><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p></blockquote><h4 id="小结">5.7 小结</h4><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p><ul><li>WHERE：适用于所有关联查询</li><li>ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起 写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字 段值相等</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 关联条件</span><br><span class="hljs-comment">-- 把关联条件写在where后面</span><br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees,departments<br><span class="hljs-keyword">WHERE</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id;<br><span class="hljs-comment">-- 把关联条件写在on后面，只能和JOIN一起使用</span><br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments<br><span class="hljs-keyword">ON</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id;<br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> departments<br><span class="hljs-keyword">ON</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id;<br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">JOIN</span> departments<br><span class="hljs-keyword">ON</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id;<br><span class="hljs-comment">-- 把关联字段写在using()中，只能和JOIN一起使用</span><br><span class="hljs-comment">-- 而且两个表中的关联字段必须名称相同，而且只能表示=</span><br><span class="hljs-comment">-- 查询员工姓名与基本工资</span><br><span class="hljs-keyword">SELECT</span> last_name,job_title<br><span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> jobs <span class="hljs-keyword">USING</span>(job_id);<br><span class="hljs-comment">-- n张表关联，需要n-1个关联条件</span><br><span class="hljs-comment">-- 查询员工姓名，基本工资，部门名称</span><br><span class="hljs-keyword">SELECT</span> last_name,job_title,department_name <span class="hljs-keyword">FROM</span> employees,departments,jobs<br><span class="hljs-keyword">WHERE</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id<br><span class="hljs-keyword">AND</span> employees.job_id <span class="hljs-operator">=</span> jobs.job_id;<br><span class="hljs-keyword">SELECT</span> last_name,job_title,department_name<br><span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> jobs<br><span class="hljs-keyword">ON</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id<br><span class="hljs-keyword">AND</span> employees.job_id <span class="hljs-operator">=</span> jobs.job_id;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p></blockquote><h3 id="单行函数">6.单行函数</h3><h4 id="数值函数">6.1 数值函数</h4><h5 id="基本函数">6.1.1 基本函数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr class="even"><td>SIGN(X)</td><td>返回X的符号。正数返回1，负数返回-1，0返回0</td></tr><tr class="odd"><td>PI()</td><td>返回圆周率的值</td></tr><tr class="even"><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr class="odd"><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr class="even"><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr class="odd"><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr class="even"><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr class="odd"><td>RAND()</td><td>返回0~1的随机值</td></tr><tr class="even"><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机</td></tr><tr class="odd"><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr class="even"><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td></tr><tr class="odd"><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr class="even"><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><h5 id="角度与弧度">6.1.2 角度与弧度</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr class="even"><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr></tbody></table><h5 id="三角函数">6.1.3 三角函数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>SIN(x)</td><td>返回x的正弦值，其中，参数x为弧度值</td></tr><tr class="even"><td>ASIN(x)</td><td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr class="odd"><td>COS(x)</td><td>返回x的余弦值，其中，参数x为弧度值</td></tr><tr class="even"><td>ACOS(x)</td><td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr class="odd"><td>TAN(x)</td><td>返回x的正切值，其中，参数x为弧度值</td></tr><tr class="even"><td>ATAN(x)</td><td>返回x的反正切值，即返回正切值为x的值</td></tr><tr class="odd"><td>ATAN2(m,n)</td><td>返回两个参数的反正切值</td></tr><tr class="even"><td>COT(x)</td><td>返回x的余切值，其中，X为弧度值</td></tr></tbody></table><h5 id="指数与对数">6.1.4 指数与对数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>POW(x,y)，POWER(X,Y)</td><td>返回x的y次方</td></tr><tr class="even"><td>EXP(X)</td><td>返回e的X次方，其中e是一个常数，2.718281828459045</td></tr><tr class="odd"><td>LN(X)，LOG(X)</td><td>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr class="even"><td>LOG10(X)</td><td>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr class="odd"><td>LOG2(X)</td><td>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</td></tr></tbody></table><h5 id="进制间的转换">6.1.5 进制间的转换</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr class="even"><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr class="odd"><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr class="even"><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><h4 id="字符串函数">6.2 字符串函数</h4><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr class="even"><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr class="odd"><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr class="even"><td>CONCAT(s1,s2,......,sn)</td><td>连接s1,s2,......,sn为一个字符串</td></tr><tr class="odd"><td>CONCAT_WS(x,s1,s2,......,sn)</td><td>同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x</td></tr><tr class="even"><td>INSERT(str, idx, len,replacestr)</td><td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td></tr><tr class="odd"><td>REPLACE(str, a, b)</td><td>用字符串b替换字符串str中所有出现的字符串a</td></tr><tr class="even"><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr class="odd"><td>LOWER(s) 或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr class="even"><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr class="odd"><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr class="even"><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符，实现右对齐效果</td></tr><tr class="odd"><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符，实现左对齐效果</td></tr><tr class="even"><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr class="odd"><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr class="even"><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr class="odd"><td>TRIM(s1 FROM s)</td><td>去掉字符串s开始与结尾的s1</td></tr><tr class="even"><td>TRIM(LEADING s1 FROM s)</td><td>去掉字符串s开始处的s1</td></tr><tr class="odd"><td>TRIM(TRAILING s1 FROM s)</td><td>去掉字符串s结尾处的s1</td></tr><tr class="even"><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr class="odd"><td>SPACE(n)</td><td>返回n个空格</td></tr><tr class="even"><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2的ASCII码值的大小</td></tr><tr class="odd"><td>SUBSTR(s,index,len)</td><td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td></tr><tr class="even"><td>LOCATE(substr,str)</td><td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td></tr><tr class="odd"><td>ELT(m,s1,s2,…,sn)</td><td>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn</td></tr><tr class="even"><td>FIELD(s,s1,s2,…,sn)</td><td>返回字符串s在字符串列表中第一次出现的位置</td></tr><tr class="odd"><td>FIND_IN_SET(s1,s2)</td><td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td></tr><tr class="even"><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr class="odd"><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td></tr></tbody></table><blockquote><p>注意：MySQL中，字符串的位置是从1开始的。</p></blockquote><h4 id="日期和时间函数">6.3 日期和时间函数</h4><h5 id="获取日期时间">6.3.1 获取日期、时间</h5><table><colgroup><col style="width: 66%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td><strong>CURDATE()</strong> ，CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr class="even"><td><strong>CURTIME()</strong> ， CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr class="odd"><td><strong>NOW()</strong> / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()</td><td>返回当前系统日期和时间</td></tr><tr class="even"><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr class="odd"><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间</td></tr></tbody></table><h5 id="日期与时间戳的转换">6.3.2 日期与时间戳的转换</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>UNIX_TIMESTAMP()</td><td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td></tr><tr class="even"><td>UNIX_TIMESTAMP(date)</td><td>将时间date以UNIX时间戳的形式返回。</td></tr><tr class="odd"><td>FROM_UNIXTIME(timestamp)</td><td>将UNIX时间戳的时间转换为普通格式的时间</td></tr></tbody></table><h5 id="获取月份星期星期数天数等函数">6.3.3 获取月份、星期、星期数、天数等函数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>YEAR(date) / MONTH(date) / DAY(date)</td><td>返回具体的日期值</td></tr><tr class="even"><td>HOUR(time) / MINUTE(time) / SECOND(time)</td><td>返回具体的时间值</td></tr><tr class="odd"><td>MONTHNAME(date)</td><td>返回月份：January，...</td></tr><tr class="even"><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY.....SUNDAY</td></tr><tr class="odd"><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，。。。周日是6</td></tr><tr class="even"><td>QUARTER(date)</td><td>返回日期对应的季度，范围为1～4</td></tr><tr class="odd"><td>WEEK(date) ， WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr class="even"><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr class="odd"><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr class="even"><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是1，周一是2，。。。周六是7</td></tr></tbody></table><h5 id="日期的操作函数">6.3.4 日期的操作函数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type指定返回的值</td></tr></tbody></table><p>EXTRACT(type FROM date)函数中type的取值与含义：</p><table><thead><tr class="header"><th style="text-align: left;">type取值</th><th>含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">MICROSECOND</td><td>返回毫秒数</td></tr><tr class="even"><td style="text-align: left;">SECOND</td><td>返回秒数</td></tr><tr class="odd"><td style="text-align: left;">MINUTE</td><td>返回分钟数</td></tr><tr class="even"><td style="text-align: left;">HOUR</td><td>返回小时数</td></tr><tr class="odd"><td style="text-align: left;">DAY</td><td>返回天数</td></tr><tr class="even"><td style="text-align: left;">WEEK</td><td>返回日期在一年中的第几个星期</td></tr><tr class="odd"><td style="text-align: left;">MONTH</td><td>返回日期在一年中的第几个月</td></tr><tr class="even"><td style="text-align: left;">QUARTER</td><td>返回日期在一年中的第几个季度</td></tr><tr class="odd"><td style="text-align: left;">YEAR</td><td>返回日期的年份</td></tr><tr class="even"><td style="text-align: left;">SECOND_MICROSECOND</td><td>返回秒和毫秒值</td></tr><tr class="odd"><td style="text-align: left;">MINUTE_MICROSECOND</td><td>返回分钟和毫秒值</td></tr><tr class="even"><td style="text-align: left;">MINUTE_SECOND</td><td>返回分钟和秒值</td></tr><tr class="odd"><td style="text-align: left;">HOUR_MICROSECOND</td><td>返回小时和毫秒值</td></tr><tr class="even"><td style="text-align: left;">HOUR_SECOND</td><td>返回小时和秒值</td></tr><tr class="odd"><td style="text-align: left;">HOUR_MINUTE</td><td>返回小时和分钟值</td></tr><tr class="even"><td style="text-align: left;">DAY_MICROSECOND</td><td>返回天和毫秒值</td></tr><tr class="odd"><td style="text-align: left;">DAY_SECOND</td><td>返回天和秒值</td></tr><tr class="even"><td style="text-align: left;">DAY_MINUTE</td><td>返回天和分钟值</td></tr><tr class="odd"><td style="text-align: left;">DAY_HOUR</td><td>返回天和小时</td></tr><tr class="even"><td style="text-align: left;">YEAR_MONTH</td><td>返回年和月</td></tr></tbody></table><h5 id="时间和秒钟转换的函数">6.3.5 时间和秒钟转换的函数</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>TIME_TO_SEC(time)</td><td>将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟*60+秒</td></tr><tr class="even"><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr></tbody></table><h5 id="计算日期和时间的函数">6.3.6 计算日期和时间的函数</h5><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr class="even"><td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td><td>返回与date相差INTERVAL时间间隔的日期</td></tr><tr class="odd"><td>TIMESTAMPDIFF(unit,begin,end)</td><td>返回begin-end的结果，其中begin和end是DATE或DATETIME表达式，unit参数是确定(end-begin)的结果的单位，表示为整数，有如下几种：MICROSECOND 微秒； SECOND 秒； MINUTE 分钟； HOUR 小时； DAY 天； WEEK 周； MONTH 月份； QUARTER 季度； YEAR 年份等</td></tr><tr class="even"><td>TIMESTAMPADD(unit,interval,datetime_expr)</td><td>将以unit为单位的interval时间间距添加到日期或日期时间表达式 datetime_expr中</td></tr></tbody></table><p>上述函数中type的取值：</p><table><thead><tr class="header"><th>间隔类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>HOUR</td><td>小时</td></tr><tr class="even"><td>MINUTE</td><td>分钟</td></tr><tr class="odd"><td>SECOND</td><td>秒</td></tr><tr class="even"><td>YEAR</td><td>年</td></tr><tr class="odd"><td>MONTH</td><td>月</td></tr><tr class="even"><td>DAY</td><td>日</td></tr><tr class="odd"><td>YEAR_MONTH</td><td>年和月</td></tr><tr class="even"><td>DAY_HOUR</td><td>日和小时</td></tr><tr class="odd"><td>DAY_MINUTE</td><td>日和分钟</td></tr><tr class="even"><td>DAY_SECOND</td><td>日和秒</td></tr><tr class="odd"><td>HOUR_MINUTE</td><td>小时和分钟</td></tr><tr class="even"><td>HOUR_SECOND</td><td>小时和秒</td></tr><tr class="odd"><td>MINUTE_SECOND</td><td>分钟和秒</td></tr></tbody></table><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>ADDTIME(time1,time2)</td><td>返回time1加上time2的时间。当time2为一个数字时，代表的是秒 ，可以为负数</td></tr><tr class="even"><td>SUBTIME(time1,time2)</td><td>返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数</td></tr><tr class="odd"><td>DATEDIFF(date1,date2)</td><td>返回date1 - date2的日期间隔天数</td></tr><tr class="even"><td>TIMEDIFF(time1, time2)</td><td>返回time1 - time2的时间间隔</td></tr><tr class="odd"><td>FROM_DAYS(N)</td><td>返回从0000年1月1日起，N天以后的日期</td></tr><tr class="even"><td>TO_DAYS(date)</td><td>返回日期date距离0000年1月1日的天数</td></tr><tr class="odd"><td>LAST_DAY(date)</td><td>返回date所在月份的最后一天的日期</td></tr><tr class="even"><td>MAKEDATE(year,n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr class="odd"><td>MAKETIME(hour,minute,second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr class="even"><td>PERIOD_ADD(time,n)</td><td>返回time加上n后的时间</td></tr></tbody></table><h5 id="日期的格式化与解析">6.3.7 日期的格式化与解析</h5><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>DATE_FORMAT(date,fmt)</td><td>按照字符串fmt格式化日期date值</td></tr><tr class="even"><td>TIME_FORMAT(time,fmt)</td><td>按照字符串fmt格式化时间time值</td></tr><tr class="odd"><td>GET_FORMAT(date_type,format_type)</td><td>返回日期字符串的显示格式</td></tr><tr class="even"><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p><table><thead><tr class="header"><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>%Y</td><td>4位数字表示年份</td><td>%y</td><td>两位数字表示年份</td></tr><tr class="even"><td>%M</td><td>月名表示月份（January,....）</td><td>%m</td><td>两位数字表示月份（01,02,03。。。）</td></tr><tr class="odd"><td>%b</td><td>缩写的月名（Jan.，Feb.，....）</td><td>%c</td><td>数字表示月份（1,2,3,...）</td></tr><tr class="even"><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,...）</td><td>%d</td><td>两位数字表示月中的天数(01,02...)</td></tr><tr class="odd"><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5.....）</td><td></td><td></td></tr><tr class="even"><td>%H</td><td>两位数字表示小数，24小时制（01,02..）</td><td>%h和%I</td><td>两位数字表示小时，12小时制（01,02..）</td></tr><tr class="odd"><td>%k</td><td>数字形式的小时，24小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时，12小时制（1,2,3,4....）</td></tr><tr class="even"><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02...)</td></tr><tr class="odd"><td>%W</td><td>一周中的星期名称（Sunday...）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td></tr><tr class="even"><td>%w</td><td>以数字表示周中的天数(0=Sunday,1=Monday....)</td><td></td><td></td></tr><tr class="odd"><td>%j</td><td>以3位数字表示年中的天数(001,002...)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td></tr><tr class="even"><td>%u</td><td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td><td></td><td></td></tr><tr class="odd"><td>%T</td><td>24小时制</td><td>%r</td><td>12小时制</td></tr><tr class="even"><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><p>GET_FORMAT函数中date_type和format_type参数取值如下：</p><table><thead><tr class="header"><th>日期类型</th><th>格式化类型</th><th>返回的格式化字符串</th></tr></thead><tbody><tr class="odd"><td>DATE</td><td>USA</td><td>%m.%d.%Y</td></tr><tr class="even"><td>DATE</td><td>JIS</td><td>%Y-%m-%d</td></tr><tr class="odd"><td>DATE</td><td>ISO</td><td>%Y-%m-%d</td></tr><tr class="even"><td>DATE</td><td>EUR</td><td>%d.%m.%Y</td></tr><tr class="odd"><td>DATE</td><td>INTERNAL</td><td>%Y%m%d</td></tr><tr class="even"><td>TIME</td><td>USA</td><td>%h:%i:%s %P</td></tr><tr class="odd"><td>TIME</td><td>JIS</td><td>%H:%i:%s</td></tr><tr class="even"><td>TIME</td><td>ISO</td><td>%H:%i:%s</td></tr><tr class="odd"><td>TIME</td><td>EUR</td><td>%H.%i.%s</td></tr><tr class="even"><td>TIME</td><td>INTERNAL</td><td>%H%i%s</td></tr><tr class="odd"><td>DATETIME</td><td>USA</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr class="even"><td>DATETIME</td><td>JIS</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr class="odd"><td>DATETIME</td><td>ISO</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr class="even"><td>DATETIME</td><td>EUR</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr class="odd"><td>DATETIME</td><td>INTERNAL</td><td>%Y%m%d%H%i%s</td></tr></tbody></table><h4 id="流程控制函数">6.4 流程控制函数</h4><table><colgroup><col style="width: 56%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>IF(value,value1,value2)</td><td>如果value的值为TRUE，返回value1，否则返回value2</td></tr><tr class="even"><td>IFNULL(value1, value2)</td><td>如果value1不为NULL，返回value1，否则返回value2</td></tr><tr class="odd"><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2.... [ELSE resultn] END</td><td>相当于Java的if...else if...else...</td></tr><tr class="even"><td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END</td><td>相当于Java的switch...case...</td></tr></tbody></table><h4 id="加密与解密函数">6.5 加密与解密函数</h4><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>PASSWORD(str)</td><td>返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密。<strong>在mysql8.0中已弃用。</strong></td></tr><tr class="even"><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td></tr><tr class="odd"><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</td></tr><tr class="even"><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value，<strong>在mysql8.0中已弃用。</strong></td></tr><tr class="odd"><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value，<strong>在mysql8.0中已弃用。</strong></td></tr></tbody></table><h4 id="mysql信息函数">6.6 MySQL信息函数</h4><table><colgroup><col style="width: 48%" /><col style="width: 51%" /></colgroup><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr class="even"><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr class="odd"><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr class="even"><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr class="odd"><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr class="even"><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><h4 id="其他函数">6.7 其他函数</h4><table><thead><tr class="header"><th>函数</th><th>用法</th></tr></thead><tbody><tr class="odd"><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td></tr><tr class="even"><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr class="odd"><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr class="even"><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr class="odd"><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr class="even"><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><h3 id="聚合函数">7.聚合函数</h3><h4 id="聚合函数介绍">7.1 聚合函数介绍</h4><h5 id="avg和sum函数">7.1.1 AVG和SUM函数</h5><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary), <span class="hljs-built_in">MAX</span>(salary),<span class="hljs-built_in">MIN</span>(salary), <span class="hljs-built_in">SUM</span>(salary)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> job_id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%REP%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">8272.727273</span> <span class="hljs-operator">|</span>    <span class="hljs-number">11500.00</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6000.00</span> <span class="hljs-operator">|</span>   <span class="hljs-number">273000.00</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br></code></pre></div></td></tr></table></figure><h5 id="min和max函数">7.1.2 MIN和MAX函数</h5><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(hire_date), <span class="hljs-built_in">MAX</span>(hire_date)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">MIN</span>(hire_date) <span class="hljs-operator">|</span> <span class="hljs-built_in">MAX</span>(hire_date) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-06</span><span class="hljs-number">-17</span>     <span class="hljs-operator">|</span> <span class="hljs-number">2000</span><span class="hljs-number">-04</span><span class="hljs-number">-21</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br></code></pre></div></td></tr></table></figure><h5 id="count函数">7.1.3 COUNT函数</h5><ul><li>COUNT(*)返回表中记录总数，适用于<strong>任意数据类型</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span>       <span class="hljs-number">45</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br></code></pre></div></td></tr></table></figure><ul><li>COUNT(expr) 返回<strong>expr不为NULL</strong>的记录总数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(commission_pct)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">COUNT</span>(commission_pct) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br><span class="hljs-operator">|</span>                     <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></li></ul><p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p><p>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</p><ul><li><strong>问题：能不能使用count(列名)替换count(*)?</strong></li></ul><p>不要使用 count(列名)来替代<code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p><h4 id="group-by">7.2 GROUP BY</h4><h5 id="基本使用">7.2.1 基本使用</h5><p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span>, group_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> group_by_expression]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">column</span>];<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>明确：WHERE一定放在FROM后面</strong></p></blockquote><p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></div></td></tr></table></figure><p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></div></td></tr></table></figure><h5 id="使用多个列分组">7.2.2 使用多个列分组</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id dept_id, job_id, <span class="hljs-built_in">SUM</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_id;<br></code></pre></div></td></tr></table></figure><h5 id="group-by中使用with-rollup">7.2.3 GROUP BY中使用WITH ROLLUP</h5><p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：</p><p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p></blockquote><h4 id="having">7.3 HAVING</h4><h5 id="基本使用-1">7.3.1 基本使用</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">MAX</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>非法使用聚合函数 ： 不能在</strong> <strong>WHERE</strong> <strong>子句中使用聚合函数。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">AVG</span>(salary)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">8000</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br>ERROR <span class="hljs-number">1111</span> (HY000): Invalid use <span class="hljs-keyword">of</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">function</span><br></code></pre></div></td></tr></table></figure><blockquote><p>结论：</p><p>当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。</p><p>当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。</p></blockquote><h5 id="where和having的对比">7.3.2 WHERE和HAVING的对比</h5><table><thead><tr class="header"><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr class="even"><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><h4 id="select的执行过程">7.4 SELECT的执行过程</h4><h5 id="查询的结构">7.4.1 查询的结构</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>： <br><span class="hljs-keyword">SELECT</span> ...,....,...<br><span class="hljs-keyword">FROM</span> ...,...,....<br><span class="hljs-keyword">WHERE</span> 多表的连接条件<br><span class="hljs-keyword">AND</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,...<br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span><br>LIMIT ...,... <br><br>#方式<span class="hljs-number">2</span>：<br><span class="hljs-keyword">SELECT</span> ...,....,...<br><span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">JOIN</span> ...<br><span class="hljs-keyword">ON</span> 多表的连接条件<br><span class="hljs-keyword">JOIN</span> ...<br><span class="hljs-keyword">ON</span> ...<br><span class="hljs-keyword">WHERE</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">AND</span><span class="hljs-operator">/</span><span class="hljs-keyword">OR</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,...<br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span><br>LIMIT ...,...<br><br>#其中： <br>#（<span class="hljs-number">1</span>）<span class="hljs-keyword">from</span>：从哪些表中筛选 <br>#（<span class="hljs-number">2</span>）<span class="hljs-keyword">on</span>：关联多表查询时，去除笛卡尔积 <br>#（<span class="hljs-number">3</span>）<span class="hljs-keyword">where</span>：从表中筛选的条件<br>#（<span class="hljs-number">4</span>）<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>：分组依据 <br>#（<span class="hljs-number">5</span>）<span class="hljs-keyword">having</span>：在统计结果中再次筛选 <br>#（<span class="hljs-number">6</span>）<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>：排序 <br>#（<span class="hljs-number">7</span>）limit：分页<br></code></pre></div></td></tr></table></figure><h5 id="select执行顺序">7.4.2 SELECT执行顺序</h5><p>你需要记住 SELECT 查询时的两个顺序：</p><p><strong>1.</strong> <strong>关键字的顺序是不能颠倒的：</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">HAVING</span> ... <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... LIMIT...<br></code></pre></div></td></tr></table></figure><p><strong>2.SELECT</strong> <strong>语句的执行顺序</strong>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-keyword">FROM</span> ...,...<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">LEFT</span><span class="hljs-operator">/</span>RIGNT  <span class="hljs-keyword">JOIN</span>) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> LIMIT<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> player_id, player_name, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num # 顺序 <span class="hljs-number">5</span><br><span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">JOIN</span> team <span class="hljs-keyword">ON</span> player.team_id <span class="hljs-operator">=</span> team.team_id # 顺序 <span class="hljs-number">1</span><br><span class="hljs-keyword">WHERE</span> height <span class="hljs-operator">&gt;</span> <span class="hljs-number">1.80</span> # 顺序 <span class="hljs-number">2</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> player.team_id # 顺序 <span class="hljs-number">3</span><br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> # 顺序 <span class="hljs-number">4</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num <span class="hljs-keyword">DESC</span> # 顺序 <span class="hljs-number">6</span><br>LIMIT <span class="hljs-number">2</span> # 顺序 <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p><h5 id="sql-的执行原理">7.4.3 SQL 的执行原理</h5><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol type="1"><li><p>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</p></li><li><p>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</p></li><li><p>添加外部行。如果我们使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</p></li></ol><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</p><p>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段 。</p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code>。</p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段 ，得到虚拟表<code>vt6</code>。</p><p>最后在 vt6 的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段 ，得到最终的结果，对应的是虚拟表<code>vt7</code>。</p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p><h3 id="mysql8新特性">8.MySQL8新特性</h3><h4 id="新特性1窗口函数">8.1 新特性1：窗口函数</h4><h5 id="窗口函数分类">8.1.1 窗口函数分类</h5><p>参考文档：<a href="https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_Window_functions.html">AWS数据库开发人员指南--窗口函数</a></p><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p><ul><li><p>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</p></li><li><p>动态窗口函数的窗口大小会随着记录的不同而变化。</p></li></ul><table><thead><tr class="header"><th>函数分类</th><th>函数</th><th>函数说明</th></tr></thead><tbody><tr class="odd"><td>序号函数</td><td>ROW_NUMBER()</td><td>顺序排序</td></tr><tr class="even"><td></td><td>RANK()</td><td>并列排序，会跳过重复的序号，比如序号为1、1、3</td></tr><tr class="odd"><td></td><td>DENSE_RANK()</td><td>并列排序，不会跳过重复的序号，比如序号为1、1、2</td></tr><tr class="even"><td>分布函数</td><td>PERCENT_RANK()</td><td>等级值百分比</td></tr><tr class="odd"><td></td><td>CUME_DIST()</td><td>累积分布值</td></tr><tr class="even"><td>前后函数</td><td>LAG(expr, n)</td><td>返回当前行的前n行的expr的值</td></tr><tr class="odd"><td></td><td>LEAD(expr, n)</td><td>返回当前行的后n行的expr的值</td></tr><tr class="even"><td>首尾函数</td><td>FIRST_VALUE(expr)</td><td>返回第一个expr的值</td></tr><tr class="odd"><td></td><td>LAST_VALUE(expr)</td><td>返回最后一个expr的值</td></tr><tr class="even"><td>其他函数</td><td>NTH_VALUE(expr, n)</td><td>返回第n个expr的值</td></tr><tr class="odd"><td></td><td>NTILE(n)</td><td>将分区中的有序数据分为n个桶，记录桶编号</td></tr></tbody></table><h5 id="语法结构">8.1.2 语法结构</h5><p>窗口函数的语法结构是：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">函数 <span class="hljs-keyword">OVER</span>（[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]）<br></code></pre></div></td></tr></table></figure><p>或者是：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">函数 <span class="hljs-keyword">OVER</span> 窗口名 … <span class="hljs-keyword">WINDOW</span> 窗口名 <span class="hljs-keyword">AS</span> （[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]）<br></code></pre></div></td></tr></table></figure><ul><li><p>OVER 关键字指定函数窗口的范围。</p><ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li><p>窗口名：为窗口设置一个别名，用来标识窗口。</p></li><li><p>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</p></li><li><p>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</p></li><li><p>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> category_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> price <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> row_num, id, category_id, category, NAME, price, stock<br><span class="hljs-keyword">FROM</span> goods;<br></code></pre></div></td></tr></table></figure><h5 id="小-结">8.1.3 小 结</h5><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h4 id="新特性2公用表表达式">8.2 新特性2：公用表表达式</h4><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code>2 种。</p><h5 id="普通公用表表达式">8.2.1 普通公用表表达式</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> CTE名称 <br><span class="hljs-keyword">AS</span> （子查询） <br><span class="hljs-keyword">SELECT</span><span class="hljs-operator">|</span><span class="hljs-keyword">DELETE</span><span class="hljs-operator">|</span><span class="hljs-keyword">UPDATE</span> 语句;<br></code></pre></div></td></tr></table></figure><p>举例：查询员工所在的部门的详细信息。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> emp_dept_id<br><span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id <span class="hljs-keyword">FROM</span> employees)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> departments d <span class="hljs-keyword">JOIN</span> emp_dept_id e<br><span class="hljs-keyword">ON</span> d.department_id <span class="hljs-operator">=</span> e.department_id;<br></code></pre></div></td></tr></table></figure><h5 id="递归公用表表达式">8.2.2 递归公用表表达式</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> <br>CTE名称 <span class="hljs-keyword">AS</span> （子查询） <br><span class="hljs-keyword">SELECT</span><span class="hljs-operator">|</span><span class="hljs-keyword">DELETE</span><span class="hljs-operator">|</span><span class="hljs-keyword">UPDATE</span> 语句;<br></code></pre></div></td></tr></table></figure><p><strong>案例：</strong>针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p><ul><li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p></li><li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p></li><li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p></li></ul><p><strong>代码实现：</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> cte <br><span class="hljs-keyword">AS</span>(<span class="hljs-keyword">SELECT</span> employee_id,last_name,manager_id,<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> n <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">100</span><br><span class="hljs-comment">-- 种子查询，找到第一代领导 </span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <br><span class="hljs-keyword">SELECT</span> a.employee_id,a.last_name,a.manager_id,n<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">JOIN</span> cte <br><span class="hljs-keyword">ON</span> (a.manager_id <span class="hljs-operator">=</span> cte.employee_id) <span class="hljs-comment">-- 递归查询，找出以递归公用表表达式的人为领导的人 </span><br>)<br><span class="hljs-keyword">SELECT</span> employee_id,last_name <span class="hljs-keyword">FROM</span> cte <span class="hljs-keyword">WHERE</span> n <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></div></td></tr></table></figure><h5 id="小-结-1">8.2.3 小 结</h5><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/Algorithm/Graph/"/>
    <url>/Algorithm/Graph/</url>
    
    <content type="html"><![CDATA[<h2 id="图论">图论</h2><h3 id="java实现c中的pair类">java实现c++中的Pair类</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PII</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;PII&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> first;<span class="hljs-comment">//距离值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> second;<span class="hljs-comment">//点编号</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.first;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSecond</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.second;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PII</span><span class="hljs-params">(<span class="hljs-type">int</span> first,<span class="hljs-type">int</span> second)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.second = second;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PII o)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(first, o.first);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="树与图的存储">树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。 对于无向图中的边<code>ab</code>，存储两条有向边<code>a-&gt;b</code>,<code>b-&gt;a</code>。 因此我们可以只考虑有向图的存储。</p><ol type="1"><li><p>邻接矩阵：<code>g[a][b]</code>存储边<code>a-&gt;b</code></p></li><li><p>邻接表（链式前向星）：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// N是节点最大数量，看题目所给范围；M=2*N：无向图边数开节点数2倍空间，有向图可开N</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>, M = <span class="hljs-number">2</span> * N;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M], w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M], ne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 加边，不带权</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 加边函数，带权</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 重要步骤，一定要在main()中初始化h[]为-1，表示每个节点当前为空链表</span><br>idx = <span class="hljs-number">0</span>;<br>Arrays.fill(h, -<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 遍历邻接表：节点u的所有邻边</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[u]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i]; <span class="hljs-comment">// j是u的一个邻边</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> w[i]; <span class="hljs-comment">// k是u-&gt;j的边权值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="树与图的遍历">树与图的遍历</h3><p><strong>时间复杂度 O(n+m), n 表示点数，m 表示边数</strong></p><p>(1)深度优先遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[u]; i != -<span class="hljs-number">1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) dfs(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(2)宽度优先遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 方式1：LinkedList集合实现队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">()</span> &#123;<br>    Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 表示1号点已经被遍历过</span><br>    q.offer(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.poll();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>                q.offer(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式2：数组模拟队列</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> hh, tt;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">()</span> &#123;<br>    hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d.length; i++) &#123;<br>        d[i] = -<span class="hljs-number">1</span>;<br>    &#125;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<span class="hljs-comment">// 判断对列是否为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[hh++]; <span class="hljs-comment">// 出队</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<span class="hljs-comment">// 遍历图中节点u的所有邻边</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == -<span class="hljs-number">1</span>) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                q[++tt] = j;<span class="hljs-comment">// 入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="拓扑排序">拓扑排序</h3><p>算法步骤：</p><ul><li>使用<code>d[N]</code>记录每个点的入度</li><li>第一步，将所有入度为<code>0</code>的点入队</li><li>第二步，循环判断队列是否为空，队列非空时，取出队头元素，将队头元素的邻边入度减<code>1</code>，如果为<code>0</code>，就将该邻点入队</li><li>第三步，按照出队顺序，即可输出拓扑排序的结果，如果出队元素数量小于结点总数，则拓扑序列不存在</li><li>拓扑排序结果不唯一</li><li>由于采用数组模拟队列，出队的元素仍按顺序保留在数组中，因此可直接输出整个数组得到拓扑序列</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-comment">// 记录入度</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-comment">// 数组模拟队列</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> hh, tt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">topsort</span><span class="hljs-params">()</span>&#123;<br>    hh = <span class="hljs-number">0</span> ; tt = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= n ; i ++ )&#123; <br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[hh++]; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t] ; i != -<span class="hljs-number">1</span>; i = ne[i])&#123; <br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            d[j] -- ;<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = j;<br>            &#125;       <br>        &#125;<br>    &#125;<br>    <span class="hljs-type">return</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span>= n - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果所有点都入队了，说明存在拓扑序列，否则不存在拓扑序列</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="最短路问题">最短路问题</h3><h4 id="朴素dijkstra算法">朴素Dijkstra算法</h4><p>适用于稠密图，时间复杂度<code>O(n^2)</code></p><p>图的存储：邻接矩阵</p><p>算法步骤：</p><ol type="1"><li>将<code>dist[i]</code>初始化为正无穷，起点的<code>dist</code>设置为0，同时，用集合<code>st</code>标记已经确定最短路的节点</li><li>迭代n次，每次先找出当前没有确定最短路的点（即<code>st[i]</code>为<code>false</code>）中距离起点最近（<code>dist[]</code>最小）的点，记为<code>t</code></li><li>随后，将<code>t</code>节点加入<code>st</code>集合中，并用它来更新别的点到起点的最短距离。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">510</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<span class="hljs-comment">// 存储每条边</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">//设置无穷大</span><br>    <span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span><br>    &#123;<br>        Arrays.fill(dist, INF);<br>        dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)<br>        &#123;<br>            <span class="hljs-comment">//1、找到当前未标记过且离源点最近的点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == -<span class="hljs-number">1</span> || dist[t] &gt; dist[j]))<br>                    t = j;<br>            &#125;<br>            <span class="hljs-comment">//2、标记该点已经确定最短距离</span><br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//3、用该点更新其他点的距离</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= n;j++)<br>            &#123;<br>                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(dist[n] == INF) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> dist[n];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] str1 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        n = Integer.parseInt(str1[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.parseInt(str1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++ )<br>             Arrays.fill(g[i], INF);<br>        <span class="hljs-keyword">while</span>(m -- &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            String[] str2 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">2</span>]);<br>            g[a][b] = Math.min(g[a][b], c);<span class="hljs-comment">//若有重边，选择最短的</span><br>        &#125;<br>        System.out.println(dijkstra());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="堆优化的dijkstra算法">堆优化的Dijkstra算法</h4><p>适用于稀疏图，时间复杂度<code>O(mlogn)</code>，是对朴素版的改进：找当前未加入<code>st</code>集合的点的最短距离的时候，取得堆顶而不是遍历数组查找。</p><p>图的存储：邻接表</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// PII(pair&lt;int,int&gt;)的定义见前文</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//维护当前未在st中标记过且离源点最近的点</span><br>    PriorityQueue&lt;PII&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;PII&gt;();<br>    Arrays.fill(dist, INF);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PII</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>    &#123;<br>        <span class="hljs-comment">//1、找到当前未在s中出现过且离源点最近的点</span><br>        <span class="hljs-type">PII</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> p.getSecond();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> p.getFirst();<br>        <span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//2、将该点进行标记</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//3、用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t];i != -<span class="hljs-number">1</span>;i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PII</span>(dist[j],j));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == INF) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="bellman-ford算法">Bellman-Ford算法</h4><ol type="1"><li><p>边的存储：自定义类Node</p></li><li><p>Bellman-Ford 算法是求<strong>含负权图的单源最短路径</strong>的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。 (通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)。</p></li><li><p>bellman - ford算法的具体步骤:</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> n次<br><span class="hljs-keyword">for</span> 所有边 a,b,w (松弛操作)<br>dist[b] = min(dist[b],back[a] + w)<br></code></pre></div></td></tr></table></figure><ol start="4" type="1"><li><p>注意：<code>back[]</code>数组是上一次迭代后<code>dist[]</code>数组的备份，由于是每个点同时向外出发，因此需要对 <code>dist[]</code>数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。</p></li><li><p>在下面代码中，是否能到达n号点的判断中需要进行<code>if(dist[n] &gt; INF/2)</code>判断，而并非是<code>if(dist[n] == INF)</code>判断，原因是<code>INF</code>是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，<code>dist[n]</code>大于某个与<code>INF</code>相同数量级的数即可。</p></li><li><p>bellman - ford算法擅长解决<strong>有边数限制</strong>的最短路问题，时间复杂度 <code>O(nm)</code>，其中n为点数，m为边数。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">510</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<span class="hljs-comment">//总点数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m;<span class="hljs-comment">//总边数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k;<span class="hljs-comment">//最多经过k条边</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">//从1到点到n号点的距离</span><br>    <span class="hljs-keyword">static</span> Node[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[M];<span class="hljs-comment">//结构体</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] back = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">//备份dist数组</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bellman_ford</span><span class="hljs-params">()</span><br>    &#123;<br>        Arrays.fill(dist, INF);<br><br>        dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k;i++)<br>        &#123;<br>            back = Arrays.copyOf(dist, n + <span class="hljs-number">1</span>);<span class="hljs-comment">//由于是从1开始存到n</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; m;j++)<br>            &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> list[j];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> node.a;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> node.b;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> node.c;<br>                dist[b] = Math.min(dist[b], back[a] + c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dist[n] &gt; INF/<span class="hljs-number">2</span>) System.out.println(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> System.out.println(dist[n]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] str1 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        n = Integer.parseInt(str1[<span class="hljs-number">0</span>]);<br>        m = Integer.parseInt(str1[<span class="hljs-number">1</span>]);<br>        k = Integer.parseInt(str1[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)<br>        &#123;<br>            String[] str2 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">2</span>]);<br>            list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a,b,c);<br>        &#125;<br>        bellman_ford();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="spfa算法">SPFA算法</h4><ol type="1"><li><p>SPFA 算法是 Bellman-Ford算法 的队列优化算法的别称，通常用于求<strong>含负权边的单源最短路径</strong>，以及判负权环。SPFA一般情况复杂度是<code>O(m)</code>最坏情况下复杂度和朴素 Bellman-Ford 相同，为<code>O(nm)</code>。</p><p><strong>bellman-ford算法操作如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> n次<br><span class="hljs-keyword">for</span> 所有边 a,b,w (松弛操作)<br>dist[b] = min(dist[b],back[a] + w)<br></code></pre></div></td></tr></table></figure><p>SPFA算法对第二行中所有边进行松弛操作进行了优化，原因是在Bellman-Ford算法中，即使该点的最短距离尚未更新过，但还是需要用尚未更新过的值去更新其他点，由此可知，该操作是不必要的，我们只需要找到更新过的值去更新其他点即可。</p></li><li><p>SPFA算法步骤</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">queue &lt;– <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> queue 不为空<br> (<span class="hljs-number">1</span>) t &lt;– 队头<br> queue.pop()<br>(<span class="hljs-number">2</span>)用 t 更新所有出边 t –&gt; b，权值为w<br> queue &lt;– b (若该点被更新过，则拿该点更新其他点)<br></code></pre></div></td></tr></table></figure></li><li><p>SPFA也能解决<strong>权值为正</strong>的图的最短距离问题，且一般情况下比Dijkstra算法还好</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br><span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] ne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N]; <span class="hljs-comment">// 存储每个点是否在队列中</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span><br>&#123;<br>    Arrays.fill(dist, INF);<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue.add(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记1号点在队列中</span><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.poll();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t];i != -<span class="hljs-number">1</span>;i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<span class="hljs-comment">// 获取点编号</span><br>            <span class="hljs-comment">// 若该点被更新过，则加入队列中</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-comment">// 判断该点是否已经在队列中</span><br>                <span class="hljs-keyword">if</span>(!st[j])<br>                &#123;<br>                    queue.add(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记已加入队列</span><br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="spfa判负环">SPFA判负环</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br> <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] ne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">// 记录虚拟点到x的最短距离</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">// 从虚拟点到x经过的边数 </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>    <span class="hljs-comment">// 将所有点进入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        queue.add(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.poll();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h[t]; i != -<span class="hljs-number">1</span>;i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>; <br><br>                <span class="hljs-keyword">if</span>(cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>                    queue.add(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="floyd算法">Floyd算法</h4><ul><li><p><code>f[i, j, k]</code>表示从<code>i</code>走到<code>j</code>的路径上除<code>i</code>和<code>j</code>点外只经过<code>1</code>到<code>k</code>的点的所有路径的最短距离。那么<code>f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]</code>。 因此在计算第<code>k</code>层的<code>f[i, j]</code>的时候必须先将第<code>k - 1</code>层的所有状态计算出来，所以需要把<code>k</code>放在最外层。</p></li><li><p>读入邻接矩阵，将次通过动态规划装换成从<code>i</code>到<code>j</code>的最短距离矩阵</p></li><li><p>在下面代码中，判断从<code>a</code>到<code>b</code>是否是无穷大距离时，需要进行<code>if(t &gt; INF/2)</code>判断，而并非是<code>if(t == INF)</code>判断，原因是<code>INF</code>是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，<code>t</code>大于某个与<code>INF</code>相同数量级的数即可。</p></li><li><p>时间复杂度<code>O(n^3)</code>，<code>n</code>表示点数</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> q;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">210</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;k &lt;= n;k++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= n;i++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= n;j++)<br>                    d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        String[] str1 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        n = Integer.parseInt(str1[<span class="hljs-number">0</span>]);<br>        m = Integer.parseInt(str1[<span class="hljs-number">1</span>]);<br>        q = Integer.parseInt(str1[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> d[i][j] = INF;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(m -- &gt; <span class="hljs-number">0</span>) &#123;<br>            String[] str2 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.parseInt(str2[<span class="hljs-number">2</span>]);<br>            d[a][b] = Math.min(d[a][b], c);<span class="hljs-comment">//若有重边选择短的边</span><br>        &#125;<br>        floyd();<br>        <span class="hljs-keyword">while</span>(q -- &gt; <span class="hljs-number">0</span>) &#123;<br>            String[] str3 = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str3[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(str3[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> d[a][b];<br>            <span class="hljs-keyword">if</span>(t &gt; INF / <span class="hljs-number">2</span>) System.out.println(<span class="hljs-string">&quot;impossible&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.println(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="最小生成树">最小生成树</h3><h4 id="prim算法">Prim算法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">朴素prim（解决稠密图），时间复杂度O(n^2 + m)，n为点数，m为边数</span><br><span class="hljs-comment">1. 初始化dist[i] = INF</span><br><span class="hljs-comment">    s:当前已经在连通块中的所有点</span><br><span class="hljs-comment">    2. for i in 1...n</span><br><span class="hljs-comment">        (1)t &lt;-- 找到集合外距离最近的点  总共O(n^2)次</span><br><span class="hljs-comment">        (2)s &lt;-- t对该点进行标志 总共O(n)次</span><br><span class="hljs-comment">        (3)用t更新其他点到集合的距离  总共O(n^2)级别次</span><br><span class="hljs-comment">    对于给定n个点，将所有点两两相连，总变数为m = n*(n-1)/2 </span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">510</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">//表示到集合的最短距离</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prim</span><span class="hljs-params">()</span> &#123;<br>    Arrays.fill(dist, INF);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == -<span class="hljs-number">1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-comment">//标记已加入集合</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) res += dist[t];<br>        <span class="hljs-comment">//用t更新其他点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= n;j++) dist[j] = Math.min(dist[j], g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="kruskal算法">Kruskal算法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Kruskal算法（解决稀疏图），时间复杂度是O(mlogm)，m为边数</span><br><span class="hljs-comment">    1. 将所有边按权重从小到大排序 共O(mlogm)次</span><br><span class="hljs-comment">    2. 枚举每条边a&lt;--&gt;b权重c 共O(m)次</span><br><span class="hljs-comment">    if a,b两点不通</span><br><span class="hljs-comment">            将a&lt;--&gt;b边加入集合中</span><br><span class="hljs-comment">注意：(1)2操作使用并查集</span><br><span class="hljs-comment"> (2)需要使用cnt来记录加进集合的边数，若cnt &lt; n-1，表示不能遍历所有点</span><br><span class="hljs-comment">*/</span>     <br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<span class="hljs-comment">// 并查集的父节点数组</span><br><span class="hljs-keyword">static</span> Edge[] edge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[M];<span class="hljs-comment">// 存储边</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-comment">// 并查集核心操作</span><br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(edge, <span class="hljs-number">0</span>, m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= n;i ++) p[i] = i; <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i ++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> edge[i].a;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> edge[i].b;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> edge[i].w;<br>        a = find(a);<br>        b = find(b);<br>        <span class="hljs-keyword">if</span>(a != b) &#123;<span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>            p[a] = b;<br>            res += w;<br>            cnt ++;<span class="hljs-comment">//计算边数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Edge&gt; &#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    Edge(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> w) &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.w = w;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Edge o)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(w, o.w);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级数据结构</title>
    <link href="/Algorithm/DataStructure/"/>
    <url>/Algorithm/DataStructure/</url>
    
    <content type="html"><![CDATA[<h3 id="并查集">并查集</h3><h4 id="基础并查集"><strong>1.基础并查集</strong></h4><p>参考题解:<a href="https://www.acwing.com/solution/content/33345/">AcWing 836. 基础_并查集_合并集合java_python_c++</a></p><p>基本操作：</p><ul><li>将两个集合合并</li><li>询问两个元素是否在一个集合中</li></ul><p>基本原理：每个集合用一棵树来表示。树的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示<code>x</code>的父节点</p><p>其他操作：</p><ul><li>判断树根 <code>if(p[x] = x)</code></li><li>求x的集合编号 <code>while(p[x] != x) x = p[x]</code></li><li>合并两个集合，这两将x的根节点嫁接到y的根节点, <code>px</code>为<code>x</code>的根节点， <code>py</code>为<code>y</code>的根节点，嫁接<code>p[px] = py</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;     <span class="hljs-comment">// 并查集节点数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];     <span class="hljs-comment">// p[]存储并查集祖宗节点编号</span><br><br><span class="hljs-comment">// 初始化并查集：最开始每个数各自在一个集合中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br><br><span class="hljs-comment">// 并查集查找+路径压缩</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 并查集合并操作：将a合并到b集合中</span><br>p[find(a)] = find(b);<br><br><span class="hljs-comment">// 判断a和b是否属于同一集合</span><br>find(a) == find(b);<br><br><span class="hljs-comment">// 其他路径压缩方法：</span><br><span class="hljs-comment">// 1.路径分裂：使路径上的每个节点都指向其祖父节点（parent的parent）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">while</span>(x != p[x])&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> p[x];<br>        p[x] = p[p[x]];<br>        x = parent;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// 2. 路径减半：使路径上每隔一个节点就指向其祖父节点（parent的parent）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">while</span>(x != p[x])&#123;<br>        p[x] = p[p[x]];<br>        x = p[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>面向对象java版UnionFind类(支持<strong>路径压缩</strong>和<strong>按秩合并</strong>)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] p;<br>    <span class="hljs-type">int</span>[] rank;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i] = i;<br>            rank[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x != p[x]) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-comment">// 按秩合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">px</span> <span class="hljs-operator">=</span> find(x);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">py</span> <span class="hljs-operator">=</span> find(y);<br>        <span class="hljs-keyword">if</span>(px == py) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(rank[px] &lt; rank[py]) p[px] = py;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[px] &gt; rank[py]) p[py] = px;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p[px] = py;<br>            rank[px] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断是否在同一集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(x) == find(y);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="并查集求连通块数量"><strong>2.并查集求连通块数量</strong></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] p, cnt;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">// 并查集祖宗节点数组</span><br>cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">// 并查集连通块大小</span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    p[i] = i;<br>    cnt[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 查询+路径压缩</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) &#123;<br>        p[x] = find(p[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并并查集，合并时更新连通块大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a), pb = find(b);<br>    <span class="hljs-keyword">if</span> (pa != pb) &#123;<br>        p[pb] = pa;<br>        cnt[pa] += cnt[pb];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断两个节点a和b是否在同一集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a), pb = find(b);<br>    <span class="hljs-type">return</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span>= pb;<br>&#125;<br><br><span class="hljs-comment">// 返回节点a所在集合（连通块）大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a);<br>    <span class="hljs-keyword">return</span> cnt[pa];<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="维护集合中每个节点到根节点距离"><strong>3.维护集合中每个节点到根节点距离</strong></h4><p>可用于求同一集合中任意两点的距离</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">30010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];        <span class="hljs-comment">// 每个节点的根节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];     <span class="hljs-comment">// 并查集中连通块大小</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];        <span class="hljs-comment">// 每个节点到根节点的距离</span><br><br><span class="hljs-comment">// main()中初始化并查集</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 查找</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> find(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> find(b);<br>    <span class="hljs-keyword">if</span>(pa == pb) <span class="hljs-keyword">return</span>;<br>    p[pa] = pb;<br>    d[pa] = size[pb];<br>    size[pb] += size[pa];<br>&#125;<br><br><span class="hljs-comment">// main()中求距离</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a), pb = find(b);<br><span class="hljs-keyword">if</span>(pa == pb) out.println(Math.max(<span class="hljs-number">0</span>, Math.abs(d[a] - d[b]) - <span class="hljs-number">1</span>));<br><span class="hljs-keyword">else</span> out.println(<span class="hljs-string">&quot;-1&quot;</span>);<br></code></pre></div></td></tr></table></figure><h4 id="带权并查集"><strong>4.带权并查集</strong></h4><ul><li>力扣<a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></li><li><a href="https://www.acwing.com/activity/content/problem/content/1582/">AcWing 239. 奇偶游戏</a></li></ul><h4 id="扩展域种类并查集"><strong>5.扩展域(种类)并查集</strong></h4><ul><li>题目：POJ<a href="http://poj.org/problem?id=1182">食物链</a> 题解：<a href="https://www.cnblogs.com/wkfvawl/p/9726554.html">食物链 POJ 1182（种类并查集）</a></li><li><a href="https://www.acwing.com/activity/content/problem/content/1582/">AcWing 239. 奇偶游戏</a></li></ul><h3 id="trie树">Trie树</h3><h4 id="数组模拟trie树">1.数组模拟Trie树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.math.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(son[p][u] == <span class="hljs-number">0</span>) son[p][u] = ++idx;<br>            p = son[p][u];<br>        &#125;<br>        cnt[p]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(son[p][u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            p = son[p][u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt[p];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(in.readLine());<br>        <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>) &#123;<br>            String[] str = in.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;I&quot;</span>)) insert(str[<span class="hljs-number">1</span>].toCharArray());<br>            <span class="hljs-keyword">else</span> out.println(query(str[<span class="hljs-number">1</span>].toCharArray()));<br>        &#125;<br>        out.close();<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="面向对象实现trie类">2.面向对象实现Trie类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;<br>            String[] s = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> s[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;I&quot;</span>)) &#123;<br>                trie.insert(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(trie.query(str));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// Trie节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-type">char</span> value;<br>    TrieNode[] son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br><br>    TrieNode(<span class="hljs-type">char</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">haveSon</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> son[c - <span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Trie树：支持插入和查询</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    TrieNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (!cur.haveSon(c)) &#123;<br>                cur.son[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>(c);<br>            &#125;<br>            cur = cur.son[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur.cnt++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (!cur.haveSon(c)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.son[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.cnt;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="树状数组">树状数组</h3><h4 id="问题">问题</h4><p>给出一个长度为 <span class="math inline">\(n\)</span> 的数组，完成以下两种操作：</p><ol type="1"><li>将第 <span class="math inline">\(i\)</span> 个数加上 <span class="math inline">\(k\)</span></li><li>输出区间 <span class="math inline">\([i,j]\)</span> 内每个数的和</li></ol><h4 id="lowbit运算">lowbit运算</h4><p>定义：非负整数 <span class="math inline">\(x\)</span> 在二进制表示下<strong>最低位1及其后面的0</strong>构成的数值。</p><p>例如：<span class="math inline">\(lowbit(12)=lowbit([1100]_2)=[100]_2=4\)</span></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="思想">思想</h4><p>树状数组基于二进制的原理，基本用途是维护序列的前缀和。对于给定的序列 <span class="math inline">\(a\)</span>，建立一个数组 <span class="math inline">\(tr\)</span>，其中 <span class="math inline">\(tr[x]\)</span> 保存序列 <span class="math inline">\(a\)</span> 的区间 <span class="math inline">\([x-lowbit(x)+1, x]\)</span> 中所有数的和，即 <span class="math inline">\(\sum_{i=x-lowbit(x)+1}^{x}a[i]\)</span>。</p><p>树状数组满足如下几个性质：</p><div class="hljs code-wrapper"><pre><code class="hljs">1. 每个内部节点 $tr[x]$ 保存以它为根的子树中所有叶节点的和。2. 每个内部节点 $tr[x]$ 的子节点个数等于 $lowbit(x)$ 的位数。3. 除根节点外，每个内部节点 $tr[x]$ 的父节点是  $tr[x+lowbit(x)]$ 。4. 树的深度是$O(logn)$。</code></pre></div><h4 id="操作">操作</h4><ul><li>单点修改：<span class="math inline">\(O(logn)\)</span></li></ul><p>给序列中的一个数 <span class="math inline">\(a[x]\)</span> 加上 <span class="math inline">\(y\)</span>，同时正确维护序列的前缀和。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-comment">// 树状数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) &#123;<br>        tr[i] += k;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>区间查询：<span class="math inline">\(O(logn)\)</span></li></ul><p>返回序列 <span class="math inline">\(a\)</span> 的第 <span class="math inline">\(1\sim x\)</span> 个数的和。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) &#123;<br>        res += tr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="初始化">初始化</h4><p>在执行所有操作之前，需要对树状数组进行初始化——针对原始序列 <span class="math inline">\(a\)</span> 构造一个树状数组。为了简便，一般方法是：直接建立一个全为0的数组 <span class="math inline">\(c\)</span>，然后对每个位置 <span class="math inline">\(x\)</span> 执行 <code>add(x,a[x])​</code>，就完成了对原始序列 <span class="math inline">\(a\)</span> 构造树状数组的过程，时间复杂度是<span class="math inline">\(O(nlogn)\)</span>。通常采用这种初始化方式已经足够。</p><h4 id="应用之求逆序对数量">应用之求逆序对数量</h4><p>任意给定一个集合<span class="math inline">\(a\)</span>，如果用 <span class="math inline">\(t[val]\)</span> 保存数值 <span class="math inline">\(val\)</span> 在集合中出现的次数，那么数组 <span class="math inline">\(t\)</span> 在 <span class="math inline">\([l,r]\)</span> 上的区间和（即<span class="math inline">\(\sum_{i=l}^{r}t[i]\)</span>）就表示集合 <span class="math inline">\(a\)</span> 中范围在 <span class="math inline">\([l,r]\)</span> 内的数有多少个。</p><p>可以在集合 <span class="math inline">\(a\)</span> 的<strong>数值范围</strong>上建立一个树状数组，来维护 <span class="math inline">\(t\)</span> 的前缀和。这样即使在集合 <span class="math inline">\(a\)</span> 中插入或删除一个数，也可以高效地进行统计。</p><p>前面提出过用归并排序解决逆序对问题：对于一个序列 <span class="math inline">\(a\)</span>，如果<span class="math inline">\(i&lt;j\)</span>，且 <span class="math inline">\(a[i]&gt;a[j]\)</span>，则称 <span class="math inline">\(a[i]\)</span> 与 <span class="math inline">\(a[j]\)</span> 构成逆序对。按照上述思路，利用树状数组也可以求出一个序列的逆序对个数：</p><ol type="1"><li><p>在序列a的数值范围上建立树状数组，初始化为全零。</p></li><li><p>倒序扫描给定的序列 <span class="math inline">\(a\)</span>，对于每个数 <span class="math inline">\(a[i]\)</span>：</p><ol type="1"><li><p>在树状数组中查询前缀和 <span class="math inline">\([1, a[i]-1]\)</span>，累加到答案<code>ans</code>中。</p></li><li><p>执行“单点增加”操作，即把位置 <span class="math inline">\(a[i]\)</span>上的数加 <span class="math inline">\(1\)</span>（相当于<code>t[a[i]]++</code>），同时正确维护<code>t</code>的前缀和。</p></li></ol></li><li><p><code>ans</code>即为所求。</p></li></ol><p>时间复杂度为<span class="math inline">\(O(N+MlogM)\)</span>，<code>M</code>为数值范围的大小。当数值范围较大时，可以先进行<strong>离散化</strong>，再用树状数组计算。但因为离散化本身需要通过排序实现，所以这种情况下不如直接用归并排序方式求解。</p><h3 id="线段树">线段树</h3><h4 id="操作-1"><strong>操作</strong></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//传入节点编号，用子节点信息来算父节点信息</span><br>pushu(<span class="hljs-type">int</span> u)<br><br><span class="hljs-comment">//将一段区间初始化为一颗线段树</span><br>build()<br><br><span class="hljs-comment">//修改操作,修改某一个点或者某一个区间（懒标记）</span><br>modify()<br><br><span class="hljs-comment">//查询某一段区间的信息</span><br>query()<br></code></pre></div></td></tr></table></figure><h4 id="线段树维护区间最大值案例"><strong>线段树维护区间最大值案例</strong></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 结构：一般使用类来存储线段树,空间大小开四倍</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> l;<span class="hljs-comment">//维护的区间左端点</span><br>    <span class="hljs-type">int</span> r;<span class="hljs-comment">//维护的区间右端点</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//维护的信息，以最大值为例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-built_in">this</span>.l = l;<br>        <span class="hljs-built_in">this</span>.r = r;<br>        <span class="hljs-built_in">this</span>.v = v;     <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m, p;<br>    <span class="hljs-keyword">static</span> Node[] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[N * <span class="hljs-number">4</span>];<span class="hljs-comment">// 线段树空间大小开四倍</span><br>    <br>    <span class="hljs-comment">// 建树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        tr[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        tr[u]. l = l; tr[u].r = r;<br>        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        build(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>        build(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br><br>    <span class="hljs-comment">// pushup操作,用子节点信息来更新父节点信息,以维护最大值为例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>        tr[u].v = Math.max(tr[u &lt;&lt; <span class="hljs-number">1</span>].v, tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].v);<br>    &#125;<br><br>    <span class="hljs-comment">// 查询操作，用来查询某一段区间内的信息,以最大值为例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].v;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(l &lt;= mid) v = query(u &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>        <span class="hljs-keyword">if</span>(r &gt; mid) v = Math.max(v, query(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r));<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;<br><br>    <span class="hljs-comment">// 修改操作，用来修改某一叶子节点并更新其所有父节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(x &lt;= mid) modify(u &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>            <span class="hljs-keyword">else</span> modify(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>            pushup(u);<span class="hljs-comment">// 修改后一定要向上更新最大值</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>       m = in.nextInt();<br>       p = in.nextInt();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>       build(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m);<span class="hljs-comment">// 建树</span><br>       <br>        <span class="hljs-keyword">while</span>(m-- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> in.next();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-keyword">if</span>(op.equals(<span class="hljs-string">&quot;Q&quot;</span>)) &#123;<br>                last = query(<span class="hljs-number">1</span>, n - x + <span class="hljs-number">1</span>, n);<br>                System.out.println(last);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                modify(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>)x + last) % p));<br>                n++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="总结"><strong>总结</strong></h4><ul><li>区间和问题解决方案的选择：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">关于各类「区间和」问题如何选择解决方案</a></li><li>树状数组、线段树、平衡树总结：<a href="https://leetcode-cn.com/problems/count-of-range-sum/solution/xian-ren-zhi-lu-ru-he-xue-xi-ke-yi-jie-jue-ben-ti-/">【仙人指路】如何学习可以解决本题的算法与数据结构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/Algorithm/Base/"/>
    <url>/Algorithm/Base/</url>
    
    <content type="html"><![CDATA[<h3 id="排序">排序</h3><h4 id="java数组排序">1.Java数组排序</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 从0到最后一位排序，默认升序</span><br>Arrays.sort(q);<br><span class="hljs-comment">// 指定范围排序[1,5)</span><br>Arrays.sort(q, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 从1到n排序，使用lambda表达式自定义排序规则：从大到小</span><br><span class="hljs-comment">// 使用Integer.compare()方法时，数组必须是Integer[]</span><br>Arrays.sort(q, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, (a, b) -&gt; Integer.compare(b, a));<br><span class="hljs-comment">// 使用Collections.reverseOrder()实现降序</span><br>Arrays.sort(q, Collections.reverseOrder());<br></code></pre></div></td></tr></table></figure><h4 id="list集合排序">2.List集合排序</h4><h4 id="快速排序">快速排序</h4><p>步骤：</p><ol type="1"><li><p>确定分界点，把数组分成两部分。 常用的分界点有 数组第一个数，数组最后一个数，数组中间那个数 一般我会选用数组中间那个数作为分界点，这样后面的写法也固定了，不容易遇到边界问题。</p></li><li><p>根据分界点调整数组，使得分界点左边的数都小于等于分界点，分界点右边的数都大于等于分界点 方法：利用双指针的移动，左指针在左边大于分界点的数停下，右指针在右边小于分界点的数停下，交换这两个数。</p></li><li><p>分别递归处理左右两边。</p></li><li><p>时间复杂度为O(nlogn)。</p></li></ol><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;                  <span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>;                      <span class="hljs-comment">//左边的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> r + <span class="hljs-number">1</span>;                      <span class="hljs-comment">//右边的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>)];    <span class="hljs-comment">//选取数组中间的那个数作为分界点，把数组分成两部分</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i++;<br>        &#125;<span class="hljs-keyword">while</span>(arr[i] &lt; x);             <span class="hljs-comment">//在左边大于分界点的数停下</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            j--;<br>        &#125;<span class="hljs-keyword">while</span>(arr[j] &gt; x);             <span class="hljs-comment">//在右边小于分界点的数停下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;                      <span class="hljs-comment">//交换两个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    quickSort(arr,l,j);                 <span class="hljs-comment">//递归处理左边</span><br>    quickSort(arr,j+<span class="hljs-number">1</span>,r);               <span class="hljs-comment">//递归处理右边</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="归并排序">归并排序</h4><p>步骤：</p><ol type="1"><li>将数组平均分成两部分（奇数个数的话就是一个为n/2个，一个为n/2+1个）。</li><li>分别递归地排序数组的这两部分。</li><li>将排好序的两部分归并成一整块。 方法：利用双指针的移动，将两部分中更小的那个数存到临时存储数组中。</li><li>时间复杂度为O(nlogn)。</li></ol><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;                      <span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l)/<span class="hljs-number">2</span>;                <span class="hljs-comment">//将数组分成[L,mid] 和 [mid+1,R] 两部分</span><br>    mergeSort(arr,l,mid);                   <span class="hljs-comment">//递归排序左半部分</span><br>    mergeSort(arr,mid+<span class="hljs-number">1</span>,r);                 <span class="hljs-comment">//递归排序右半部分</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;                              <span class="hljs-comment">//左半部分的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;                        <span class="hljs-comment">//右半部分的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">//临时存储数组的索引</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;              <span class="hljs-comment">//循环找到两部分中更小的那个数</span><br>        <span class="hljs-keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">else</span> temp[k++] = arr[j++];          <span class="hljs-comment">//temp为临时存储数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = arr[i++];   <span class="hljs-comment">//把左半部分没存入的数存到临时存储数组中</span><br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = arr[j++];     <span class="hljs-comment">//把右半部分没存入的数存到临时存储数组中</span><br>    <span class="hljs-keyword">for</span>(i = l,j = <span class="hljs-number">0</span>; i &lt;= r; i++,j++)&#123;      <span class="hljs-comment">//将临时存储数组中排好序的数复制到原数组中</span><br>        arr[i] = temp[j];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="堆排序">堆排序</h4><p><strong>思路</strong>：首先建立一个堆，从n/2位置开始，不断的down直到1，构造一个小顶堆，每一次输出堆中第一个元素，然后将第一个元素与最后一个元素进行交换，删掉最后一个元素，再次维护堆就可以了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-comment">// 向下调整</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">while</span>(pos &lt;= n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> pos;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> pos &lt;&lt; <span class="hljs-number">1</span>, right = pos &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(left &lt;= n &amp;&amp; q[left] &lt; q[temp]) temp = left;<br>        <span class="hljs-keyword">if</span>(right &lt;= n &amp;&amp; q[right] &lt; q[temp]) temp = right;<br>        <span class="hljs-keyword">if</span>(temp == pos) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[temp];<br>        q[temp] = q[pos];<br>        q[pos] = t;<br>        pos = temp;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">// 建堆</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n &gt;&gt; <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) downHeap(i, n);<br></code></pre></div></td></tr></table></figure><h3 id="二分">二分</h3><p>二分就是把区间划分成两部分，我把这两部分分别记为left 和 right。满足left就一定不满足right，满足right就一定不满足left。</p><h4 id="整数二分">整数二分：</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//check(mid)是对mid处的数进行判断。</span><br><span class="hljs-comment">//若符合right，答案就在left。即binarySearch1</span><br><span class="hljs-comment">//若符合left，答案就在right。即binarySearch2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;      <br>        <span class="hljs-keyword">if</span>(check(mid)) r = mid;        <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;               <br>    &#125;<br>    <span class="hljs-keyword">return</span> l;                          <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid;         <br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;               <br>    &#125;<br>    <span class="hljs-keyword">return</span> l;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="实数二分">实数二分</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-title function_">binarySearch3</span><span class="hljs-params">(<span class="hljs-type">double</span> l,<span class="hljs-type">double</span> r)</span>&#123;<br>    <span class="hljs-type">double</span> eps;<span class="hljs-comment">//根据题目设置精度，一般是题目精度的1e-2倍</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; eps)&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="前缀和与差分">前缀和与差分</h3><h4 id="一维前缀和">一维前缀和</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h4 id="二维前缀和">二维前缀和</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[][] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 预处理：S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= n  ; i ++ )&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;j &lt;= m ; j ++ )&#123;<br>        S[i][j] = S[i-<span class="hljs-number">1</span>][j] + S[i][j-<span class="hljs-number">1</span>] - S[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + a[i][j];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h4 id="一维差分">一维差分</h4><p><strong>差分定义</strong>：差分是求前缀和的逆操作，对于原数组<code>a[n]</code>,构造出一个数组<code>b[n]</code>,使<code>a[n]</code>为<code>b[n]</code>的前缀和。一般用于快速对整个数组进行操作，比如对将<code>a</code>数组中<code>[l,r]</code>部分的数据全部加上<code>c</code>，使用差分算法可以将时间复杂度从<span class="math inline">\(O(n)\)</span>降低到<span class="math inline">\(O(1)\)</span>。</p><p><strong>差分操作</strong>：给区间<code>[l, r]</code>中的每个数加上<code>c</code>：<code>B[l] += c, B[r + 1] -= c</code></p><p><strong>差分构造</strong>：给差分数组<code>b[n]</code>每个位置做一次插入操作，<code>insert(b, i, i, a[i]);</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//a为原数组，b为差分数组</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><br><span class="hljs-comment">//插入操作函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] b, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    b[l] += c;<br>    b[r+<span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-comment">// main()中进行如下操作</span><br><span class="hljs-comment">// 初始化差分数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>    insert(b, i, i, a[i]);          <br>&#125;<br><span class="hljs-comment">// 进行若干次插入</span><br><span class="hljs-keyword">while</span>(m--&gt;<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> l, r, c;<br>    l = scanner.nextInt();<br>    r = scanner.nextInt();<br>    c = scanner.nextInt();<br>    insert(b, l, r, c);<br>&#125;<br><span class="hljs-comment">// 求一遍前缀和，即可得a[]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) b[i] += b[i-<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><h4 id="二维差分">二维差分</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>;<br><span class="hljs-comment">//a为原数组，b为差分数组</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> &#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-comment">// 二维差分数组初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        insert(i, j, i, j, a[i][j]);<br><br><span class="hljs-comment">// 进行若干次插入</span><br><span class="hljs-keyword">while</span>(q-- &gt; <span class="hljs-number">0</span>) &#123;<br>    str = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> Integer.parseInt(str[<span class="hljs-number">0</span>]), y1 = Integer.parseInt(str[<span class="hljs-number">1</span>]), x2 = Integer.parseInt(str[<span class="hljs-number">2</span>]), y2 = Integer.parseInt(str[<span class="hljs-number">3</span>]), c = Integer.parseInt(str[<span class="hljs-number">4</span>]);<br>    insert(x1, y1, x2, y2, c);<br>&#125;<br><br><span class="hljs-comment">// 对差分数组求二维前缀和，可得原数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        System.out.println(b[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="栈">栈</h3><p>java容器类推荐Deque而不是Stack实现的栈：参考文章<a href="https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg">Java为什么使用Deque实现Stack</a></p><ol type="1"><li><p>Stack的入栈和出栈的操作：</p><ul><li>把元素压栈：push(E)；</li><li>把栈顶的元素“弹出”：pop(E)；</li><li>取栈顶元素但不弹出：peek(E)。</li></ul></li><li><p>在Java中，我们用Deque可以实现Stack的功能：</p><ul><li>把元素压栈：push(E)/addFirst(E)；</li><li>把栈顶的元素“弹出”：pop(E)/removeFirst()；</li><li>取栈顶元素但不弹出：peek(E)/peekFirst()。</li></ul><table><thead><tr class="header"><th style="text-align: left;">运作方式</th><th style="text-align: left;">头部</th><th style="text-align: left;">尾部</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"><strong>引发异常</strong></td><td style="text-align: left;"><strong>返回特殊值</strong></td><td><strong>引发异常</strong></td><td><strong>返回特殊值</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>插入</strong></td><td style="text-align: left;"><em>无效addFirst（e）</em></td><td style="text-align: left;"><em>boolean offerFirst（e）</em></td><td><em>无效addLast（e）</em></td><td><em>boolean offerLast（e）</em></td></tr><tr class="odd"><td style="text-align: left;"><strong>恢复</strong></td><td style="text-align: left;"><em>E getFirst（）</em></td><td style="text-align: left;"><em>E peekFirst（）</em></td><td><em>E getLast（）</em></td><td><em>E peekLast（）</em></td></tr><tr class="even"><td style="text-align: left;"><strong>删除/删除</strong></td><td style="text-align: left;"><em>E removeFirst（）</em></td><td style="text-align: left;"><em>E pollFirst（）</em></td><td><em>E removeLast（）</em></td><td><em>E pollLast（）</em></td></tr></tbody></table></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">void push（E e）：将元素压入双端队列的堆栈表示的顶部</span><br><span class="hljs-comment">E pop（）：在双端队列的堆栈表示顶部弹出一个元素</span><br><span class="hljs-comment">boolean isEmpty（）：对于空的双端队列返回true</span><br><span class="hljs-comment">int size（）：返回双端队列所包含的元素数</span><br><span class="hljs-comment">boolean contains（Object obj）：如果给定对象存在于双端队列中，则返回true</span><br><span class="hljs-comment">void clear（）：删除所有双端队列元素</span><br><span class="hljs-comment">E remove（）：返回并删除head元素</span><br><span class="hljs-comment">boolean removeFirstOccurrence（E e）：从头到尾遍历双端队列，并删除指定元素的第一次出现</span><br><span class="hljs-comment">boolean removeLastOccurrence（E e）：删除指定元素的最后一次出现</span><br><span class="hljs-comment">*/</span><br><br><br>Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br><span class="hljs-comment">// 已弃用</span><br>Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br></code></pre></div></td></tr></table></figure><h3 id="队列">队列</h3><p>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br><span class="hljs-comment">// add()和remove()方法在失败的时候会抛出异常(不推荐)</span><br>queue.offer(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 入队</span><br><span class="hljs-type">var</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// 返回第一个元素，并在队列中删除,队列为空时返回null</span><br>str = queue.peek();<span class="hljs-comment">// 返回第一个元素</span><br><span class="hljs-comment">// str = queue.element();// 返回第一个元素，不存在则抛出异常</span><br><span class="hljs-type">var</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<span class="hljs-comment">// 返回队列大小</span><br><span class="hljs-type">var</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> queue.isEmpty(); <span class="hljs-comment">// 判空</span><br></code></pre></div></td></tr></table></figure><h3 id="单调队列">单调队列</h3><h3 id="单调栈">单调栈</h3><h3 id="位运算">位运算</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：lowbit(n) = n &amp; -n<br></code></pre></div></td></tr></table></figure><h3 id="双指针算法"><strong>双指针算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></div></td></tr></table></figure><h3 id="高精度">高精度</h3><h4 id="biginteger类">BigInteger类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//对于大数，Java可以轻松解决，因为在Java中,math包下有BigInteger这个类</span><br><span class="hljs-comment">//构造器：new BigInteger(String s);</span><br><br><span class="hljs-comment">// BigInteger a;</span><br><span class="hljs-comment">// BigInteger b;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">加法：a.add(b)</span><br><span class="hljs-comment">减法：a.subtract(b)</span><br><span class="hljs-comment">乘法：a.multiply(b)</span><br><span class="hljs-comment">除法：a.divide(b)</span><br><span class="hljs-comment">取余：a.mod(b)</span><br><span class="hljs-comment">比较：a.compareTo(b)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h4 id="高精度加法"><strong>高精度加法</strong></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B )</span> &#123;<br>        <span class="hljs-keyword">if</span> (A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.size(); i ++ ) &#123;<br>            t += A.get(i);<br>            <span class="hljs-keyword">if</span> (i &lt; B.size()) t += B.get(i);<br>            C.add(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>) C.add(t);<br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scan.next();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scan.next();<br><br>        List&lt;Integer&gt; A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        List&lt;Integer&gt; B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.add(a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.add(b.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>        List&lt;Integer&gt; C = add(A, B);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) System.out.print((C.get(i)));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="高精度减法">高精度减法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">sub</span><span class="hljs-params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!cmp(A,B))&#123;<br>            <span class="hljs-keyword">return</span> sub(B,A);<br>        &#125;<br><br>        List&lt;Integer&gt; C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; A.size();i ++)&#123;<br>            t = A.get(i) - t;<br>            <span class="hljs-keyword">if</span>(i &lt; B.size()) t -= B.get(i);<br>            C.add((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br><br>            <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.get(C.size() - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)  C.remove(C.size() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> A.size() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>            <span class="hljs-keyword">if</span>(A.get(i) != B.get(i)) &#123;<br>                <span class="hljs-keyword">return</span> A.get(i) &gt; B.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> in.next();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> in.next();<br>        List&lt;Integer&gt; A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s1.length() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) A.add(s1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s2.length() - <span class="hljs-number">1</span>;i  &gt;= <span class="hljs-number">0</span>; i --) B.add(s2.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">if</span>(!cmp(A,B))&#123;<br>            System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>        &#125;<br>        List&lt;Integer&gt; C = sub(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> C.size() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>            System.out.print(C.get(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="高精度乘低精度">高精度乘低精度</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">mul</span><span class="hljs-params">(List&lt;Integer&gt; A, <span class="hljs-type">int</span> B)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; A.size();i++)<br>        &#123;<br>            t += A.get(i) * B;<br>            C.add(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(t != <span class="hljs-number">0</span>)<br>        &#123;<br>            C.add(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-comment">// 去除多余的前缀0</span><br>        <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.get(C.size() - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) C.remove(C.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.next();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> in.nextInt();<br><br>        List&lt;Integer&gt; A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.add(a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        List&lt;Integer&gt; C = mul(A, B);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) System.out.print((C.get(i)));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="高精度除以低精度">高精度除以低精度</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">div</span><span class="hljs-params">(List&lt;Integer&gt; A,<span class="hljs-type">int</span> b)</span>&#123;<br>        List&lt;Integer&gt; C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> A.size() - <span class="hljs-number">1</span> ;i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br>            r = r * <span class="hljs-number">10</span> + A.get(i);<br>            C.add(r / b);<br>            r %= b;<br>        &#125;<br>        Collections.reverse(C);<br>        <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.get(C.size() - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) C.remove(C.size() - <span class="hljs-number">1</span>);<br><br>        C.add(r);<br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] arg)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.next();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextInt();<br>        List&lt;Integer&gt; A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a.length());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) A.add(a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        List&lt;Integer&gt; C = div(A,b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> C.size() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i --) System.out.print(C.get(i));<br><br>        System.out.println();<br>        System.out.print(C.get(C.size() - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="离散化">离散化</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; alls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储所有待离散化的值</span><br>Collections.sort(alls);   <span class="hljs-comment">// 排序</span><br><span class="hljs-type">int</span> <span class="hljs-variable">unique</span> <span class="hljs-operator">=</span> unique(alls);  <span class="hljs-comment">// 去重</span><br>alls = alls.subList(<span class="hljs-number">0</span>,unique);  <span class="hljs-comment">// 将去重之后的alls的长度范围中的值重新赋值给alls集合中。</span><br><br><span class="hljs-comment">//去重 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">unique</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt;= list.size() - <span class="hljs-number">1</span>; i ++ )&#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || list.get(i) != list.get(i-<span class="hljs-number">1</span>))&#123;<br>            list.set(j,list.get(i));<br>            j ++ ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回去重后的第一个重复元素的下标</span><br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br> <span class="hljs-comment">// 二分查找</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x, List&lt;Integer&gt; list)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ( l + r )/ <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(list.get(mid) &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + GitHub搭建博客</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo">Hexo</h3><p><a href="https://hexo.io/zh-cn/">Hexo</a>是一款快速、简洁且高效的博客框架，有如下特点：</p><ul><li><strong>超快速度</strong>：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li><li><strong>支持 Markdown</strong>：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li><li><strong>一键部署</strong>：只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</li><li><strong>插件和可扩展性</strong>：强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></div></td></tr></table></figure><p>环境准备：Node.js, git, npm, nvm(非必须)。</p><p>操作文档参考：<a href="https://hexo.io/zh-cn/docs/">文档</a></p><p>官方收录主题：<a href="https://hexo.io/themes/">主题</a></p><p>本博客使用主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></p><p>一键部署：<a href="https://hexo.io/zh-cn/docs/one-command-deployment">部署</a></p><h3 id="fluid-主题">Fluid 主题</h3><p>官方手册：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p><h3 id="发布文章">发布文章</h3><ol type="1"><li><p>进入博客站点文件夹，使用<code>cmd</code>命令执行：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">// hexo new [page] -p 文件保存路径 <span class="hljs-string">&quot;title&quot;</span><br>hexo new page --path Algorithm/Graph <span class="hljs-string">&quot;图论&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在<code>站点目录\source\_posts</code>中生成的<code>xxx.md</code>文件里编辑文章内容。</p></li><li><p>[可选]执行下一步前，可先执行<code>hexo clean</code>，清空生成的文件夹<code>public</code></p></li><li><p>执行生成命令<code>hexo g</code>，将<code>*.md</code>转为静态文件<code>*.html</code>。</p></li><li><p>执行<code>hexo s</code>，启动本地服务，浏览器输入<code>localhost:4000</code>，查看生成效果。</p></li><li><p>执行部署命令<code>hexo d</code>，将新发布的文章部署到<code>github.io</code>上</p></li></ol><h3 id="hexo-优化">Hexo 优化</h3><h4 id="网站图片加速">网站图片加速</h4><p>jsDelivr 加速 + Github图床 + PicGo上传</p><p>可参考<a href="https://www.erenship.com/posts/db37.html">Hexo 博客站点加速不完全指南</a></p><h4 id="版权声明优化">版权声明优化</h4><p><a href="https://blog.csdn.net/qq_36852780/article/details/120943120">参考博客</a></p><p>在<code>blog\node_modules\hexo-theme-fluid\layout</code>路径下找到<code>post.ejs</code>文件，打开后搜索<code>copyright</code>, 增加如下代码即可修改版权声明信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if(theme.post.copyright.enable &amp;&amp; theme.post.copyright.content &amp;&amp; page.copyright !== false) &#123; %&gt;<br>    &lt;p class=&quot;note note-warning&quot;&gt;<br>         &lt;strong&gt;本文作者: &lt;/strong&gt;&lt;a href=&quot;&lt;%- url_for() %&gt;&quot;&gt;&lt;%- theme.about.name || config.author || config.title %&gt;&lt;/a&gt; &lt;br&gt;<br>         &lt;strong&gt;本文链接: &lt;/strong&gt;&lt;a href=&quot;&lt;%- full_url_for(page.path) %&gt;&quot;&gt;&lt;%-   full_url_for(page.path) %&gt;&lt;/a&gt; &lt;br&gt;<br>         &lt;strong&gt;版权声明: &lt;/strong&gt;&lt;%- theme.post.copyright.content %&gt;<br>    &lt;/p&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure><h4 id="文字复制时添加版权声明">文字复制时添加版权声明</h4><p><a href="https://blog.csdn.net/qq_33430083/article/details/105626840">参考文章：新手如何给Hexo博客在复制时添加版权声明</a></p><h5 id="确认需要版权声明的位置">确认需要版权声明的位置</h5><p>Fluid主题文章主体内容在<code>&lt;div class="container-fluid nopadding-x"&gt;</code>标签中</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Hexo_1.png" alt="找到Hexo文章主题内容所在标签class名称" /><figcaption aria-hidden="true">找到Hexo文章主题内容所在标签class名称</figcaption></figure><h5 id="设置只有在非转载文章才会有添加版权声明">设置只有在非转载文章才会有添加版权声明</h5><p>在需要复制时加版权声明的文章的<code>Front-matter</code>部分加上<code>copyable: true</code>即可</p><figure><img src="https://cdn.jsdelivr.net/gh/Xylitol415/Hexo_Blog_Pictures/img/Hexo_2.png" alt="文章头部加上copyable属性" /><figcaption aria-hidden="true">文章头部加上copyable属性</figcaption></figure><p>为了避免每次都加上<code>copyable</code>，可以设置新建文章时<code>Front-matter</code>的固定格式，带上<code>copyable: true</code>属性。</p><h5 id="编写版权声明的js">编写版权声明的js</h5><p>将监听博客详情页的复制事件的js代码放在<code>post.ejs</code>文件最后，可以通过设置<code>len</code>的大小度来改变粘贴板中字符的长度限制，复制超过len的大小文字内容时，就会在末尾追加上版权声明的信息，比如我这里设置<code>len</code>不超过<code>120</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (page.copyable) &#123; %&gt;<br>      &lt;script&gt;<br>          function setClipboardText(event)&#123;<br>              // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容<br>              let clipboardData = event.clipboardData || window.clipboardData;<br>              // 如果未复制或者未剪切，则return出去<br>              if (!clipboardData) &#123; return; &#125;<br>              event.preventDefault();<br>              // Selection 对象，表示用户选择的文本范围或光标的当前位置。<br>              //     声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串<br>              let text = window.getSelection().toString();<br>  let len = text.length;<br>  <br>// 复制文字超过120个就加上版权信息<br>              if (len &gt;= 120) &#123;<br>                // 如果文本存在则先取消文本默认事件<br>                event.preventDefault();<br>                // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本<br>                // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。<br>                // data: 一个 DOMString表示要添加到 drag object的数据。<br>                var copyright = &#x27;\n\n&#x27;<br>+ &#x27;------------------------------------------------------&#x27;<br>                                + &#x27;\n著作权归作者所有。&#x27;<br>                                + &#x27;\n商业转载请联系作者获得授权，非商业转载请注明出处。&#x27;<br>                                + &#x27;\n作者: Seon Fang&#x27;<br>                                + &#x27;\n邮箱: fx940415@163.com&#x27;<br>                                + &#x27;\n原文地址: &lt;%= page.permalink %&gt;&#x27;<br>    <br>                clipboardData.setData(&#x27;text/plain&#x27;, text + copyright);<br>    <br>              &#125; else &#123;<br>clipboardData.setData(&#x27;text/plain&#x27;, text);<br>  &#125;<br>          &#125;;<br>          var contents = document.getElementsByClassName(&quot;container-fluid nopadding-x&quot;);<br>          // 监听文章内容的copy事件<br>          contents[0].addEventListener(&#x27;copy&#x27;,function(e)&#123;<br>              setClipboardText(e);<br>          &#125;);<br>      &lt;/script&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure><p>以上步骤完成后即可测试效果。</p><h4 id="页脚增加网站运行时间">页脚增加网站运行时间</h4><p>找到<code>blog\node_modules\hexo-theme-fluid\layout\_partial</code>中的<code>footer.ejs</code>文件，打开后在任意位置加上如下代码，即可看到效果，网站运行时间动态增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs"> &lt;!-- 添加网站运行时间 --&gt;<br>&lt;div class=&quot;footer-content&quot;&gt;<br>    &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;<br>    &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;<br>    &lt;script&gt;<br>        var now = new Date();<br>        function createtime()&#123;<br>            var grt= new Date(&quot;04/05/2022 00:00:00&quot;);//此处修改你的建站时间或者网站上线时间<br>            now.setTime(now.getTime()+250);<br>            days = (now - grt ) / 1000 / 60 / 60 / 24;<br>            dnum = Math.floor(days);<br>            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);<br>            hnum = Math.floor(hours);<br>            if(String(hnum).length ==1 )&#123;<br>                hnum = &quot;0&quot; + hnum;<br>            &#125;<br>            minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);<br>            mnum = Math.floor(minutes);<br>            if(String(mnum).length ==1 )&#123;<br>                mnum = &quot;0&quot; + mnum;<br>            &#125;<br>            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);<br>            snum = Math.round(seconds);<br>            if(String(snum).length ==1 )&#123;<br>                snum = &quot;0&quot; + snum;<br>            &#125;<br>            document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;🚀 for&amp;nbsp&quot;+dnum+&quot;&amp;nbspdays&quot;;  //此次自定义显示内容<br>            document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot;&amp;nbsphr&amp;nbsp&quot; + mnum + &quot;&amp;nbspmin&amp;nbsp&quot; + snum + &quot;&amp;nbspsec&quot;;<br>        &#125;  //此次自定义显示内容<br>        setInterval(&quot;createtime()&quot;,250);<br>    &lt;/script&gt;<br>&lt;/div&gt;<br></code></pre></div></td></tr></table></figure><h4 id="设置网站全局字体为宋体">设置网站全局字体为宋体</h4><p>在<code>_config.fluid.yml</code>文件中<code>#主题字体配置处</code>做如下修改：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-attr">font:</span><br><span class="hljs-attr">font_family:</span> <span class="hljs-string">Noto</span> <span class="hljs-string">Serif</span> <span class="hljs-string">SC</span><br><span class="hljs-attr">custom_css:</span> <span class="hljs-string">https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap</span><br></code></pre></div></td></tr></table></figure><h3 id="常见错误">常见错误</h3><h4 id="格式错误">格式错误</h4><p>1.在使用<code>$</code>符号时，一定要用反引号括起来，不然<code>$</code>被解析成HTML文件时格式会出错。</p><p>比如"$1"应写成<code>$1</code></p><p>2.对命令选项加粗时，要在<code>-</code>字符前面加上转义<code>\</code>，不然解析HTML格式异常。</p><p>比如:<code>**-p选项**</code>应写成`<code>**\-p选项</code></p><p>类似的还有<code>**&gt;&gt;符号**</code>这中<code>**</code>与<code>&gt;</code>连在一起时，中间也要加上转义：<code>**\&gt;&gt;符号**</code>。</p><p>3.<code>$</code>想要加粗显示，可以用如下方式，注意后面两个加粗符号<code>**</code>要与之后的汉字或字母间隔一个空格位置：</p><p><code>**$\*** 和**\$@**变量可以用来轻松访问所有的参数</code></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
