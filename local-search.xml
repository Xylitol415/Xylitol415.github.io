<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/Algorithm/Base/"/>
    <url>/Algorithm/Base/</url>
    
    <content type="html"><![CDATA[<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="1-Java数组排序"><a href="#1-Java数组排序" class="headerlink" title="1.Java数组排序"></a>1.Java数组排序</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 从0到最后一位排序，默认升序</span><br>Arrays.sort(q);<br><span class="hljs-comment">// 指定范围排序[1,5)</span><br>Arrays.sort(q, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 从1到n排序，使用lambda表达式自定义排序规则：从大到小</span><br><span class="hljs-comment">// 使用Integer.compare()方法时，数组必须是Integer[]</span><br>Arrays.sort(q, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, (a, b) -&gt; Integer.compare(b, a));<br><span class="hljs-comment">// 使用Collections.reverseOrder()实现降序</span><br>Arrays.sort(q, Collections.reverseOrder());<br></code></pre></div></td></tr></table></figure><h5 id="2-List集合排序"><a href="#2-List集合排序" class="headerlink" title="2.List集合排序"></a>2.List集合排序</h5><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>步骤：</p><ol><li><p>确定分界点，把数组分成两部分。<br>常用的分界点有 数组第一个数，数组最后一个数，数组中间那个数<br>一般我会选用数组中间那个数作为分界点，这样后面的写法也固定了，不容易遇到边界问题。</p></li><li><p>根据分界点调整数组，使得分界点左边的数都小于等于分界点，分界点右边的数都大于等于分界点<br>方法：利用双指针的移动，左指针在左边大于分界点的数停下，右指针在右边小于分界点的数停下，交换这两个数。</p></li><li><p>分别递归处理左右两边。</p></li><li><p>时间复杂度为O(nlogn)。</p></li></ol><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;                  <span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>;                      <span class="hljs-comment">//左边的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> r + <span class="hljs-number">1</span>;                      <span class="hljs-comment">//右边的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>)];    <span class="hljs-comment">//选取数组中间的那个数作为分界点，把数组分成两部分</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i++;<br>        &#125;<span class="hljs-keyword">while</span>(arr[i] &lt; x);             <span class="hljs-comment">//在左边大于分界点的数停下</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            j--;<br>        &#125;<span class="hljs-keyword">while</span>(arr[j] &gt; x);             <span class="hljs-comment">//在右边小于分界点的数停下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;                      <span class="hljs-comment">//交换两个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    quickSort(arr,l,j);                 <span class="hljs-comment">//递归处理左边</span><br>    quickSort(arr,j+<span class="hljs-number">1</span>,r);               <span class="hljs-comment">//递归处理右边</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>步骤：</p><ol><li>将数组平均分成两部分（奇数个数的话就是一个为n/2个，一个为n/2+1个）。</li><li>分别递归地排序数组的这两部分。</li><li>将排好序的两部分归并成一整块。<br>方法：利用双指针的移动，将两部分中更小的那个数存到临时存储数组中。</li><li>时间复杂度为O(nlogn)。</li></ol><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;                      <span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l)/<span class="hljs-number">2</span>;                <span class="hljs-comment">//将数组分成[L,mid] 和 [mid+1,R] 两部分</span><br>    mergeSort(arr,l,mid);                   <span class="hljs-comment">//递归排序左半部分</span><br>    mergeSort(arr,mid+<span class="hljs-number">1</span>,r);                 <span class="hljs-comment">//递归排序右半部分</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;                              <span class="hljs-comment">//左半部分的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;                        <span class="hljs-comment">//右半部分的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">//临时存储数组的索引</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;              <span class="hljs-comment">//循环找到两部分中更小的那个数</span><br>        <span class="hljs-keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">else</span> temp[k++] = arr[j++];          <span class="hljs-comment">//temp为临时存储数组</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = arr[i++];   <span class="hljs-comment">//把左半部分没存入的数存到临时存储数组中</span><br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = arr[j++];     <span class="hljs-comment">//把右半部分没存入的数存到临时存储数组中</span><br>    <span class="hljs-keyword">for</span>(i = l,j = <span class="hljs-number">0</span>; i &lt;= r; i++,j++)&#123;      <span class="hljs-comment">//将临时存储数组中排好序的数复制到原数组中</span><br>        arr[i] = temp[j];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p><strong>思路</strong>：首先建立一个堆，从n/2位置开始，不断的down直到1，构造一个小顶堆，每一次输出堆中第一个元素，然后将第一个元素与最后一个元素进行交换，删掉最后一个元素，再次维护堆就可以了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-comment">// 向下调整</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">while</span>(pos &lt;= n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> pos;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> pos &lt;&lt; <span class="hljs-number">1</span>, right = pos &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(left &lt;= n &amp;&amp; q[left] &lt; q[temp]) temp = left;<br>        <span class="hljs-keyword">if</span>(right &lt;= n &amp;&amp; q[right] &lt; q[temp]) temp = right;<br>        <span class="hljs-keyword">if</span>(temp == pos) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[temp];<br>        q[temp] = q[pos];<br>        q[pos] = t;<br>        pos = temp;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">// 建堆</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n &gt;&gt; <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) downHeap(i, n);<br></code></pre></div></td></tr></table></figure><h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>二分就是把区间划分成两部分，我把这两部分分别记为left 和 right。满足left就一定不满足right，满足right就一定不满足left。</p><p>整数二分：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//check(mid)是对mid处的数进行判断。</span><br><span class="hljs-comment">//若符合right，答案就在left。即binarySearch1</span><br><span class="hljs-comment">//若符合left，答案就在right。即binarySearch2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;      <br>        <span class="hljs-keyword">if</span>(check(mid)) r = mid;        <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;               <br>    &#125;<br>    <span class="hljs-keyword">return</span> l;                          <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid;         <br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;               <br>    &#125;<br>    <span class="hljs-keyword">return</span> l;  <br>&#125;<br></code></pre></div></td></tr></table></figure><p>实数二分</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-title function_">binarySearch3</span><span class="hljs-params">(<span class="hljs-type">double</span> l,<span class="hljs-type">double</span> r)</span>&#123;<br>    <span class="hljs-type">double</span> eps;<span class="hljs-comment">//根据题目设置精度，一般是题目精度的1e-2倍</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; eps)&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//对于大数，Java可以轻松解决，因为在Java中,math包下有BigInteger这个类</span><br><span class="hljs-comment">//构造器：new BigInteger(String s);</span><br><br><span class="hljs-comment">// BigInteger a;</span><br><span class="hljs-comment">// BigInteger b;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">加法：a.add(b)</span><br><span class="hljs-comment">减法：a.subtract(b)</span><br><span class="hljs-comment">乘法：a.multiply(b)</span><br><span class="hljs-comment">除法：a.divide(b)</span><br><span class="hljs-comment">取余：a.mod(b)</span><br><span class="hljs-comment">比较：a.compareTo(b)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + GitHub搭建博客</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p><a href="https://hexo.io/zh-cn/">Hexo</a>是一款快速、简洁且高效的博客框架，有如下特点：</p><ul><li><strong>超快速度</strong>：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li><li><strong>支持 Markdown</strong>：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li><li><strong>一键部署</strong>：只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</li><li><strong>插件和可扩展性</strong>：强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></div></td></tr></table></figure><p>环境准备：Node.js, git, npm, nvm(非必须)。</p><p>操作文档参考：<a href="https://hexo.io/zh-cn/docs/">文档</a></p><p>官方收录主题：<a href="https://hexo.io/themes/">主题</a></p><p>本博客使用主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></p><p>一键部署：<a href="https://hexo.io/zh-cn/docs/one-command-deployment">部署</a></p><h4 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h4><p>官方手册：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
